#include "image.h"
//using namespace std;
uint16_t f[10 * CAMERA_H];//考察连通域联通性

uint8_t* fullBuffer = &mt9v034_image[0][0];

//每个白条子属性

int state = 0;


int carParkX;
int carParkTimes = 0;
int carParkDelay = 0;
int lastJumpPoint;
int lastK_up, lastK_jump;
int myIslandFlag = 0;
int count = 0;
int speedFlag = 0;
int lastStraight = 0;

all_range white_range[CAMERA_H];//所有白条子
road my_road[CAMERA_H];//赛道
uint8_t IMG[CAMERA_H][CAMERA_W];//二值化后图像数组
uint8_t left_line[CAMERA_H], right_line[CAMERA_H];//赛道的左右边界
uint8_t mid_line[CAMERA_H];
//uint8_t last_mid_line[CAMERA_H];
//road_noise swell;
int all_connect_num = 0;//所有白条子数

uint8_t top_road;//赛道最高处所在行数
uint8_t threshold = 80;//;//阈值
uint8_t thresholdUp;
uint8_t thresholdDown;
uint8_t midDownDistance = 0;
uint8_t midTimes = 0;


int FolkRoadWhere = RIGHT;
int islandWhere;
int TWhere;
int TIslandWhere;
int TFlag = 0;

int stopFlag = 0;
uint8_t stopCount = 0;
uint8_t j_continue[CAMERA_H];

int leftDownJumpPoint;//寻找左下角的拐点的行数
int leftUpJumpPoint;//寻找左上角的拐点的行数
int rightDownJumpPoint;//寻找右下角的拐点的行数
int rightUpJumpPoint;//寻找右下角的拐点的行数
int flagJumpPoint;//跳跃点的个数
int lastUpPoint = 0;

//三叉
int upSharpPoint = 119;
int leftSharpPoint = 119;
int rightSharpPoint = 119;
uint8_t folkTimes = 0;

//车库
int parkPosition = 0;
int leftPark = 0, rightPark = 0;
//uint8_t missLeft[CAMERA_H];
//uint8_t missRight[CAMERA_H];

int crossCircleCount = 0;


int straightFlag = 0, lastStraightFlag = 0;
int slowFlag = 0;
int rampFlag1 = 0, rampFlag2 = 0,rampFlag3 = 0;
int parkJudgeCount = 0;
int rampWayCount = 0;
int rampJudgeCount=199;
int lastTwoState=0;
int laststate = 0;
uint8_t memoryFlag = 0;
uint16_t memoryState[20] = {0};
float p_last = 0;
uint8_t averMidLine;
uint8_t sRoadFlag = 0;
uint8_t sRoadCount = 0;
uint8_t thresholdAdapt[8];
int forceOut = 0;
//uint8_t ForeSee = 35;
//coordinate foreSee[CAMERA_W];
uint8_t Loud=0;
uint8_t islandTimes = 0, IslandRadius = 0;
uint8_t minThre, maxThre;
uint8_t islandCircleCount = 0;
uint8_t tInCount = 0;
int threOriginal;
int flagIT = 0;
int wayIT = 1; //回环之后一定是环岛，我们用+-1来决定，1肯定是环岛，-1是回环 由发车方向决定
uint8_t tCrossStatus = 0;
uint8_t tCrossTimes = 0;
uint8_t rampTimes = 0;
uint8_t myParkLine = 0;
uint8_t parkSlowDownCount = 0;
uint8_t car_stop = 0;
int flagSee = 0;
uint8_t afterRampFlag = 0;
uint8_t folkCNT = 0;
uint8_t islandTimesCNT = 0;
uint8_t islandFinalTimes = 0;
uint8_t folkOutTimes = 0;
uint8_t speedUpPhase = 0; //省赛记忆加速
//road my_road[CAMERA_H];
//uint8_t IMG_zebra[36][CAMERA_W];
//uint8_t zebraFlag;
//uint8_t zebraCircle;
const uint8_t left_side[CHANGED_H] = { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,4,4,4,8,8,8,8,12,12,12,12,16,16,16,16,20,20,20,23,23,23,25,25,25,28,28,31,31,31,33,33,35,35,37,37,39,39,40,42,42,43,45,45,46,47,49,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80 };
const uint8_t right_side[CHANGED_H] = { 187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,183,183,183,183,183,179,179,179,179,175,175,175,175,171,171,171,171,167,167,167,164,164,164,162,162,162,159,159,156,156,156,154,154,152,152,150,150,148,148,147,145,145,144,142,142,141,140,138,138,137,136,135,134,133,132,131,130,129,128,127,126,125,124,123,122,121,120,119,118,117,116,115,114,113,112,111,110,109,108,107 };

const uint8_t transform_y[CAMERA_H][CAMERA_W] = { {  31,  31,  32,  33,  34,  34,  35,  35,  35,  36,  37,  38,  38,  39,  40,  40,  40,  41,  42,  42,  43,  44,  44,  45,  46,  47,  47,  48,  49,  49,  49,  50,  51,  51,  52,  53,  53,  54,  55,  56,  56,  57,  58,  58,  59,  60,  61,  61,  62,  63,  63,  64,  65,  66,  66,  66,  67,  67,  68,  69,  70,  70,  71,  72,  72,  73,  74,  75,  75,  76,  77,  77,  78,  79,  80,  80,  81,  82,  82,  83,  84,  85,  85,  86,  87,  87,  88,  89,  90,  90,  91,  92,  92,  93,  94,  95,  95,  96,  97,  97,  98,  99, 100, 100, 101, 102, 102, 103, 104, 105, 105, 106, 107, 107, 108, 109, 110, 110, 111, 112, 112, 113, 114, 115, 115, 116, 117, 117, 118, 119, 120, 120, 121, 122, 122, 123, 124, 125, 125, 126, 127, 127, 127, 128, 129, 129, 130, 131, 131, 132, 133, 134, 134, 135, 136, 136, 137, 138, 139, 139, 140, 141, 141, 142, 143, 143, 143, 144, 145, 145, 146, 147, 148, 148, 149, 150, 150, 151, 152, 152, 152, 153, 154, 154, 155, 156, 157, 157},
{  31,  31,  32,  33,  34,  34,  35,  35,  35,  36,  37,  38,  38,  39,  40,  40,  40,  41,  42,  42,  43,  44,  44,  45,  46,  47,  47,  48,  49,  49,  49,  50,  51,  51,  52,  53,  53,  54,  55,  56,  56,  57,  58,  58,  59,  60,  61,  61,  62,  63,  63,  64,  65,  66,  66,  66,  67,  67,  68,  69,  70,  70,  71,  72,  72,  73,  74,  75,  75,  76,  77,  77,  78,  79,  80,  80,  81,  82,  82,  83,  84,  85,  85,  86,  87,  87,  88,  89,  90,  90,  91,  92,  92,  93,  94,  95,  95,  96,  97,  97,  98,  99, 100, 100, 101, 102, 102, 103, 104, 105, 105, 106, 107, 107, 108, 109, 110, 110, 111, 112, 112, 113, 114, 115, 115, 116, 117, 117, 118, 119, 120, 120, 121, 122, 122, 123, 124, 125, 125, 126, 127, 127, 127, 128, 129, 129, 130, 131, 131, 132, 133, 134, 134, 135, 136, 136, 137, 138, 139, 139, 140, 141, 141, 142, 143, 143, 143, 144, 145, 145, 146, 147, 148, 148, 149, 150, 150, 151, 152, 152, 152, 153, 154, 154, 155, 156, 157, 157},
{  31,  31,  32,  33,  34,  34,  35,  35,  35,  36,  37,  38,  38,  39,  40,  40,  40,  41,  42,  42,  43,  44,  44,  45,  46,  47,  47,  48,  49,  49,  49,  50,  51,  51,  52,  53,  53,  54,  55,  56,  56,  57,  58,  58,  59,  60,  61,  61,  62,  63,  63,  64,  65,  66,  66,  66,  67,  67,  68,  69,  70,  70,  71,  72,  72,  73,  74,  75,  75,  76,  77,  77,  78,  79,  80,  80,  81,  82,  82,  83,  84,  85,  85,  86,  87,  87,  88,  89,  90,  90,  91,  92,  92,  93,  94,  95,  95,  96,  97,  97,  98,  99, 100, 100, 101, 102, 102, 103, 104, 105, 105, 106, 107, 107, 108, 109, 110, 110, 111, 112, 112, 113, 114, 115, 115, 116, 117, 117, 118, 119, 120, 120, 121, 122, 122, 123, 124, 125, 125, 126, 127, 127, 127, 128, 129, 129, 130, 131, 131, 132, 133, 134, 134, 135, 136, 136, 137, 138, 139, 139, 140, 141, 141, 142, 143, 143, 143, 144, 145, 145, 146, 147, 148, 148, 149, 150, 150, 151, 152, 152, 152, 153, 154, 154, 155, 156, 157, 157},
{  31,  31,  32,  33,  34,  34,  35,  35,  35,  36,  37,  38,  38,  39,  40,  40,  40,  41,  42,  42,  43,  44,  44,  45,  46,  47,  47,  48,  49,  49,  49,  50,  51,  51,  52,  53,  53,  54,  55,  56,  56,  57,  58,  58,  59,  60,  61,  61,  62,  63,  63,  64,  65,  66,  66,  66,  67,  67,  68,  69,  70,  70,  71,  72,  72,  73,  74,  75,  75,  76,  77,  77,  78,  79,  80,  80,  81,  82,  82,  83,  84,  85,  85,  86,  87,  87,  88,  89,  90,  90,  91,  92,  92,  93,  94,  95,  95,  96,  97,  97,  98,  99, 100, 100, 101, 102, 102, 103, 104, 105, 105, 106, 107, 107, 108, 109, 110, 110, 111, 112, 112, 113, 114, 115, 115, 116, 117, 117, 118, 119, 120, 120, 121, 122, 122, 123, 124, 125, 125, 126, 127, 127, 127, 128, 129, 129, 130, 131, 131, 132, 133, 134, 134, 135, 136, 136, 137, 138, 139, 139, 140, 141, 141, 142, 143, 143, 143, 144, 145, 145, 146, 147, 148, 148, 149, 150, 150, 151, 152, 152, 152, 153, 154, 154, 155, 156, 157, 157},
{  31,  31,  32,  33,  34,  34,  35,  35,  35,  36,  37,  38,  38,  39,  40,  40,  40,  41,  42,  42,  43,  44,  44,  45,  46,  47,  47,  48,  49,  49,  49,  50,  51,  51,  52,  53,  53,  54,  55,  56,  56,  57,  58,  58,  59,  60,  61,  61,  62,  63,  63,  64,  65,  66,  66,  66,  67,  67,  68,  69,  70,  70,  71,  72,  72,  73,  74,  75,  75,  76,  77,  77,  78,  79,  80,  80,  81,  82,  82,  83,  84,  85,  85,  86,  87,  87,  88,  89,  90,  90,  91,  92,  92,  93,  94,  95,  95,  96,  97,  97,  98,  99, 100, 100, 101, 102, 102, 103, 104, 105, 105, 106, 107, 107, 108, 109, 110, 110, 111, 112, 112, 113, 114, 115, 115, 116, 117, 117, 118, 119, 120, 120, 121, 122, 122, 123, 124, 125, 125, 126, 127, 127, 127, 128, 129, 129, 130, 131, 131, 132, 133, 134, 134, 135, 136, 136, 137, 138, 139, 139, 140, 141, 141, 142, 143, 143, 143, 144, 145, 145, 146, 147, 148, 148, 149, 150, 150, 151, 152, 152, 152, 153, 154, 154, 155, 156, 157, 157},
{  27,  27,  28,  29,  30,  30,  30,  31,  32,  32,  33,  34,  34,  35,  35,  36,  37,  38,  38,  39,  40,  40,  40,  41,  42,  43,  44,  44,  45,  46,  47,  47,  48,  48,  49,  49,  50,  51,  52,  53,  53,  54,  55,  56,  56,  57,  58,  59,  59,  60,  61,  62,  63,  63,  64,  65,  65,  65,  66,  67,  68,  68,  69,  70,  71,  72,  72,  73,  74,  75,  75,  76,  77,  78,  78,  79,  80,  81,  82,  82,  83,  84,  85,  85,  86,  87,  88,  88,  89,  90,  91,  92,  92,  93,  94,  95,  95,  96,  97,  98,  99,  99, 100, 101, 102, 102, 103, 104, 105, 105, 106, 107, 108, 109, 109, 110, 111, 112, 112, 113, 114, 115, 115, 116, 117, 118, 119, 119, 120, 121, 122, 122, 123, 124, 125, 125, 126, 127, 127, 128, 128, 129, 130, 131, 131, 132, 133, 134, 134, 135, 136, 137, 138, 138, 139, 140, 141, 141, 142, 143, 144, 144, 144, 145, 146, 147, 147, 148, 149, 150, 150, 151, 152, 152, 152, 153, 154, 155, 156, 156, 157, 157, 158, 158, 159, 160, 161, 161},
{  27,  27,  28,  29,  30,  30,  30,  31,  32,  32,  33,  34,  34,  35,  35,  36,  37,  38,  38,  39,  40,  40,  40,  41,  42,  43,  44,  44,  45,  46,  47,  47,  48,  48,  49,  49,  50,  51,  52,  53,  53,  54,  55,  56,  56,  57,  58,  59,  59,  60,  61,  62,  63,  63,  64,  65,  65,  65,  66,  67,  68,  68,  69,  70,  71,  72,  72,  73,  74,  75,  75,  76,  77,  78,  78,  79,  80,  81,  82,  82,  83,  84,  85,  85,  86,  87,  88,  88,  89,  90,  91,  92,  92,  93,  94,  95,  95,  96,  97,  98,  99,  99, 100, 101, 102, 102, 103, 104, 105, 105, 106, 107, 108, 109, 109, 110, 111, 112, 112, 113, 114, 115, 115, 116, 117, 118, 119, 119, 120, 121, 122, 122, 123, 124, 125, 125, 126, 127, 127, 128, 128, 129, 130, 131, 131, 132, 133, 134, 134, 135, 136, 137, 138, 138, 139, 140, 141, 141, 142, 143, 144, 144, 144, 145, 146, 147, 147, 148, 149, 150, 150, 151, 152, 152, 152, 153, 154, 155, 156, 156, 157, 157, 158, 158, 159, 160, 161, 161},
{  27,  27,  28,  29,  30,  30,  30,  31,  32,  32,  33,  34,  34,  35,  35,  36,  37,  38,  38,  39,  40,  40,  40,  41,  42,  43,  44,  44,  45,  46,  47,  47,  48,  48,  49,  49,  50,  51,  52,  53,  53,  54,  55,  56,  56,  57,  58,  59,  59,  60,  61,  62,  63,  63,  64,  65,  65,  65,  66,  67,  68,  68,  69,  70,  71,  72,  72,  73,  74,  75,  75,  76,  77,  78,  78,  79,  80,  81,  82,  82,  83,  84,  85,  85,  86,  87,  88,  88,  89,  90,  91,  92,  92,  93,  94,  95,  95,  96,  97,  98,  99,  99, 100, 101, 102, 102, 103, 104, 105, 105, 106, 107, 108, 109, 109, 110, 111, 112, 112, 113, 114, 115, 115, 116, 117, 118, 119, 119, 120, 121, 122, 122, 123, 124, 125, 125, 126, 127, 127, 128, 128, 129, 130, 131, 131, 132, 133, 134, 134, 135, 136, 137, 138, 138, 139, 140, 141, 141, 142, 143, 144, 144, 144, 145, 146, 147, 147, 148, 149, 150, 150, 151, 152, 152, 152, 153, 154, 155, 156, 156, 157, 157, 158, 158, 159, 160, 161, 161},
{  27,  27,  28,  29,  30,  30,  30,  31,  32,  32,  33,  34,  34,  35,  35,  36,  37,  38,  38,  39,  40,  40,  40,  41,  42,  43,  44,  44,  45,  46,  47,  47,  48,  48,  49,  49,  50,  51,  52,  53,  53,  54,  55,  56,  56,  57,  58,  59,  59,  60,  61,  62,  63,  63,  64,  65,  65,  65,  66,  67,  68,  68,  69,  70,  71,  72,  72,  73,  74,  75,  75,  76,  77,  78,  78,  79,  80,  81,  82,  82,  83,  84,  85,  85,  86,  87,  88,  88,  89,  90,  91,  92,  92,  93,  94,  95,  95,  96,  97,  98,  99,  99, 100, 101, 102, 102, 103, 104, 105, 105, 106, 107, 108, 109, 109, 110, 111, 112, 112, 113, 114, 115, 115, 116, 117, 118, 119, 119, 120, 121, 122, 122, 123, 124, 125, 125, 126, 127, 127, 128, 128, 129, 130, 131, 131, 132, 133, 134, 134, 135, 136, 137, 138, 138, 139, 140, 141, 141, 142, 143, 144, 144, 144, 145, 146, 147, 147, 148, 149, 150, 150, 151, 152, 152, 152, 153, 154, 155, 156, 156, 157, 157, 158, 158, 159, 160, 161, 161},
{  27,  27,  28,  29,  30,  30,  30,  31,  32,  32,  33,  34,  34,  35,  35,  36,  37,  38,  38,  39,  40,  40,  40,  41,  42,  43,  44,  44,  45,  46,  47,  47,  48,  48,  49,  49,  50,  51,  52,  53,  53,  54,  55,  56,  56,  57,  58,  59,  59,  60,  61,  62,  63,  63,  64,  65,  65,  65,  66,  67,  68,  68,  69,  70,  71,  72,  72,  73,  74,  75,  75,  76,  77,  78,  78,  79,  80,  81,  82,  82,  83,  84,  85,  85,  86,  87,  88,  88,  89,  90,  91,  92,  92,  93,  94,  95,  95,  96,  97,  98,  99,  99, 100, 101, 102, 102, 103, 104, 105, 105, 106, 107, 108, 109, 109, 110, 111, 112, 112, 113, 114, 115, 115, 116, 117, 118, 119, 119, 120, 121, 122, 122, 123, 124, 125, 125, 126, 127, 127, 128, 128, 129, 130, 131, 131, 132, 133, 134, 134, 135, 136, 137, 138, 138, 139, 140, 141, 141, 142, 143, 144, 144, 144, 145, 146, 147, 147, 148, 149, 150, 150, 151, 152, 152, 152, 153, 154, 155, 156, 156, 157, 157, 158, 158, 159, 160, 161, 161},
{  27,  27,  28,  29,  30,  30,  30,  31,  32,  32,  33,  34,  34,  35,  35,  36,  37,  38,  38,  39,  40,  40,  40,  41,  42,  43,  44,  44,  45,  46,  47,  47,  48,  48,  49,  49,  50,  51,  52,  53,  53,  54,  55,  56,  56,  57,  58,  59,  59,  60,  61,  62,  63,  63,  64,  65,  65,  65,  66,  67,  68,  68,  69,  70,  71,  72,  72,  73,  74,  75,  75,  76,  77,  78,  78,  79,  80,  81,  82,  82,  83,  84,  85,  85,  86,  87,  88,  88,  89,  90,  91,  92,  92,  93,  94,  95,  95,  96,  97,  98,  99,  99, 100, 101, 102, 102, 103, 104, 105, 105, 106, 107, 108, 109, 109, 110, 111, 112, 112, 113, 114, 115, 115, 116, 117, 118, 119, 119, 120, 121, 122, 122, 123, 124, 125, 125, 126, 127, 127, 128, 128, 129, 130, 131, 131, 132, 133, 134, 134, 135, 136, 137, 138, 138, 139, 140, 141, 141, 142, 143, 144, 144, 144, 145, 146, 147, 147, 148, 149, 150, 150, 151, 152, 152, 152, 153, 154, 155, 156, 156, 157, 157, 158, 158, 159, 160, 161, 161},
{  27,  27,  28,  29,  30,  30,  30,  31,  32,  32,  33,  34,  34,  35,  35,  36,  37,  38,  38,  39,  40,  40,  40,  41,  42,  43,  44,  44,  45,  46,  47,  47,  48,  48,  49,  49,  50,  51,  52,  53,  53,  54,  55,  56,  56,  57,  58,  59,  59,  60,  61,  62,  63,  63,  64,  65,  65,  65,  66,  67,  68,  68,  69,  70,  71,  72,  72,  73,  74,  75,  75,  76,  77,  78,  78,  79,  80,  81,  82,  82,  83,  84,  85,  85,  86,  87,  88,  88,  89,  90,  91,  92,  92,  93,  94,  95,  95,  96,  97,  98,  99,  99, 100, 101, 102, 102, 103, 104, 105, 105, 106, 107, 108, 109, 109, 110, 111, 112, 112, 113, 114, 115, 115, 116, 117, 118, 119, 119, 120, 121, 122, 122, 123, 124, 125, 125, 126, 127, 127, 128, 128, 129, 130, 131, 131, 132, 133, 134, 134, 135, 136, 137, 138, 138, 139, 140, 141, 141, 142, 143, 144, 144, 144, 145, 146, 147, 147, 148, 149, 150, 150, 151, 152, 152, 152, 153, 154, 155, 156, 156, 157, 157, 158, 158, 159, 160, 161, 161},
{  27,  27,  28,  29,  30,  30,  30,  31,  32,  32,  33,  34,  34,  35,  35,  36,  37,  38,  38,  39,  40,  40,  40,  41,  42,  43,  44,  44,  45,  46,  47,  47,  48,  48,  49,  49,  50,  51,  52,  53,  53,  54,  55,  56,  56,  57,  58,  59,  59,  60,  61,  62,  63,  63,  64,  65,  65,  65,  66,  67,  68,  68,  69,  70,  71,  72,  72,  73,  74,  75,  75,  76,  77,  78,  78,  79,  80,  81,  82,  82,  83,  84,  85,  85,  86,  87,  88,  88,  89,  90,  91,  92,  92,  93,  94,  95,  95,  96,  97,  98,  99,  99, 100, 101, 102, 102, 103, 104, 105, 105, 106, 107, 108, 109, 109, 110, 111, 112, 112, 113, 114, 115, 115, 116, 117, 118, 119, 119, 120, 121, 122, 122, 123, 124, 125, 125, 126, 127, 127, 128, 128, 129, 130, 131, 131, 132, 133, 134, 134, 135, 136, 137, 138, 138, 139, 140, 141, 141, 142, 143, 144, 144, 144, 145, 146, 147, 147, 148, 149, 150, 150, 151, 152, 152, 152, 153, 154, 155, 156, 156, 157, 157, 158, 158, 159, 160, 161, 161},
{  27,  27,  28,  29,  30,  30,  30,  31,  32,  32,  33,  34,  34,  35,  35,  36,  37,  38,  38,  39,  40,  40,  40,  41,  42,  43,  44,  44,  45,  46,  47,  47,  48,  48,  49,  49,  50,  51,  52,  53,  53,  54,  55,  56,  56,  57,  58,  59,  59,  60,  61,  62,  63,  63,  64,  65,  65,  65,  66,  67,  68,  68,  69,  70,  71,  72,  72,  73,  74,  75,  75,  76,  77,  78,  78,  79,  80,  81,  82,  82,  83,  84,  85,  85,  86,  87,  88,  88,  89,  90,  91,  92,  92,  93,  94,  95,  95,  96,  97,  98,  99,  99, 100, 101, 102, 102, 103, 104, 105, 105, 106, 107, 108, 109, 109, 110, 111, 112, 112, 113, 114, 115, 115, 116, 117, 118, 119, 119, 120, 121, 122, 122, 123, 124, 125, 125, 126, 127, 127, 128, 128, 129, 130, 131, 131, 132, 133, 134, 134, 135, 136, 137, 138, 138, 139, 140, 141, 141, 142, 143, 144, 144, 144, 145, 146, 147, 147, 148, 149, 150, 150, 151, 152, 152, 152, 153, 154, 155, 156, 156, 157, 157, 158, 158, 159, 160, 161, 161},
{  23,  24,  24,  25,  26,  26,  26,  27,  28,  29,  30,  30,  30,  31,  32,  33,  33,  34,  34,  35,  36,  37,  37,  38,  39,  39,  40,  41,  41,  42,  43,  44,  45,  46,  46,  47,  48,  48,  49,  49,  50,  51,  52,  53,  54,  54,  55,  56,  57,  58,  59,  59,  60,  61,  62,  63,  64,  64,  65,  65,  66,  67,  67,  68,  69,  70,  71,  72,  72,  73,  74,  75,  76,  77,  77,  78,  79,  80,  81,  82,  82,  83,  84,  85,  86,  86,  87,  88,  89,  90,  91,  91,  92,  93,  94,  95,  96,  96,  97,  98,  99, 100, 101, 101, 102, 103, 104, 105, 105, 106, 107, 108, 109, 110, 110, 111, 112, 113, 114, 115, 115, 116, 117, 118, 119, 120, 120, 121, 122, 123, 124, 124, 125, 126, 127, 128, 128, 128, 129, 130, 131, 132, 133, 133, 134, 135, 136, 137, 138, 138, 139, 140, 141, 142, 142, 143, 144, 144, 145, 146, 146, 147, 148, 149, 150, 151, 151, 152, 153, 153, 154, 155, 155, 156, 157, 158, 158, 158, 159, 160, 161, 162, 162, 162, 163, 164, 165, 165},
{  23,  24,  24,  25,  26,  26,  26,  27,  28,  29,  30,  30,  30,  31,  32,  33,  33,  34,  34,  35,  36,  37,  37,  38,  39,  39,  40,  41,  41,  42,  43,  44,  45,  46,  46,  47,  48,  48,  49,  49,  50,  51,  52,  53,  54,  54,  55,  56,  57,  58,  59,  59,  60,  61,  62,  63,  64,  64,  65,  65,  66,  67,  67,  68,  69,  70,  71,  72,  72,  73,  74,  75,  76,  77,  77,  78,  79,  80,  81,  82,  82,  83,  84,  85,  86,  86,  87,  88,  89,  90,  91,  91,  92,  93,  94,  95,  96,  96,  97,  98,  99, 100, 101, 101, 102, 103, 104, 105, 105, 106, 107, 108, 109, 110, 110, 111, 112, 113, 114, 115, 115, 116, 117, 118, 119, 120, 120, 121, 122, 123, 124, 124, 125, 126, 127, 128, 128, 128, 129, 130, 131, 132, 133, 133, 134, 135, 136, 137, 138, 138, 139, 140, 141, 142, 142, 143, 144, 144, 145, 146, 146, 147, 148, 149, 150, 151, 151, 152, 153, 153, 154, 155, 155, 156, 157, 158, 158, 158, 159, 160, 161, 162, 162, 162, 163, 164, 165, 165},
{  23,  24,  24,  25,  26,  26,  26,  27,  28,  29,  30,  30,  30,  31,  32,  33,  33,  34,  34,  35,  36,  37,  37,  38,  39,  39,  40,  41,  41,  42,  43,  44,  45,  46,  46,  47,  48,  48,  49,  49,  50,  51,  52,  53,  54,  54,  55,  56,  57,  58,  59,  59,  60,  61,  62,  63,  64,  64,  65,  65,  66,  67,  67,  68,  69,  70,  71,  72,  72,  73,  74,  75,  76,  77,  77,  78,  79,  80,  81,  82,  82,  83,  84,  85,  86,  86,  87,  88,  89,  90,  91,  91,  92,  93,  94,  95,  96,  96,  97,  98,  99, 100, 101, 101, 102, 103, 104, 105, 105, 106, 107, 108, 109, 110, 110, 111, 112, 113, 114, 115, 115, 116, 117, 118, 119, 120, 120, 121, 122, 123, 124, 124, 125, 126, 127, 128, 128, 128, 129, 130, 131, 132, 133, 133, 134, 135, 136, 137, 138, 138, 139, 140, 141, 142, 142, 143, 144, 144, 145, 146, 146, 147, 148, 149, 150, 151, 151, 152, 153, 153, 154, 155, 155, 156, 157, 158, 158, 158, 159, 160, 161, 162, 162, 162, 163, 164, 165, 165},
{  23,  24,  24,  25,  26,  26,  26,  27,  28,  29,  30,  30,  30,  31,  32,  33,  33,  34,  34,  35,  36,  37,  37,  38,  39,  39,  40,  41,  41,  42,  43,  44,  45,  46,  46,  47,  48,  48,  49,  49,  50,  51,  52,  53,  54,  54,  55,  56,  57,  58,  59,  59,  60,  61,  62,  63,  64,  64,  65,  65,  66,  67,  67,  68,  69,  70,  71,  72,  72,  73,  74,  75,  76,  77,  77,  78,  79,  80,  81,  82,  82,  83,  84,  85,  86,  86,  87,  88,  89,  90,  91,  91,  92,  93,  94,  95,  96,  96,  97,  98,  99, 100, 101, 101, 102, 103, 104, 105, 105, 106, 107, 108, 109, 110, 110, 111, 112, 113, 114, 115, 115, 116, 117, 118, 119, 120, 120, 121, 122, 123, 124, 124, 125, 126, 127, 128, 128, 128, 129, 130, 131, 132, 133, 133, 134, 135, 136, 137, 138, 138, 139, 140, 141, 142, 142, 143, 144, 144, 145, 146, 146, 147, 148, 149, 150, 151, 151, 152, 153, 153, 154, 155, 155, 156, 157, 158, 158, 158, 159, 160, 161, 162, 162, 162, 163, 164, 165, 165},
{  23,  24,  24,  25,  26,  26,  26,  27,  28,  29,  30,  30,  30,  31,  32,  33,  33,  34,  34,  35,  36,  37,  37,  38,  39,  39,  40,  41,  41,  42,  43,  44,  45,  46,  46,  47,  48,  48,  49,  49,  50,  51,  52,  53,  54,  54,  55,  56,  57,  58,  59,  59,  60,  61,  62,  63,  64,  64,  65,  65,  66,  67,  67,  68,  69,  70,  71,  72,  72,  73,  74,  75,  76,  77,  77,  78,  79,  80,  81,  82,  82,  83,  84,  85,  86,  86,  87,  88,  89,  90,  91,  91,  92,  93,  94,  95,  96,  96,  97,  98,  99, 100, 101, 101, 102, 103, 104, 105, 105, 106, 107, 108, 109, 110, 110, 111, 112, 113, 114, 115, 115, 116, 117, 118, 119, 120, 120, 121, 122, 123, 124, 124, 125, 126, 127, 128, 128, 128, 129, 130, 131, 132, 133, 133, 134, 135, 136, 137, 138, 138, 139, 140, 141, 142, 142, 143, 144, 144, 145, 146, 146, 147, 148, 149, 150, 151, 151, 152, 153, 153, 154, 155, 155, 156, 157, 158, 158, 158, 159, 160, 161, 162, 162, 162, 163, 164, 165, 165},
{  23,  24,  24,  25,  26,  26,  26,  27,  28,  29,  30,  30,  30,  31,  32,  33,  33,  34,  34,  35,  36,  37,  37,  38,  39,  39,  40,  41,  41,  42,  43,  44,  45,  46,  46,  47,  48,  48,  49,  49,  50,  51,  52,  53,  54,  54,  55,  56,  57,  58,  59,  59,  60,  61,  62,  63,  64,  64,  65,  65,  66,  67,  67,  68,  69,  70,  71,  72,  72,  73,  74,  75,  76,  77,  77,  78,  79,  80,  81,  82,  82,  83,  84,  85,  86,  86,  87,  88,  89,  90,  91,  91,  92,  93,  94,  95,  96,  96,  97,  98,  99, 100, 101, 101, 102, 103, 104, 105, 105, 106, 107, 108, 109, 110, 110, 111, 112, 113, 114, 115, 115, 116, 117, 118, 119, 120, 120, 121, 122, 123, 124, 124, 125, 126, 127, 128, 128, 128, 129, 130, 131, 132, 133, 133, 134, 135, 136, 137, 138, 138, 139, 140, 141, 142, 142, 143, 144, 144, 145, 146, 146, 147, 148, 149, 150, 151, 151, 152, 153, 153, 154, 155, 155, 156, 157, 158, 158, 158, 159, 160, 161, 162, 162, 162, 163, 164, 165, 165},
{  23,  24,  24,  25,  26,  26,  26,  27,  28,  29,  30,  30,  30,  31,  32,  33,  33,  34,  34,  35,  36,  37,  37,  38,  39,  39,  40,  41,  41,  42,  43,  44,  45,  46,  46,  47,  48,  48,  49,  49,  50,  51,  52,  53,  54,  54,  55,  56,  57,  58,  59,  59,  60,  61,  62,  63,  64,  64,  65,  65,  66,  67,  67,  68,  69,  70,  71,  72,  72,  73,  74,  75,  76,  77,  77,  78,  79,  80,  81,  82,  82,  83,  84,  85,  86,  86,  87,  88,  89,  90,  91,  91,  92,  93,  94,  95,  96,  96,  97,  98,  99, 100, 101, 101, 102, 103, 104, 105, 105, 106, 107, 108, 109, 110, 110, 111, 112, 113, 114, 115, 115, 116, 117, 118, 119, 120, 120, 121, 122, 123, 124, 124, 125, 126, 127, 128, 128, 128, 129, 130, 131, 132, 133, 133, 134, 135, 136, 137, 138, 138, 139, 140, 141, 142, 142, 143, 144, 144, 145, 146, 146, 147, 148, 149, 150, 151, 151, 152, 153, 153, 154, 155, 155, 156, 157, 158, 158, 158, 159, 160, 161, 162, 162, 162, 163, 164, 165, 165},
{  23,  24,  24,  25,  26,  26,  26,  27,  28,  29,  30,  30,  30,  31,  32,  33,  33,  34,  34,  35,  36,  37,  37,  38,  39,  39,  40,  41,  41,  42,  43,  44,  45,  46,  46,  47,  48,  48,  49,  49,  50,  51,  52,  53,  54,  54,  55,  56,  57,  58,  59,  59,  60,  61,  62,  63,  64,  64,  65,  65,  66,  67,  67,  68,  69,  70,  71,  72,  72,  73,  74,  75,  76,  77,  77,  78,  79,  80,  81,  82,  82,  83,  84,  85,  86,  86,  87,  88,  89,  90,  91,  91,  92,  93,  94,  95,  96,  96,  97,  98,  99, 100, 101, 101, 102, 103, 104, 105, 105, 106, 107, 108, 109, 110, 110, 111, 112, 113, 114, 115, 115, 116, 117, 118, 119, 120, 120, 121, 122, 123, 124, 124, 125, 126, 127, 128, 128, 128, 129, 130, 131, 132, 133, 133, 134, 135, 136, 137, 138, 138, 139, 140, 141, 142, 142, 143, 144, 144, 145, 146, 146, 147, 148, 149, 150, 151, 151, 152, 153, 153, 154, 155, 155, 156, 157, 158, 158, 158, 159, 160, 161, 162, 162, 162, 163, 164, 165, 165},
{  20,  20,  21,  21,  22,  22,  23,  24,  24,  25,  26,  26,  27,  28,  28,  29,  29,  30,  31,  32,  33,  33,  33,  34,  35,  36,  37,  38,  39,  39,  40,  40,  41,  42,  43,  44,  45,  46,  47,  47,  47,  48,  49,  50,  51,  52,  53,  53,  54,  55,  56,  57,  58,  59,  60,  61,  61,  62,  63,  64,  64,  65,  66,  67,  67,  68,  69,  70,  71,  72,  73,  74,  75,  75,  76,  77,  78,  79,  80,  81,  82,  82,  83,  84,  85,  86,  87,  88,  89,  90,  90,  91,  92,  93,  94,  95,  96,  97,  97,  98,  99, 100, 101, 102, 103, 104, 105, 105, 106, 107, 108, 109, 110, 111, 112, 112, 113, 114, 115, 116, 117, 118, 119, 120, 120, 121, 122, 123, 124, 125, 126, 127, 127, 128, 128, 129, 130, 131, 132, 133, 134, 134, 135, 136, 137, 138, 139, 140, 141, 141, 142, 143, 144, 145, 145, 146, 147, 147, 148, 149, 150, 151, 152, 153, 153, 154, 154, 155, 156, 157, 158, 158, 159, 160, 160, 161, 162, 162, 163, 164, 165, 165, 166, 166, 167, 168, 168, 169},
{  20,  20,  21,  21,  22,  22,  23,  24,  24,  25,  26,  26,  27,  28,  28,  29,  29,  30,  31,  32,  33,  33,  33,  34,  35,  36,  37,  38,  39,  39,  40,  40,  41,  42,  43,  44,  45,  46,  47,  47,  47,  48,  49,  50,  51,  52,  53,  53,  54,  55,  56,  57,  58,  59,  60,  61,  61,  62,  63,  64,  64,  65,  66,  67,  67,  68,  69,  70,  71,  72,  73,  74,  75,  75,  76,  77,  78,  79,  80,  81,  82,  82,  83,  84,  85,  86,  87,  88,  89,  90,  90,  91,  92,  93,  94,  95,  96,  97,  97,  98,  99, 100, 101, 102, 103, 104, 105, 105, 106, 107, 108, 109, 110, 111, 112, 112, 113, 114, 115, 116, 117, 118, 119, 120, 120, 121, 122, 123, 124, 125, 126, 127, 127, 128, 128, 129, 130, 131, 132, 133, 134, 134, 135, 136, 137, 138, 139, 140, 141, 141, 142, 143, 144, 145, 145, 146, 147, 147, 148, 149, 150, 151, 152, 153, 153, 154, 154, 155, 156, 157, 158, 158, 159, 160, 160, 161, 162, 162, 163, 164, 165, 165, 166, 166, 167, 168, 168, 169},
{  20,  20,  21,  21,  22,  22,  23,  24,  24,  25,  26,  26,  27,  28,  28,  29,  29,  30,  31,  32,  33,  33,  33,  34,  35,  36,  37,  38,  39,  39,  40,  40,  41,  42,  43,  44,  45,  46,  47,  47,  47,  48,  49,  50,  51,  52,  53,  53,  54,  55,  56,  57,  58,  59,  60,  61,  61,  62,  63,  64,  64,  65,  66,  67,  67,  68,  69,  70,  71,  72,  73,  74,  75,  75,  76,  77,  78,  79,  80,  81,  82,  82,  83,  84,  85,  86,  87,  88,  89,  90,  90,  91,  92,  93,  94,  95,  96,  97,  97,  98,  99, 100, 101, 102, 103, 104, 105, 105, 106, 107, 108, 109, 110, 111, 112, 112, 113, 114, 115, 116, 117, 118, 119, 120, 120, 121, 122, 123, 124, 125, 126, 127, 127, 128, 128, 129, 130, 131, 132, 133, 134, 134, 135, 136, 137, 138, 139, 140, 141, 141, 142, 143, 144, 145, 145, 146, 147, 147, 148, 149, 150, 151, 152, 153, 153, 154, 154, 155, 156, 157, 158, 158, 159, 160, 160, 161, 162, 162, 163, 164, 165, 165, 166, 166, 167, 168, 168, 169},
{  20,  20,  21,  21,  22,  22,  23,  24,  24,  25,  26,  26,  27,  28,  28,  29,  29,  30,  31,  32,  33,  33,  33,  34,  35,  36,  37,  38,  39,  39,  40,  40,  41,  42,  43,  44,  45,  46,  47,  47,  47,  48,  49,  50,  51,  52,  53,  53,  54,  55,  56,  57,  58,  59,  60,  61,  61,  62,  63,  64,  64,  65,  66,  67,  67,  68,  69,  70,  71,  72,  73,  74,  75,  75,  76,  77,  78,  79,  80,  81,  82,  82,  83,  84,  85,  86,  87,  88,  89,  90,  90,  91,  92,  93,  94,  95,  96,  97,  97,  98,  99, 100, 101, 102, 103, 104, 105, 105, 106, 107, 108, 109, 110, 111, 112, 112, 113, 114, 115, 116, 117, 118, 119, 120, 120, 121, 122, 123, 124, 125, 126, 127, 127, 128, 128, 129, 130, 131, 132, 133, 134, 134, 135, 136, 137, 138, 139, 140, 141, 141, 142, 143, 144, 145, 145, 146, 147, 147, 148, 149, 150, 151, 152, 153, 153, 154, 154, 155, 156, 157, 158, 158, 159, 160, 160, 161, 162, 162, 163, 164, 165, 165, 166, 166, 167, 168, 168, 169},
{  20,  20,  21,  21,  22,  22,  23,  24,  24,  25,  26,  26,  27,  28,  28,  29,  29,  30,  31,  32,  33,  33,  33,  34,  35,  36,  37,  38,  39,  39,  40,  40,  41,  42,  43,  44,  45,  46,  47,  47,  47,  48,  49,  50,  51,  52,  53,  53,  54,  55,  56,  57,  58,  59,  60,  61,  61,  62,  63,  64,  64,  65,  66,  67,  67,  68,  69,  70,  71,  72,  73,  74,  75,  75,  76,  77,  78,  79,  80,  81,  82,  82,  83,  84,  85,  86,  87,  88,  89,  90,  90,  91,  92,  93,  94,  95,  96,  97,  97,  98,  99, 100, 101, 102, 103, 104, 105, 105, 106, 107, 108, 109, 110, 111, 112, 112, 113, 114, 115, 116, 117, 118, 119, 120, 120, 121, 122, 123, 124, 125, 126, 127, 127, 128, 128, 129, 130, 131, 132, 133, 134, 134, 135, 136, 137, 138, 139, 140, 141, 141, 142, 143, 144, 145, 145, 146, 147, 147, 148, 149, 150, 151, 152, 153, 153, 154, 154, 155, 156, 157, 158, 158, 159, 160, 160, 161, 162, 162, 163, 164, 165, 165, 166, 166, 167, 168, 168, 169},
{  20,  20,  21,  21,  22,  22,  23,  24,  24,  25,  26,  26,  27,  28,  28,  29,  29,  30,  31,  32,  33,  33,  33,  34,  35,  36,  37,  38,  39,  39,  40,  40,  41,  42,  43,  44,  45,  46,  47,  47,  47,  48,  49,  50,  51,  52,  53,  53,  54,  55,  56,  57,  58,  59,  60,  61,  61,  62,  63,  64,  64,  65,  66,  67,  67,  68,  69,  70,  71,  72,  73,  74,  75,  75,  76,  77,  78,  79,  80,  81,  82,  82,  83,  84,  85,  86,  87,  88,  89,  90,  90,  91,  92,  93,  94,  95,  96,  97,  97,  98,  99, 100, 101, 102, 103, 104, 105, 105, 106, 107, 108, 109, 110, 111, 112, 112, 113, 114, 115, 116, 117, 118, 119, 120, 120, 121, 122, 123, 124, 125, 126, 127, 127, 128, 128, 129, 130, 131, 132, 133, 134, 134, 135, 136, 137, 138, 139, 140, 141, 141, 142, 143, 144, 145, 145, 146, 147, 147, 148, 149, 150, 151, 152, 153, 153, 154, 154, 155, 156, 157, 158, 158, 159, 160, 160, 161, 162, 162, 163, 164, 165, 165, 166, 166, 167, 168, 168, 169},
{  20,  20,  21,  21,  22,  22,  23,  24,  24,  25,  26,  26,  27,  28,  28,  29,  29,  30,  31,  32,  33,  33,  33,  34,  35,  36,  37,  38,  39,  39,  40,  40,  41,  42,  43,  44,  45,  46,  47,  47,  47,  48,  49,  50,  51,  52,  53,  53,  54,  55,  56,  57,  58,  59,  60,  61,  61,  62,  63,  64,  64,  65,  66,  67,  67,  68,  69,  70,  71,  72,  73,  74,  75,  75,  76,  77,  78,  79,  80,  81,  82,  82,  83,  84,  85,  86,  87,  88,  89,  90,  90,  91,  92,  93,  94,  95,  96,  97,  97,  98,  99, 100, 101, 102, 103, 104, 105, 105, 106, 107, 108, 109, 110, 111, 112, 112, 113, 114, 115, 116, 117, 118, 119, 120, 120, 121, 122, 123, 124, 125, 126, 127, 127, 128, 128, 129, 130, 131, 132, 133, 134, 134, 135, 136, 137, 138, 139, 140, 141, 141, 142, 143, 144, 145, 145, 146, 147, 147, 148, 149, 150, 151, 152, 153, 153, 154, 154, 155, 156, 157, 158, 158, 159, 160, 160, 161, 162, 162, 163, 164, 165, 165, 166, 166, 167, 168, 168, 169},
{  17,  17,  18,  18,  19,  19,  19,  20,  21,  21,  22,  23,  23,  24,  25,  26,  26,  27,  28,  29,  29,  30,  30,  31,  32,  33,  33,  34,  35,  36,  37,  38,  38,  39,  40,  41,  42,  43,  43,  44,  45,  46,  47,  47,  48,  49,  50,  51,  52,  53,  54,  55,  56,  57,  57,  58,  59,  60,  61,  62,  63,  63,  64,  65,  66,  67,  68,  69,  70,  71,  71,  72,  73,  74,  75,  76,  77,  78,  79,  80,  81,  82,  83,  84,  85,  86,  86,  87,  88,  89,  90,  91,  92,  93,  94,  95,  96,  97,  98,  99, 100, 101, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 129, 130, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 145, 145, 146, 147, 148, 149, 150, 151, 152, 153, 153, 154, 155, 156, 157, 158, 158, 159, 159, 160, 161, 162, 163, 163, 164, 165, 166, 166, 167, 168, 168, 169, 169, 170, 170, 171, 172, 172},
{  17,  17,  18,  18,  19,  19,  19,  20,  21,  21,  22,  23,  23,  24,  25,  26,  26,  27,  28,  29,  29,  30,  30,  31,  32,  33,  33,  34,  35,  36,  37,  38,  38,  39,  40,  41,  42,  43,  43,  44,  45,  46,  47,  47,  48,  49,  50,  51,  52,  53,  54,  55,  56,  57,  57,  58,  59,  60,  61,  62,  63,  63,  64,  65,  66,  67,  68,  69,  70,  71,  71,  72,  73,  74,  75,  76,  77,  78,  79,  80,  81,  82,  83,  84,  85,  86,  86,  87,  88,  89,  90,  91,  92,  93,  94,  95,  96,  97,  98,  99, 100, 101, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 129, 130, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 145, 145, 146, 147, 148, 149, 150, 151, 152, 153, 153, 154, 155, 156, 157, 158, 158, 159, 159, 160, 161, 162, 163, 163, 164, 165, 166, 166, 167, 168, 168, 169, 169, 170, 170, 171, 172, 172},
{  17,  17,  18,  18,  19,  19,  19,  20,  21,  21,  22,  23,  23,  24,  25,  26,  26,  27,  28,  29,  29,  30,  30,  31,  32,  33,  33,  34,  35,  36,  37,  38,  38,  39,  40,  41,  42,  43,  43,  44,  45,  46,  47,  47,  48,  49,  50,  51,  52,  53,  54,  55,  56,  57,  57,  58,  59,  60,  61,  62,  63,  63,  64,  65,  66,  67,  68,  69,  70,  71,  71,  72,  73,  74,  75,  76,  77,  78,  79,  80,  81,  82,  83,  84,  85,  86,  86,  87,  88,  89,  90,  91,  92,  93,  94,  95,  96,  97,  98,  99, 100, 101, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 129, 130, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 145, 145, 146, 147, 148, 149, 150, 151, 152, 153, 153, 154, 155, 156, 157, 158, 158, 159, 159, 160, 161, 162, 163, 163, 164, 165, 166, 166, 167, 168, 168, 169, 169, 170, 170, 171, 172, 172},
{  17,  17,  18,  18,  19,  19,  19,  20,  21,  21,  22,  23,  23,  24,  25,  26,  26,  27,  28,  29,  29,  30,  30,  31,  32,  33,  33,  34,  35,  36,  37,  38,  38,  39,  40,  41,  42,  43,  43,  44,  45,  46,  47,  47,  48,  49,  50,  51,  52,  53,  54,  55,  56,  57,  57,  58,  59,  60,  61,  62,  63,  63,  64,  65,  66,  67,  68,  69,  70,  71,  71,  72,  73,  74,  75,  76,  77,  78,  79,  80,  81,  82,  83,  84,  85,  86,  86,  87,  88,  89,  90,  91,  92,  93,  94,  95,  96,  97,  98,  99, 100, 101, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 129, 130, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 145, 145, 146, 147, 148, 149, 150, 151, 152, 153, 153, 154, 155, 156, 157, 158, 158, 159, 159, 160, 161, 162, 163, 163, 164, 165, 166, 166, 167, 168, 168, 169, 169, 170, 170, 171, 172, 172},
{  17,  17,  18,  18,  19,  19,  19,  20,  21,  21,  22,  23,  23,  24,  25,  26,  26,  27,  28,  29,  29,  30,  30,  31,  32,  33,  33,  34,  35,  36,  37,  38,  38,  39,  40,  41,  42,  43,  43,  44,  45,  46,  47,  47,  48,  49,  50,  51,  52,  53,  54,  55,  56,  57,  57,  58,  59,  60,  61,  62,  63,  63,  64,  65,  66,  67,  68,  69,  70,  71,  71,  72,  73,  74,  75,  76,  77,  78,  79,  80,  81,  82,  83,  84,  85,  86,  86,  87,  88,  89,  90,  91,  92,  93,  94,  95,  96,  97,  98,  99, 100, 101, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 129, 130, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 145, 145, 146, 147, 148, 149, 150, 151, 152, 153, 153, 154, 155, 156, 157, 158, 158, 159, 159, 160, 161, 162, 163, 163, 164, 165, 166, 166, 167, 168, 168, 169, 169, 170, 170, 171, 172, 172},
{  17,  17,  18,  18,  19,  19,  19,  20,  21,  21,  22,  23,  23,  24,  25,  26,  26,  27,  28,  29,  29,  30,  30,  31,  32,  33,  33,  34,  35,  36,  37,  38,  38,  39,  40,  41,  42,  43,  43,  44,  45,  46,  47,  47,  48,  49,  50,  51,  52,  53,  54,  55,  56,  57,  57,  58,  59,  60,  61,  62,  63,  63,  64,  65,  66,  67,  68,  69,  70,  71,  71,  72,  73,  74,  75,  76,  77,  78,  79,  80,  81,  82,  83,  84,  85,  86,  86,  87,  88,  89,  90,  91,  92,  93,  94,  95,  96,  97,  98,  99, 100, 101, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 129, 130, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 145, 145, 146, 147, 148, 149, 150, 151, 152, 153, 153, 154, 155, 156, 157, 158, 158, 159, 159, 160, 161, 162, 163, 163, 164, 165, 166, 166, 167, 168, 168, 169, 169, 170, 170, 171, 172, 172},
{  14,  14,  15,  15,  16,  16,  17,  18,  18,  19,  19,  20,  21,  21,  22,  23,  23,  23,  24,  25,  25,  26,  27,  28,  29,  29,  30,  31,  32,  33,  33,  34,  35,  36,  37,  38,  38,  39,  40,  41,  42,  43,  44,  45,  46,  46,  47,  48,  49,  50,  51,  52,  53,  54,  55,  56,  57,  58,  59,  60,  61,  62,  63,  63,  64,  65,  66,  67,  68,  69,  70,  71,  72,  73,  74,  75,  76,  77,  78,  79,  80,  81,  82,  83,  84,  85,  86,  87,  88,  89,  90,  91,  92,  93,  94,  95,  96,  97,  98,  99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 146, 147, 148, 149, 150, 151, 152, 153, 154, 154, 155, 156, 157, 158, 159, 159, 160, 161, 162, 163, 163, 164, 165, 165, 166, 166, 167, 168, 169, 169, 170, 171, 171, 172, 172, 173, 174, 174, 175, 175},
{  14,  14,  15,  15,  16,  16,  17,  18,  18,  19,  19,  20,  21,  21,  22,  23,  23,  23,  24,  25,  25,  26,  27,  28,  29,  29,  30,  31,  32,  33,  33,  34,  35,  36,  37,  38,  38,  39,  40,  41,  42,  43,  44,  45,  46,  46,  47,  48,  49,  50,  51,  52,  53,  54,  55,  56,  57,  58,  59,  60,  61,  62,  63,  63,  64,  65,  66,  67,  68,  69,  70,  71,  72,  73,  74,  75,  76,  77,  78,  79,  80,  81,  82,  83,  84,  85,  86,  87,  88,  89,  90,  91,  92,  93,  94,  95,  96,  97,  98,  99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 146, 147, 148, 149, 150, 151, 152, 153, 154, 154, 155, 156, 157, 158, 159, 159, 160, 161, 162, 163, 163, 164, 165, 165, 166, 166, 167, 168, 169, 169, 170, 171, 171, 172, 172, 173, 174, 174, 175, 175},
{  14,  14,  15,  15,  16,  16,  17,  18,  18,  19,  19,  20,  21,  21,  22,  23,  23,  23,  24,  25,  25,  26,  27,  28,  29,  29,  30,  31,  32,  33,  33,  34,  35,  36,  37,  38,  38,  39,  40,  41,  42,  43,  44,  45,  46,  46,  47,  48,  49,  50,  51,  52,  53,  54,  55,  56,  57,  58,  59,  60,  61,  62,  63,  63,  64,  65,  66,  67,  68,  69,  70,  71,  72,  73,  74,  75,  76,  77,  78,  79,  80,  81,  82,  83,  84,  85,  86,  87,  88,  89,  90,  91,  92,  93,  94,  95,  96,  97,  98,  99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 146, 147, 148, 149, 150, 151, 152, 153, 154, 154, 155, 156, 157, 158, 159, 159, 160, 161, 162, 163, 163, 164, 165, 165, 166, 166, 167, 168, 169, 169, 170, 171, 171, 172, 172, 173, 174, 174, 175, 175},
{  14,  14,  15,  15,  16,  16,  17,  18,  18,  19,  19,  20,  21,  21,  22,  23,  23,  23,  24,  25,  25,  26,  27,  28,  29,  29,  30,  31,  32,  33,  33,  34,  35,  36,  37,  38,  38,  39,  40,  41,  42,  43,  44,  45,  46,  46,  47,  48,  49,  50,  51,  52,  53,  54,  55,  56,  57,  58,  59,  60,  61,  62,  63,  63,  64,  65,  66,  67,  68,  69,  70,  71,  72,  73,  74,  75,  76,  77,  78,  79,  80,  81,  82,  83,  84,  85,  86,  87,  88,  89,  90,  91,  92,  93,  94,  95,  96,  97,  98,  99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 146, 147, 148, 149, 150, 151, 152, 153, 154, 154, 155, 156, 157, 158, 159, 159, 160, 161, 162, 163, 163, 164, 165, 165, 166, 166, 167, 168, 169, 169, 170, 171, 171, 172, 172, 173, 174, 174, 175, 175},
{  14,  14,  15,  15,  16,  16,  17,  18,  18,  19,  19,  20,  21,  21,  22,  23,  23,  23,  24,  25,  25,  26,  27,  28,  29,  29,  30,  31,  32,  33,  33,  34,  35,  36,  37,  38,  38,  39,  40,  41,  42,  43,  44,  45,  46,  46,  47,  48,  49,  50,  51,  52,  53,  54,  55,  56,  57,  58,  59,  60,  61,  62,  63,  63,  64,  65,  66,  67,  68,  69,  70,  71,  72,  73,  74,  75,  76,  77,  78,  79,  80,  81,  82,  83,  84,  85,  86,  87,  88,  89,  90,  91,  92,  93,  94,  95,  96,  97,  98,  99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 146, 147, 148, 149, 150, 151, 152, 153, 154, 154, 155, 156, 157, 158, 159, 159, 160, 161, 162, 163, 163, 164, 165, 165, 166, 166, 167, 168, 169, 169, 170, 171, 171, 172, 172, 173, 174, 174, 175, 175},
{  67,  67,  67,  67,  13,  14,  14,  15,  15,  16,  16,  17,  17,  18,  19,  19,  20,  20,  21,  22,  23,  23,  24,  25,  26,  27,  28,  28,  29,  30,  31,  32,  32,  33,  34,  35,  36,  37,  38,  38,  39,  40,  41,  43,  44,  45,  46,  46,  47,  48,  49,  50,  51,  52,  53,  54,  55,  56,  57,  58,  59,  60,  61,  62,  63,  64,  65,  66,  67,  68,  69,  70,  71,  72,  73,  74,  75,  76,  77,  78,  79,  80,  81,  82,  84,  85,  86,  87,  88,  89,  90,  91,  92,  93,  94,  95,  96,  97,  98,  99, 100, 101, 102, 103, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 126, 127, 128, 129, 130, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 154, 155, 156, 157, 158, 159, 159, 160, 161, 162, 163, 164, 165, 166, 166, 167, 168, 169, 169, 170, 171, 171, 172, 173, 173, 174, 174, 175, 175, 176,  67,  67,  67,  67},
{  67,  67,  67,  67,  13,  14,  14,  15,  15,  16,  16,  17,  17,  18,  19,  19,  20,  20,  21,  22,  23,  23,  24,  25,  26,  27,  28,  28,  29,  30,  31,  32,  32,  33,  34,  35,  36,  37,  38,  38,  39,  40,  41,  43,  44,  45,  46,  46,  47,  48,  49,  50,  51,  52,  53,  54,  55,  56,  57,  58,  59,  60,  61,  62,  63,  64,  65,  66,  67,  68,  69,  70,  71,  72,  73,  74,  75,  76,  77,  78,  79,  80,  81,  82,  84,  85,  86,  87,  88,  89,  90,  91,  92,  93,  94,  95,  96,  97,  98,  99, 100, 101, 102, 103, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 126, 127, 128, 129, 130, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 154, 155, 156, 157, 158, 159, 159, 160, 161, 162, 163, 164, 165, 166, 166, 167, 168, 169, 169, 170, 171, 171, 172, 173, 173, 174, 174, 175, 175, 176,  67,  67,  67,  67},
{  67,  67,  67,  67,  13,  14,  14,  15,  15,  16,  16,  17,  17,  18,  19,  19,  20,  20,  21,  22,  23,  23,  24,  25,  26,  27,  28,  28,  29,  30,  31,  32,  32,  33,  34,  35,  36,  37,  38,  38,  39,  40,  41,  43,  44,  45,  46,  46,  47,  48,  49,  50,  51,  52,  53,  54,  55,  56,  57,  58,  59,  60,  61,  62,  63,  64,  65,  66,  67,  68,  69,  70,  71,  72,  73,  74,  75,  76,  77,  78,  79,  80,  81,  82,  84,  85,  86,  87,  88,  89,  90,  91,  92,  93,  94,  95,  96,  97,  98,  99, 100, 101, 102, 103, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 126, 127, 128, 129, 130, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 154, 155, 156, 157, 158, 159, 159, 160, 161, 162, 163, 164, 165, 166, 166, 167, 168, 169, 169, 170, 171, 171, 172, 173, 173, 174, 174, 175, 175, 176,  67,  67,  67,  67},
{  67,  67,  67,  67,  13,  14,  14,  15,  15,  16,  16,  17,  17,  18,  19,  19,  20,  20,  21,  22,  23,  23,  24,  25,  26,  27,  28,  28,  29,  30,  31,  32,  32,  33,  34,  35,  36,  37,  38,  38,  39,  40,  41,  43,  44,  45,  46,  46,  47,  48,  49,  50,  51,  52,  53,  54,  55,  56,  57,  58,  59,  60,  61,  62,  63,  64,  65,  66,  67,  68,  69,  70,  71,  72,  73,  74,  75,  76,  77,  78,  79,  80,  81,  82,  84,  85,  86,  87,  88,  89,  90,  91,  92,  93,  94,  95,  96,  97,  98,  99, 100, 101, 102, 103, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 126, 127, 128, 129, 130, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 154, 155, 156, 157, 158, 159, 159, 160, 161, 162, 163, 164, 165, 166, 166, 167, 168, 169, 169, 170, 171, 171, 172, 173, 173, 174, 174, 175, 175, 176,  67,  67,  67,  67},
{  67,  67,  67,  67,  13,  14,  14,  15,  15,  16,  16,  17,  17,  18,  19,  19,  20,  20,  21,  22,  23,  23,  24,  25,  26,  27,  28,  28,  29,  30,  31,  32,  32,  33,  34,  35,  36,  37,  38,  38,  39,  40,  41,  43,  44,  45,  46,  46,  47,  48,  49,  50,  51,  52,  53,  54,  55,  56,  57,  58,  59,  60,  61,  62,  63,  64,  65,  66,  67,  68,  69,  70,  71,  72,  73,  74,  75,  76,  77,  78,  79,  80,  81,  82,  84,  85,  86,  87,  88,  89,  90,  91,  92,  93,  94,  95,  96,  97,  98,  99, 100, 101, 102, 103, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 126, 127, 128, 129, 130, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 154, 155, 156, 157, 158, 159, 159, 160, 161, 162, 163, 164, 165, 166, 166, 167, 168, 169, 169, 170, 171, 171, 172, 173, 173, 174, 174, 175, 175, 176,  67,  67,  67,  67},
{  67,  67,  67,  67,  67,  67,  67,  67,  13,  13,  14,  14,  15,  16,  16,  17,  17,  18,  18,  19,  20,  20,  21,  22,  23,  24,  25,  25,  26,  27,  28,  28,  30,  31,  32,  32,  33,  34,  35,  36,  37,  37,  39,  40,  41,  42,  43,  44,  45,  45,  46,  48,  49,  50,  51,  52,  53,  54,  55,  56,  57,  59,  60,  61,  62,  62,  63,  64,  65,  66,  68,  69,  70,  71,  72,  73,  74,  75,  76,  77,  79,  80,  81,  82,  83,  84,  85,  86,  87,  89,  90,  91,  92,  93,  94,  95,  96,  97,  98, 100, 101, 102, 103, 104, 105, 106, 107, 108, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 121, 122, 123, 124, 125, 126, 127, 128, 129, 131, 131, 132, 133, 134, 135, 136, 137, 138, 139, 141, 142, 143, 144, 145, 146, 147, 147, 148, 150, 151, 152, 153, 154, 155, 155, 156, 157, 158, 160, 160, 161, 162, 163, 164, 164, 165, 166, 167, 168, 169, 169, 170, 171, 171, 172, 173, 173, 174, 175, 176, 176, 176,  67,  67,  67,  67,  67,  67,  67,  67},
{  67,  67,  67,  67,  67,  67,  67,  67,  13,  13,  14,  14,  15,  16,  16,  17,  17,  18,  18,  19,  20,  20,  21,  22,  23,  24,  25,  25,  26,  27,  28,  28,  30,  31,  32,  32,  33,  34,  35,  36,  37,  37,  39,  40,  41,  42,  43,  44,  45,  45,  46,  48,  49,  50,  51,  52,  53,  54,  55,  56,  57,  59,  60,  61,  62,  62,  63,  64,  65,  66,  68,  69,  70,  71,  72,  73,  74,  75,  76,  77,  79,  80,  81,  82,  83,  84,  85,  86,  87,  89,  90,  91,  92,  93,  94,  95,  96,  97,  98, 100, 101, 102, 103, 104, 105, 106, 107, 108, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 121, 122, 123, 124, 125, 126, 127, 128, 129, 131, 131, 132, 133, 134, 135, 136, 137, 138, 139, 141, 142, 143, 144, 145, 146, 147, 147, 148, 150, 151, 152, 153, 154, 155, 155, 156, 157, 158, 160, 160, 161, 162, 163, 164, 164, 165, 166, 167, 168, 169, 169, 170, 171, 171, 172, 173, 173, 174, 175, 176, 176, 176,  67,  67,  67,  67,  67,  67,  67,  67},
{  67,  67,  67,  67,  67,  67,  67,  67,  13,  13,  14,  14,  15,  16,  16,  17,  17,  18,  18,  19,  20,  20,  21,  22,  23,  24,  25,  25,  26,  27,  28,  28,  30,  31,  32,  32,  33,  34,  35,  36,  37,  37,  39,  40,  41,  42,  43,  44,  45,  45,  46,  48,  49,  50,  51,  52,  53,  54,  55,  56,  57,  59,  60,  61,  62,  62,  63,  64,  65,  66,  68,  69,  70,  71,  72,  73,  74,  75,  76,  77,  79,  80,  81,  82,  83,  84,  85,  86,  87,  89,  90,  91,  92,  93,  94,  95,  96,  97,  98, 100, 101, 102, 103, 104, 105, 106, 107, 108, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 121, 122, 123, 124, 125, 126, 127, 128, 129, 131, 131, 132, 133, 134, 135, 136, 137, 138, 139, 141, 142, 143, 144, 145, 146, 147, 147, 148, 150, 151, 152, 153, 154, 155, 155, 156, 157, 158, 160, 160, 161, 162, 163, 164, 164, 165, 166, 167, 168, 169, 169, 170, 171, 171, 172, 173, 173, 174, 175, 176, 176, 176,  67,  67,  67,  67,  67,  67,  67,  67},
{  67,  67,  67,  67,  67,  67,  67,  67,  13,  13,  14,  14,  15,  16,  16,  17,  17,  18,  18,  19,  20,  20,  21,  22,  23,  24,  25,  25,  26,  27,  28,  28,  30,  31,  32,  32,  33,  34,  35,  36,  37,  37,  39,  40,  41,  42,  43,  44,  45,  45,  46,  48,  49,  50,  51,  52,  53,  54,  55,  56,  57,  59,  60,  61,  62,  62,  63,  64,  65,  66,  68,  69,  70,  71,  72,  73,  74,  75,  76,  77,  79,  80,  81,  82,  83,  84,  85,  86,  87,  89,  90,  91,  92,  93,  94,  95,  96,  97,  98, 100, 101, 102, 103, 104, 105, 106, 107, 108, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 121, 122, 123, 124, 125, 126, 127, 128, 129, 131, 131, 132, 133, 134, 135, 136, 137, 138, 139, 141, 142, 143, 144, 145, 146, 147, 147, 148, 150, 151, 152, 153, 154, 155, 155, 156, 157, 158, 160, 160, 161, 162, 163, 164, 164, 165, 166, 167, 168, 169, 169, 170, 171, 171, 172, 173, 173, 174, 175, 176, 176, 176,  67,  67,  67,  67,  67,  67,  67,  67},
{  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  13,  13,  13,  14,  15,  15,  16,  17,  17,  18,  18,  20,  20,  21,  22,  22,  23,  24,  25,  26,  27,  28,  28,  30,  31,  31,  32,  33,  34,  36,  37,  37,  38,  39,  40,  42,  43,  44,  45,  45,  46,  47,  49,  50,  51,  52,  53,  54,  56,  57,  58,  59,  60,  61,  62,  63,  64,  65,  66,  67,  69,  70,  71,  72,  73,  74,  76,  77,  78,  79,  80,  81,  82,  84,  85,  86,  87,  88,  89,  91,  92,  93,  94,  95,  96,  98,  99, 100, 101, 102, 103, 105, 106, 107, 108, 109, 110, 111, 113, 114, 115, 116, 117, 118, 120, 121, 122, 123, 124, 125, 127, 128, 129, 130, 131, 131, 133, 134, 135, 136, 137, 138, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 154, 155, 155, 156, 157, 158, 160, 160, 161, 162, 163, 164, 165, 166, 167, 167, 168, 169, 170, 171, 171, 172, 173, 173, 174, 175, 176, 176, 176,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67},
{  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  13,  13,  13,  14,  15,  15,  16,  17,  17,  18,  18,  20,  20,  21,  22,  22,  23,  24,  25,  26,  27,  28,  28,  30,  31,  31,  32,  33,  34,  36,  37,  37,  38,  39,  40,  42,  43,  44,  45,  45,  46,  47,  49,  50,  51,  52,  53,  54,  56,  57,  58,  59,  60,  61,  62,  63,  64,  65,  66,  67,  69,  70,  71,  72,  73,  74,  76,  77,  78,  79,  80,  81,  82,  84,  85,  86,  87,  88,  89,  91,  92,  93,  94,  95,  96,  98,  99, 100, 101, 102, 103, 105, 106, 107, 108, 109, 110, 111, 113, 114, 115, 116, 117, 118, 120, 121, 122, 123, 124, 125, 127, 128, 129, 130, 131, 131, 133, 134, 135, 136, 137, 138, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 154, 155, 155, 156, 157, 158, 160, 160, 161, 162, 163, 164, 165, 166, 167, 167, 168, 169, 170, 171, 171, 172, 173, 173, 174, 175, 176, 176, 176,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67},
{  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  13,  13,  13,  14,  15,  15,  16,  17,  17,  18,  18,  20,  20,  21,  22,  22,  23,  24,  25,  26,  27,  28,  28,  30,  31,  31,  32,  33,  34,  36,  37,  37,  38,  39,  40,  42,  43,  44,  45,  45,  46,  47,  49,  50,  51,  52,  53,  54,  56,  57,  58,  59,  60,  61,  62,  63,  64,  65,  66,  67,  69,  70,  71,  72,  73,  74,  76,  77,  78,  79,  80,  81,  82,  84,  85,  86,  87,  88,  89,  91,  92,  93,  94,  95,  96,  98,  99, 100, 101, 102, 103, 105, 106, 107, 108, 109, 110, 111, 113, 114, 115, 116, 117, 118, 120, 121, 122, 123, 124, 125, 127, 128, 129, 130, 131, 131, 133, 134, 135, 136, 137, 138, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 154, 155, 155, 156, 157, 158, 160, 160, 161, 162, 163, 164, 165, 166, 167, 167, 168, 169, 170, 171, 171, 172, 173, 173, 174, 175, 176, 176, 176,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67},
{  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  13,  13,  13,  14,  15,  15,  16,  17,  17,  18,  18,  20,  20,  21,  22,  22,  23,  24,  25,  26,  27,  28,  28,  30,  31,  31,  32,  33,  34,  36,  37,  37,  38,  39,  40,  42,  43,  44,  45,  45,  46,  47,  49,  50,  51,  52,  53,  54,  56,  57,  58,  59,  60,  61,  62,  63,  64,  65,  66,  67,  69,  70,  71,  72,  73,  74,  76,  77,  78,  79,  80,  81,  82,  84,  85,  86,  87,  88,  89,  91,  92,  93,  94,  95,  96,  98,  99, 100, 101, 102, 103, 105, 106, 107, 108, 109, 110, 111, 113, 114, 115, 116, 117, 118, 120, 121, 122, 123, 124, 125, 127, 128, 129, 130, 131, 131, 133, 134, 135, 136, 137, 138, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 154, 155, 155, 156, 157, 158, 160, 160, 161, 162, 163, 164, 165, 166, 167, 167, 168, 169, 170, 171, 171, 172, 173, 173, 174, 175, 176, 176, 176,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67},
{  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  13,  13,  14,  14,  15,  15,  16,  17,  18,  18,  19,  20,  21,  22,  22,  23,  24,  25,  26,  27,  28,  29,  30,  31,  31,  33,  34,  35,  36,  36,  38,  39,  40,  41,  43,  44,  44,  45,  46,  48,  49,  50,  51,  53,  54,  55,  56,  57,  59,  60,  61,  61,  62,  64,  65,  66,  67,  69,  70,  71,  72,  73,  75,  76,  77,  78,  80,  81,  82,  83,  84,  86,  87,  88,  89,  90,  92,  93,  94,  95,  97,  98,  99, 100, 101, 103, 104, 105, 106, 107, 109, 110, 111, 112, 114, 115, 116, 117, 118, 120, 121, 122, 123, 125, 126, 127, 128, 129, 131, 132, 132, 133, 134, 136, 137, 138, 139, 141, 142, 143, 144, 145, 147, 148, 148, 149, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 167, 168, 170, 170, 171, 172, 173, 173, 174, 175, 175, 176, 176,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67},
{  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  13,  13,  14,  14,  15,  15,  16,  17,  18,  18,  19,  20,  21,  22,  22,  23,  24,  25,  26,  27,  28,  29,  30,  31,  31,  33,  34,  35,  36,  36,  38,  39,  40,  41,  43,  44,  44,  45,  46,  48,  49,  50,  51,  53,  54,  55,  56,  57,  59,  60,  61,  61,  62,  64,  65,  66,  67,  69,  70,  71,  72,  73,  75,  76,  77,  78,  80,  81,  82,  83,  84,  86,  87,  88,  89,  90,  92,  93,  94,  95,  97,  98,  99, 100, 101, 103, 104, 105, 106, 107, 109, 110, 111, 112, 114, 115, 116, 117, 118, 120, 121, 122, 123, 125, 126, 127, 128, 129, 131, 132, 132, 133, 134, 136, 137, 138, 139, 141, 142, 143, 144, 145, 147, 148, 148, 149, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 167, 168, 170, 170, 171, 172, 173, 173, 174, 175, 175, 176, 176,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67},
{  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  13,  13,  14,  14,  15,  15,  16,  17,  18,  18,  19,  20,  21,  22,  22,  23,  24,  25,  26,  27,  28,  29,  30,  31,  31,  33,  34,  35,  36,  36,  38,  39,  40,  41,  43,  44,  44,  45,  46,  48,  49,  50,  51,  53,  54,  55,  56,  57,  59,  60,  61,  61,  62,  64,  65,  66,  67,  69,  70,  71,  72,  73,  75,  76,  77,  78,  80,  81,  82,  83,  84,  86,  87,  88,  89,  90,  92,  93,  94,  95,  97,  98,  99, 100, 101, 103, 104, 105, 106, 107, 109, 110, 111, 112, 114, 115, 116, 117, 118, 120, 121, 122, 123, 125, 126, 127, 128, 129, 131, 132, 132, 133, 134, 136, 137, 138, 139, 141, 142, 143, 144, 145, 147, 148, 148, 149, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 167, 168, 170, 170, 171, 172, 173, 173, 174, 175, 175, 176, 176,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67},
{  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  13,  13,  14,  14,  15,  15,  16,  17,  18,  18,  19,  20,  21,  22,  22,  23,  24,  25,  26,  27,  28,  29,  30,  31,  31,  33,  34,  35,  36,  36,  38,  39,  40,  41,  43,  44,  44,  45,  46,  48,  49,  50,  51,  53,  54,  55,  56,  57,  59,  60,  61,  61,  62,  64,  65,  66,  67,  69,  70,  71,  72,  73,  75,  76,  77,  78,  80,  81,  82,  83,  84,  86,  87,  88,  89,  90,  92,  93,  94,  95,  97,  98,  99, 100, 101, 103, 104, 105, 106, 107, 109, 110, 111, 112, 114, 115, 116, 117, 118, 120, 121, 122, 123, 125, 126, 127, 128, 129, 131, 132, 132, 133, 134, 136, 137, 138, 139, 141, 142, 143, 144, 145, 147, 148, 148, 149, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 167, 168, 170, 170, 171, 172, 173, 173, 174, 175, 175, 176, 176,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67},
{  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  13,  13,  14,  15,  15,  16,  17,  18,  18,  19,  20,  21,  21,  23,  24,  24,  25,  27,  27,  28,  29,  31,  31,  32,  34,  35,  36,  36,  38,  39,  40,  41,  43,  44,  44,  46,  47,  48,  49,  51,  52,  53,  54,  56,  57,  58,  60,  60,  61,  62,  64,  65,  66,  67,  69,  70,  71,  73,  74,  75,  76,  78,  79,  80,  81,  83,  84,  85,  87,  88,  89,  90,  92,  93,  94,  95,  97,  98,  99, 100, 102, 103, 104, 106, 107, 108, 109, 111, 112, 113, 114, 116, 117, 118, 120, 121, 122, 123, 125, 126, 127, 128, 130, 131, 132, 133, 134, 135, 136, 138, 139, 140, 141, 143, 144, 145, 147, 148, 148, 149, 151, 152, 153, 154, 156, 156, 157, 159, 160, 161, 161, 163, 164, 165, 165, 167, 168, 168, 170, 170, 171, 172, 173, 174, 174, 175, 176, 176,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67},
{  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  13,  13,  14,  15,  15,  16,  17,  18,  18,  19,  20,  21,  21,  23,  24,  24,  25,  27,  27,  28,  29,  31,  31,  32,  34,  35,  36,  36,  38,  39,  40,  41,  43,  44,  44,  46,  47,  48,  49,  51,  52,  53,  54,  56,  57,  58,  60,  60,  61,  62,  64,  65,  66,  67,  69,  70,  71,  73,  74,  75,  76,  78,  79,  80,  81,  83,  84,  85,  87,  88,  89,  90,  92,  93,  94,  95,  97,  98,  99, 100, 102, 103, 104, 106, 107, 108, 109, 111, 112, 113, 114, 116, 117, 118, 120, 121, 122, 123, 125, 126, 127, 128, 130, 131, 132, 133, 134, 135, 136, 138, 139, 140, 141, 143, 144, 145, 147, 148, 148, 149, 151, 152, 153, 154, 156, 156, 157, 159, 160, 161, 161, 163, 164, 165, 165, 167, 168, 168, 170, 170, 171, 172, 173, 174, 174, 175, 176, 176,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67},
{  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  13,  13,  14,  15,  15,  16,  17,  18,  18,  19,  20,  21,  21,  23,  24,  24,  25,  27,  27,  28,  29,  31,  31,  32,  34,  35,  36,  36,  38,  39,  40,  41,  43,  44,  44,  46,  47,  48,  49,  51,  52,  53,  54,  56,  57,  58,  60,  60,  61,  62,  64,  65,  66,  67,  69,  70,  71,  73,  74,  75,  76,  78,  79,  80,  81,  83,  84,  85,  87,  88,  89,  90,  92,  93,  94,  95,  97,  98,  99, 100, 102, 103, 104, 106, 107, 108, 109, 111, 112, 113, 114, 116, 117, 118, 120, 121, 122, 123, 125, 126, 127, 128, 130, 131, 132, 133, 134, 135, 136, 138, 139, 140, 141, 143, 144, 145, 147, 148, 148, 149, 151, 152, 153, 154, 156, 156, 157, 159, 160, 161, 161, 163, 164, 165, 165, 167, 168, 168, 170, 170, 171, 172, 173, 174, 174, 175, 176, 176,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67},
{  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  13,  13,  14,  15,  15,  16,  17,  17,  18,  19,  20,  21,  22,  23,  24,  25,  26,  27,  28,  29,  30,  31,  32,  33,  35,  36,  36,  38,  39,  40,  42,  43,  44,  45,  46,  47,  49,  50,  51,  53,  54,  55,  57,  58,  59,  60,  61,  62,  64,  65,  66,  68,  69,  70,  72,  73,  74,  76,  77,  78,  80,  81,  82,  84,  85,  86,  88,  89,  90,  92,  93,  94,  95,  97,  98,  99, 101, 102, 103, 105, 106, 107, 109, 110, 111, 113, 114, 115, 117, 118, 119, 121, 122, 123, 125, 126, 127, 129, 130, 131, 133, 133, 134, 136, 137, 138, 140, 141, 142, 144, 145, 146, 148, 148, 149, 151, 152, 153, 155, 156, 156, 158, 159, 160, 161, 162, 163, 165, 165, 166, 168, 168, 169, 170, 171, 172, 173, 174, 174, 175, 176, 177,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67},
{  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  13,  13,  14,  15,  15,  16,  17,  17,  18,  19,  20,  21,  22,  23,  24,  25,  26,  27,  28,  29,  30,  31,  32,  33,  35,  36,  36,  38,  39,  40,  42,  43,  44,  45,  46,  47,  49,  50,  51,  53,  54,  55,  57,  58,  59,  60,  61,  62,  64,  65,  66,  68,  69,  70,  72,  73,  74,  76,  77,  78,  80,  81,  82,  84,  85,  86,  88,  89,  90,  92,  93,  94,  95,  97,  98,  99, 101, 102, 103, 105, 106, 107, 109, 110, 111, 113, 114, 115, 117, 118, 119, 121, 122, 123, 125, 126, 127, 129, 130, 131, 133, 133, 134, 136, 137, 138, 140, 141, 142, 144, 145, 146, 148, 148, 149, 151, 152, 153, 155, 156, 156, 158, 159, 160, 161, 162, 163, 165, 165, 166, 168, 168, 169, 170, 171, 172, 173, 174, 174, 175, 176, 177,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67},
{  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  13,  13,  14,  15,  15,  16,  17,  17,  18,  19,  20,  21,  22,  23,  24,  25,  26,  27,  28,  29,  30,  31,  32,  33,  35,  36,  36,  38,  39,  40,  42,  43,  44,  45,  46,  47,  49,  50,  51,  53,  54,  55,  57,  58,  59,  60,  61,  62,  64,  65,  66,  68,  69,  70,  72,  73,  74,  76,  77,  78,  80,  81,  82,  84,  85,  86,  88,  89,  90,  92,  93,  94,  95,  97,  98,  99, 101, 102, 103, 105, 106, 107, 109, 110, 111, 113, 114, 115, 117, 118, 119, 121, 122, 123, 125, 126, 127, 129, 130, 131, 133, 133, 134, 136, 137, 138, 140, 141, 142, 144, 145, 146, 148, 148, 149, 151, 152, 153, 155, 156, 156, 158, 159, 160, 161, 162, 163, 165, 165, 166, 168, 168, 169, 170, 171, 172, 173, 174, 174, 175, 176, 177,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67},
{  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  12,  12,  13,  14,  14,  16,  16,  17,  18,  19,  20,  21,  21,  23,  23,  24,  26,  26,  28,  29,  30,  31,  32,  34,  35,  35,  37,  38,  39,  41,  42,  43,  44,  45,  47,  48,  50,  51,  52,  54,  55,  56,  58,  59,  60,  61,  62,  64,  65,  67,  68,  69,  71,  72,  73,  75,  76,  78,  79,  80,  82,  83,  85,  86,  87,  89,  90,  91,  93,  94,  96,  97,  98, 100, 101, 102, 104, 105, 107, 108, 109, 111, 112, 114, 115, 116, 118, 119, 120, 122, 123, 125, 126, 127, 129, 130, 132, 133, 133, 135, 136, 137, 139, 140, 142, 143, 144, 146, 147, 149, 149, 150, 152, 153, 154, 156, 156, 158, 159, 160, 161, 162, 164, 165, 165, 167, 168, 168, 170, 171, 172, 173, 173, 174, 175, 176, 177, 177,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67},
{  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  12,  12,  13,  14,  14,  16,  16,  17,  18,  19,  20,  21,  21,  23,  23,  24,  26,  26,  28,  29,  30,  31,  32,  34,  35,  35,  37,  38,  39,  41,  42,  43,  44,  45,  47,  48,  50,  51,  52,  54,  55,  56,  58,  59,  60,  61,  62,  64,  65,  67,  68,  69,  71,  72,  73,  75,  76,  78,  79,  80,  82,  83,  85,  86,  87,  89,  90,  91,  93,  94,  96,  97,  98, 100, 101, 102, 104, 105, 107, 108, 109, 111, 112, 114, 115, 116, 118, 119, 120, 122, 123, 125, 126, 127, 129, 130, 132, 133, 133, 135, 136, 137, 139, 140, 142, 143, 144, 146, 147, 149, 149, 150, 152, 153, 154, 156, 156, 158, 159, 160, 161, 162, 164, 165, 165, 167, 168, 168, 170, 171, 172, 173, 173, 174, 175, 176, 177, 177,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67},
{  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  12,  12,  13,  14,  14,  16,  16,  17,  18,  19,  20,  21,  21,  23,  23,  24,  26,  26,  28,  29,  30,  31,  32,  34,  35,  35,  37,  38,  39,  41,  42,  43,  44,  45,  47,  48,  50,  51,  52,  54,  55,  56,  58,  59,  60,  61,  62,  64,  65,  67,  68,  69,  71,  72,  73,  75,  76,  78,  79,  80,  82,  83,  85,  86,  87,  89,  90,  91,  93,  94,  96,  97,  98, 100, 101, 102, 104, 105, 107, 108, 109, 111, 112, 114, 115, 116, 118, 119, 120, 122, 123, 125, 126, 127, 129, 130, 132, 133, 133, 135, 136, 137, 139, 140, 142, 143, 144, 146, 147, 149, 149, 150, 152, 153, 154, 156, 156, 158, 159, 160, 161, 162, 164, 165, 165, 167, 168, 168, 170, 171, 172, 173, 173, 174, 175, 176, 177, 177,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67},
{  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  12,  13,  13,  14,  15,  15,  17,  17,  19,  19,  21,  21,  22,  23,  24,  26,  26,  28,  29,  30,  31,  32,  34,  35,  36,  37,  39,  40,  41,  43,  43,  45,  46,  48,  49,  51,  52,  53,  55,  56,  58,  59,  60,  61,  63,  64,  65,  67,  68,  70,  71,  73,  74,  75,  77,  78,  80,  81,  83,  84,  86,  87,  88,  90,  91,  93,  94,  96,  97,  99, 100, 101, 103, 104, 106, 107, 109, 110, 112, 113, 114, 116, 117, 119, 120, 122, 123, 124, 126, 127, 129, 130, 132, 133, 134, 135, 136, 138, 139, 141, 142, 144, 145, 147, 148, 149, 150, 151, 153, 154, 156, 157, 157, 159, 160, 162, 162, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 176, 177,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67},
{  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  12,  13,  13,  14,  15,  15,  17,  17,  19,  19,  21,  21,  22,  23,  24,  26,  26,  28,  29,  30,  31,  32,  34,  35,  36,  37,  39,  40,  41,  43,  43,  45,  46,  48,  49,  51,  52,  53,  55,  56,  58,  59,  60,  61,  63,  64,  65,  67,  68,  70,  71,  73,  74,  75,  77,  78,  80,  81,  83,  84,  86,  87,  88,  90,  91,  93,  94,  96,  97,  99, 100, 101, 103, 104, 106, 107, 109, 110, 112, 113, 114, 116, 117, 119, 120, 122, 123, 124, 126, 127, 129, 130, 132, 133, 134, 135, 136, 138, 139, 141, 142, 144, 145, 147, 148, 149, 150, 151, 153, 154, 156, 157, 157, 159, 160, 162, 162, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 176, 177,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67},
{  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  12,  13,  14,  14,  15,  16,  17,  18,  19,  20,  21,  22,  23,  24,  26,  26,  28,  29,  30,  31,  33,  34,  35,  36,  38,  39,  41,  42,  43,  44,  46,  47,  49,  50,  52,  53,  55,  56,  58,  58,  60,  61,  63,  64,  66,  67,  69,  70,  72,  73,  75,  76,  78,  79,  81,  82,  84,  85,  87,  88,  90,  91,  93,  94,  96,  97,  99, 100, 102, 103, 105, 106, 108, 109, 111, 112, 114, 115, 117, 118, 120, 121, 123, 124, 126, 127, 129, 130, 132, 133, 134, 135, 137, 138, 140, 141, 143, 144, 146, 147, 149, 149, 151, 152, 154, 155, 157, 157, 159, 160, 162, 162, 164, 165, 166, 167, 169, 169, 171, 171, 173, 173, 175, 175, 176, 177,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67},
{  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  12,  13,  14,  14,  15,  16,  17,  18,  19,  20,  21,  22,  23,  24,  26,  26,  28,  29,  30,  31,  33,  34,  35,  36,  38,  39,  41,  42,  43,  44,  46,  47,  49,  50,  52,  53,  55,  56,  58,  58,  60,  61,  63,  64,  66,  67,  69,  70,  72,  73,  75,  76,  78,  79,  81,  82,  84,  85,  87,  88,  90,  91,  93,  94,  96,  97,  99, 100, 102, 103, 105, 106, 108, 109, 111, 112, 114, 115, 117, 118, 120, 121, 123, 124, 126, 127, 129, 130, 132, 133, 134, 135, 137, 138, 140, 141, 143, 144, 146, 147, 149, 149, 151, 152, 154, 155, 157, 157, 159, 160, 162, 162, 164, 165, 166, 167, 169, 169, 171, 171, 173, 173, 175, 175, 176, 177,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67},
{  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  12,  13,  14,  14,  15,  16,  17,  18,  19,  20,  21,  22,  23,  24,  26,  26,  28,  29,  30,  31,  33,  34,  35,  36,  38,  39,  41,  42,  43,  44,  46,  47,  49,  50,  52,  53,  55,  56,  58,  58,  60,  61,  63,  64,  66,  67,  69,  70,  72,  73,  75,  76,  78,  79,  81,  82,  84,  85,  87,  88,  90,  91,  93,  94,  96,  97,  99, 100, 102, 103, 105, 106, 108, 109, 111, 112, 114, 115, 117, 118, 120, 121, 123, 124, 126, 127, 129, 130, 132, 133, 134, 135, 137, 138, 140, 141, 143, 144, 146, 147, 149, 149, 151, 152, 154, 155, 157, 157, 159, 160, 162, 162, 164, 165, 166, 167, 169, 169, 171, 171, 173, 173, 175, 175, 176, 177,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67},
{  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  12,  13,  14,  14,  15,  16,  17,  18,  19,  20,  21,  22,  23,  25,  25,  27,  28,  29,  31,  32,  34,  34,  36,  37,  39,  40,  42,  43,  44,  46,  47,  49,  50,  52,  53,  55,  56,  58,  59,  60,  62,  63,  65,  66,  68,  69,  71,  73,  74,  76,  77,  79,  80,  82,  83,  85,  87,  88,  90,  91,  93,  94,  96,  97,  99, 100, 102, 104, 105, 107, 108, 110, 111, 113, 114, 116, 118, 119, 121, 122, 124, 125, 127, 128, 130, 132, 133, 135, 135, 137, 138, 140, 141, 143, 144, 146, 148, 149, 150, 151, 153, 154, 156, 157, 158, 160, 161, 162, 163, 165, 166, 167, 168, 169, 171, 171, 173, 173, 175, 175, 176, 177,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67},
{  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  12,  13,  14,  14,  15,  16,  17,  18,  19,  20,  21,  22,  23,  25,  25,  27,  28,  29,  31,  32,  34,  34,  36,  37,  39,  40,  42,  43,  44,  46,  47,  49,  50,  52,  53,  55,  56,  58,  59,  60,  62,  63,  65,  66,  68,  69,  71,  73,  74,  76,  77,  79,  80,  82,  83,  85,  87,  88,  90,  91,  93,  94,  96,  97,  99, 100, 102, 104, 105, 107, 108, 110, 111, 113, 114, 116, 118, 119, 121, 122, 124, 125, 127, 128, 130, 132, 133, 135, 135, 137, 138, 140, 141, 143, 144, 146, 148, 149, 150, 151, 153, 154, 156, 157, 158, 160, 161, 162, 163, 165, 166, 167, 168, 169, 171, 171, 173, 173, 175, 175, 176, 177,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67},
{  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  12,  12,  13,  14,  15,  16,  17,  18,  19,  20,  22,  22,  24,  25,  26,  28,  29,  30,  31,  33,  34,  35,  37,  38,  40,  42,  42,  44,  45,  47,  49,  50,  52,  54,  55,  57,  57,  59,  61,  62,  64,  65,  67,  69,  70,  72,  73,  75,  77,  78,  80,  81,  83,  85,  86,  88,  89,  91,  93,  94,  96,  98,  99, 101, 102, 104, 106, 107, 109, 110, 112, 114, 115, 117, 118, 120, 122, 123, 125, 126, 128, 130, 131, 133, 134, 135, 137, 138, 140, 142, 143, 145, 146, 148, 150, 150, 152, 153, 155, 157, 158, 159, 160, 162, 163, 164, 166, 166, 168, 169, 170, 172, 173, 174, 175, 175, 177, 177,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67},
{  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  12,  12,  13,  14,  15,  16,  17,  18,  19,  20,  22,  22,  24,  25,  26,  28,  29,  30,  31,  33,  34,  35,  37,  38,  40,  42,  42,  44,  45,  47,  49,  50,  52,  54,  55,  57,  57,  59,  61,  62,  64,  65,  67,  69,  70,  72,  73,  75,  77,  78,  80,  81,  83,  85,  86,  88,  89,  91,  93,  94,  96,  98,  99, 101, 102, 104, 106, 107, 109, 110, 112, 114, 115, 117, 118, 120, 122, 123, 125, 126, 128, 130, 131, 133, 134, 135, 137, 138, 140, 142, 143, 145, 146, 148, 150, 150, 152, 153, 155, 157, 158, 159, 160, 162, 163, 164, 166, 166, 168, 169, 170, 172, 173, 174, 175, 175, 177, 177,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67},
{  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  12,  12,  13,  15,  15,  16,  17,  18,  20,  20,  22,  23,  24,  25,  27,  28,  29,  31,  32,  34,  35,  36,  38,  40,  41,  42,  44,  45,  47,  49,  50,  52,  54,  55,  57,  58,  59,  61,  63,  64,  66,  68,  69,  71,  73,  74,  76,  78,  79,  81,  83,  84,  86,  88,  89,  91,  93,  94,  96,  98,  99, 101, 103, 104, 106, 108, 109, 111, 113, 114, 116, 118, 119, 121, 123, 124, 126, 128, 129, 131, 133, 134, 136, 137, 138, 140, 142, 143, 145, 147, 148, 150, 151, 152, 154, 156, 157, 158, 160, 161, 163, 164, 165, 167, 168, 169, 170, 172, 172, 174, 174, 175, 177, 177,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67},
{  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  12,  12,  13,  15,  15,  16,  17,  18,  20,  20,  22,  23,  24,  25,  27,  28,  29,  31,  32,  34,  35,  36,  38,  40,  41,  42,  44,  45,  47,  49,  50,  52,  54,  55,  57,  58,  59,  61,  63,  64,  66,  68,  69,  71,  73,  74,  76,  78,  79,  81,  83,  84,  86,  88,  89,  91,  93,  94,  96,  98,  99, 101, 103, 104, 106, 108, 109, 111, 113, 114, 116, 118, 119, 121, 123, 124, 126, 128, 129, 131, 133, 134, 136, 137, 138, 140, 142, 143, 145, 147, 148, 150, 151, 152, 154, 156, 157, 158, 160, 161, 163, 164, 165, 167, 168, 169, 170, 172, 172, 174, 174, 175, 177, 177,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67},
{  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  12,  13,  13,  14,  16,  16,  17,  19,  20,  21,  22,  24,  25,  26,  28,  29,  30,  32,  34,  34,  36,  38,  40,  41,  42,  44,  45,  47,  49,  51,  52,  54,  56,  57,  58,  60,  62,  63,  65,  67,  69,  70,  72,  74,  75,  77,  79,  81,  82,  84,  86,  87,  89,  91,  93,  94,  96,  98, 100, 101, 103, 105, 106, 108, 110, 112, 113, 115, 117, 118, 120, 122, 124, 125, 127, 129, 130, 132, 134, 136, 136, 138, 140, 142, 143, 145, 147, 148, 150, 151, 153, 154, 156, 158, 158, 160, 162, 163, 164, 166, 167, 168, 170, 171, 172, 173, 174, 176, 176, 177,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67},
{  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  12,  13,  13,  14,  16,  16,  17,  19,  20,  21,  22,  24,  25,  26,  28,  29,  30,  32,  34,  34,  36,  38,  40,  41,  42,  44,  45,  47,  49,  51,  52,  54,  56,  57,  58,  60,  62,  63,  65,  67,  69,  70,  72,  74,  75,  77,  79,  81,  82,  84,  86,  87,  89,  91,  93,  94,  96,  98, 100, 101, 103, 105, 106, 108, 110, 112, 113, 115, 117, 118, 120, 122, 124, 125, 127, 129, 130, 132, 134, 136, 136, 138, 140, 142, 143, 145, 147, 148, 150, 151, 153, 154, 156, 158, 158, 160, 162, 163, 164, 166, 167, 168, 170, 171, 172, 173, 174, 176, 176, 177,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67},
{  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  12,  12,  13,  14,  15,  16,  17,  18,  19,  21,  22,  23,  25,  26,  27,  28,  30,  32,  33,  34,  36,  38,  40,  41,  42,  44,  46,  47,  49,  51,  53,  55,  56,  57,  59,  61,  62,  64,  66,  68,  70,  71,  73,  75,  77,  78,  80,  82,  84,  86,  87,  89,  91,  93,  94,  96,  98, 100, 101, 103, 105, 107, 109, 110, 112, 114, 116, 117, 119, 121, 123, 125, 126, 128, 130, 132, 133, 135, 136, 138, 140, 141, 143, 145, 147, 148, 150, 151, 153, 155, 156, 158, 159, 161, 162, 163, 165, 167, 167, 169, 170, 172, 173, 174, 175, 176, 177, 177,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67},
{  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  12,  12,  13,  14,  15,  16,  17,  19,  20,  21,  23,  24,  25,  27,  28,  30,  31,  33,  34,  36,  38,  40,  41,  42,  44,  46,  48,  50,  51,  53,  55,  56,  58,  60,  61,  63,  65,  67,  69,  71,  72,  74,  76,  78,  80,  82,  83,  85,  87,  89,  91,  93,  94,  96,  98, 100, 102, 104, 105, 107, 109, 111, 113, 115, 116, 118, 120, 122, 124, 126, 127, 129, 131, 133, 135, 137, 137, 139, 141, 143, 145, 147, 148, 150, 151, 153, 155, 157, 158, 159, 161, 163, 164, 165, 167, 168, 170, 171, 172, 173, 174, 176, 177, 177,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67},
{  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  12,  12,  13,  14,  15,  16,  17,  19,  20,  21,  23,  24,  25,  27,  28,  30,  31,  33,  34,  36,  38,  40,  41,  42,  44,  46,  48,  50,  51,  53,  55,  56,  58,  60,  61,  63,  65,  67,  69,  71,  72,  74,  76,  78,  80,  82,  83,  85,  87,  89,  91,  93,  94,  96,  98, 100, 102, 104, 105, 107, 109, 111, 113, 115, 116, 118, 120, 122, 124, 126, 127, 129, 131, 133, 135, 137, 137, 139, 141, 143, 145, 147, 148, 150, 151, 153, 155, 157, 158, 159, 161, 163, 164, 165, 167, 168, 170, 171, 172, 173, 174, 176, 177, 177,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67},
{  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  12,  12,  13,  14,  15,  16,  17,  18,  19,  21,  22,  24,  25,  27,  28,  30,  31,  33,  34,  36,  38,  40,  41,  43,  44,  46,  48,  50,  52,  54,  55,  57,  59,  60,  62,  64,  66,  68,  70,  72,  74,  76,  77,  79,  81,  83,  85,  87,  89,  91,  93,  94,  96,  98, 100, 102, 104, 106, 108, 110, 111, 113, 115, 117, 119, 121, 123, 125, 127, 128, 130, 132, 134, 136, 137, 139, 141, 143, 144, 146, 148, 150, 152, 153, 155, 157, 158, 159, 161, 163, 164, 166, 167, 169, 170, 171, 173, 174, 175, 176, 177, 177,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67},
{  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  11,  12,  13,  14,  15,  17,  18,  19,  21,  22,  24,  25,  27,  28,  29,  31,  33,  34,  36,  38,  40,  41,  43,  45,  47,  49,  51,  53,  55,  56,  58,  60,  61,  63,  65,  67,  69,  71,  73,  75,  77,  79,  81,  83,  85,  87,  89,  91,  93,  94,  96,  98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 127, 129, 131, 133, 135, 137, 138, 140, 142, 144, 146, 148, 150, 152, 153, 155, 157, 159, 159, 161, 163, 164, 166, 168, 169, 170, 172, 173, 175, 176, 177, 178,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67},
{  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  11,  12,  13,  14,  15,  17,  18,  19,  21,  22,  24,  25,  27,  28,  29,  31,  33,  34,  36,  38,  40,  41,  43,  45,  47,  49,  51,  53,  55,  56,  58,  60,  61,  63,  65,  67,  69,  71,  73,  75,  77,  79,  81,  83,  85,  87,  89,  91,  93,  94,  96,  98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 127, 129, 131, 133, 135, 137, 138, 140, 142, 144, 146, 148, 150, 152, 153, 155, 157, 159, 159, 161, 163, 164, 166, 168, 169, 170, 172, 173, 175, 176, 177, 178,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67},
{  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  11,  12,  13,  14,  15,  17,  18,  19,  21,  22,  24,  25,  27,  28,  30,  32,  33,  35,  37,  39,  40,  42,  44,  46,  48,  50,  52,  54,  55,  57,  59,  61,  63,  65,  67,  69,  71,  73,  75,  77,  79,  81,  83,  85,  87,  89,  91,  93,  94,  96,  98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 139, 141, 143, 145, 147, 149, 151, 152, 154, 156, 158, 159, 161, 163, 164, 166, 168, 169, 171, 172, 173, 175, 176, 177, 178,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67},
{  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  11,  11,  12,  13,  15,  16,  17,  18,  20,  21,  24,  25,  27,  28,  30,  32,  33,  35,  37,  39,  40,  42,  44,  46,  48,  50,  52,  54,  55,  58,  60,  62,  64,  66,  68,  70,  72,  74,  76,  78,  80,  82,  84,  86,  88,  90,  92,  95,  97,  99, 101, 103, 105, 107, 109, 111, 113, 115, 117, 119, 121, 123, 125, 127, 129, 132, 134, 136, 138, 139, 141, 143, 145, 147, 149, 151, 152, 154, 156, 158, 159, 161, 163, 164, 167, 168, 170, 171, 173, 174, 175, 177, 178, 178,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67},
{  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  11,  12,  13,  15,  16,  17,  18,  20,  21,  23,  25,  27,  28,  30,  32,  33,  35,  37,  40,  41,  43,  45,  47,  49,  51,  53,  54,  57,  59,  61,  63,  65,  67,  69,  71,  73,  76,  78,  80,  82,  84,  86,  88,  90,  92,  95,  97,  99, 101, 103, 105, 107, 109, 111, 114, 116, 118, 120, 122, 124, 126, 128, 130, 133, 135, 137, 138, 140, 142, 144, 146, 148, 151, 152, 154, 156, 158, 160, 161, 163, 164, 167, 168, 170, 171, 173, 174, 175, 177, 178,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67},
{  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  11,  12,  13,  15,  16,  17,  18,  20,  21,  23,  25,  27,  28,  30,  32,  33,  35,  37,  40,  41,  43,  45,  47,  49,  51,  53,  54,  57,  59,  61,  63,  65,  67,  69,  71,  73,  76,  78,  80,  82,  84,  86,  88,  90,  92,  95,  97,  99, 101, 103, 105, 107, 109, 111, 114, 116, 118, 120, 122, 124, 126, 128, 130, 133, 135, 137, 138, 140, 142, 144, 146, 148, 151, 152, 154, 156, 158, 160, 161, 163, 164, 167, 168, 170, 171, 173, 174, 175, 177, 178,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67},
{  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  11,  12,  13,  14,  16,  17,  18,  20,  22,  23,  25,  27,  28,  30,  32,  34,  36,  38,  39,  41,  44,  46,  48,  50,  52,  54,  56,  58,  60,  62,  64,  66,  69,  71,  73,  75,  77,  79,  82,  84,  86,  88,  90,  92,  95,  97,  99, 101, 103, 105, 108, 110, 112, 114, 116, 118, 121, 123, 125, 127, 129, 131, 134, 136, 138, 139, 141, 143, 146, 148, 150, 152, 153, 155, 158, 160, 161, 163, 165, 166, 168, 170, 171, 173, 174, 175, 177, 178,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67},
{  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  11,  12,  13,  14,  16,  17,  18,  20,  22,  23,  25,  27,  29,  31,  32,  34,  37,  39,  40,  42,  45,  47,  49,  51,  53,  55,  57,  59,  61,  64,  66,  68,  70,  72,  75,  77,  79,  81,  84,  86,  88,  90,  92,  95,  97,  99, 101, 103, 106, 108, 110, 112, 115, 117, 119, 121, 123, 126, 128, 130, 132, 135, 137, 139, 140, 142, 145, 147, 149, 151, 153, 155, 157, 159, 160, 163, 165, 166, 168, 170, 171, 173, 174, 175, 177, 178,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67},
{  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  11,  12,  13,  14,  16,  17,  19,  20,  22,  23,  26,  27,  29,  32,  33,  35,  37,  39,  41,  43,  46,  48,  50,  52,  54,  56,  58,  60,  63,  65,  67,  70,  72,  74,  76,  79,  81,  83,  86,  88,  90,  92,  95,  97,  99, 101, 104, 106, 108, 111, 113, 115, 117, 120, 122, 124, 127, 129, 131, 133, 136, 138, 139, 141, 144, 146, 148, 151, 153, 154, 156, 159, 160, 162, 165, 166, 168, 169, 171, 173, 174, 175, 177, 178,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67},
{  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  11,  12,  13,  14,  16,  18,  19,  20,  23,  24,  26,  28,  30,  32,  34,  36,  38,  40,  42,  44,  47,  49,  51,  53,  55,  57,  60,  62,  64,  67,  69,  71,  74,  76,  78,  81,  83,  85,  88,  90,  92,  95,  97,  99, 102, 104, 106, 109, 111, 113, 116, 118, 120, 123, 125, 127, 130, 132, 134, 137, 139, 140, 143, 145, 147, 150, 152, 153, 156, 158, 160, 162, 164, 165, 168, 169, 171, 173, 174, 176, 177, 178,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67},
{  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  11,  12,  13,  14,  16,  18,  19,  21,  23,  25,  27,  28,  31,  32,  35,  37,  39,  41,  43,  46,  48,  50,  53,  54,  56,  59,  61,  64,  66,  68,  71,  73,  76,  78,  80,  83,  85,  88,  90,  92,  95,  97,  99, 102, 104, 107, 109, 111, 114, 116, 119, 121, 123, 126, 128, 131, 133, 135, 138, 139, 141, 144, 146, 149, 151, 153, 155, 157, 160, 161, 163, 165, 167, 169, 171, 172, 174, 176, 177, 178,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67},
{  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  11,  12,  13,  15,  16,  18,  20,  21,  23,  25,  27,  29,  31,  33,  36,  38,  39,  42,  44,  47,  49,  52,  53,  56,  58,  60,  63,  65,  68,  70,  73,  75,  78,  80,  82,  85,  87,  90,  92,  95,  97, 100, 102, 105, 107, 109, 112, 114, 117, 119, 122, 124, 127, 129, 131, 134, 136, 139, 140, 143, 145, 148, 150, 152, 154, 156, 159, 160, 163, 165, 167, 169, 170, 172, 174, 176, 177, 178,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67},
{  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  11,  11,  12,  14,  15,  17,  19,  21,  23,  25,  26,  29,  31,  33,  35,  38,  40,  42,  45,  47,  50,  52,  54,  56,  59,  62,  64,  67,  69,  72,  74,  77,  79,  82,  85,  87,  90,  92,  95,  97, 100, 102, 105, 108, 110, 113, 115, 118, 120, 123, 125, 128, 131, 133, 136, 138, 140, 142, 145, 147, 150, 153, 154, 157, 159, 161, 163, 165, 167, 169, 172, 173, 175, 176, 178, 178,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67},
{  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  11,  11,  12,  14,  16,  17,  20,  21,  23,  26,  27,  30,  31,  34,  37,  38,  41,  44,  46,  49,  51,  53,  56,  58,  61,  63,  66,  69,  71,  74,  77,  79,  82,  84,  87,  90,  92,  95,  97, 100, 103, 105, 108, 110, 113, 116, 118, 121, 124, 126, 129, 131, 134, 137, 139, 141, 143, 146, 149, 151, 154, 156, 158, 161, 162, 165, 167, 169, 171, 172, 174, 176, 178, 178,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67},
{  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  11,  11,  13,  15,  16,  18,  20,  22,  24,  26,  28,  31,  33,  35,  38,  40,  42,  45,  48,  50,  53,  55,  57,  60,  63,  65,  68,  71,  73,  76,  79,  81,  84,  87,  89,  92,  95,  98, 100, 103, 106, 108, 111, 114, 116, 119, 122, 124, 127, 130, 132, 135, 138, 140, 142, 145, 147, 150, 153, 154, 157, 160, 161, 164, 166, 168, 170, 172, 174, 176, 178, 178,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67},
{  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  11,  12,  14,  15,  17,  19,  21,  23,  25,  27,  30,  31,  34,  37,  39,  41,  44,  47,  50,  52,  54,  57,  59,  62,  65,  68,  70,  73,  76,  79,  81,  84,  87,  89,  92,  95,  98, 100, 103, 106, 108, 111, 114, 117, 119, 122, 125, 128, 130, 133, 136, 138, 140, 143, 146, 148, 151, 154, 156, 158, 161, 163, 165, 167, 169, 172, 173, 175, 177, 178,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67},
{  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  11,  11,  13,  15,  17,  19,  21,  22,  25,  27,  30,  32,  35,  37,  39,  42,  45,  48,  51,  52,  55,  58,  61,  64,  67,  69,  72,  75,  78,  81,  84,  86,  89,  92,  95,  98, 101, 103, 106, 109, 112, 115, 118, 120, 123, 126, 129, 132, 135, 137, 140, 142, 145, 148, 151, 153, 155, 158, 161, 163, 166, 167, 169, 172, 174, 176, 178, 178,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67},
{  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  11,  11,  13,  15,  16,  18,  20,  22,  25,  27,  30,  32,  35,  38,  40,  43,  46,  49,  52,  54,  57,  60,  63,  65,  68,  71,  74,  77,  80,  83,  86,  89,  92,  95,  98, 101, 104, 107, 110, 113, 116, 119, 122, 124, 127, 130, 133, 136, 139, 141, 144, 147, 150, 153, 155, 158, 161, 163, 166, 168, 170, 172, 174, 176, 178, 178,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67},
{  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  11,  12,  14,  15,  17,  19,  22,  24,  26,  29,  31,  34,  37,  39,  42,  45,  48,  51,  53,  56,  59,  62,  65,  68,  71,  74,  77,  80,  83,  86,  89,  92,  95,  98, 101, 104, 107, 110, 113, 116, 119, 122, 125, 128, 131, 134, 137, 140, 142, 145, 148, 151, 154, 156, 159, 161, 164, 166, 169, 171, 173, 175, 177, 178,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67},
{  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  11,  12,  14,  15,  17,  20,  22,  24,  26,  30,  32,  35,  38,  40,  43,  46,  49,  52,  55,  58,  61,  64,  67,  70,  73,  76,  79,  83,  86,  89,  92,  95,  98, 101, 104, 108, 111, 114, 117, 120, 123, 126, 129, 132, 136, 139, 141, 144, 147, 150, 153, 155, 158, 161, 164, 166, 169, 171, 173, 175, 177, 178,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67},
{  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  11,  12,  14,  15,  17,  20,  22,  25,  27,  30,  33,  36,  38,  41,  44,  48,  51,  53,  56,  60,  63,  66,  69,  73,  76,  79,  82,  85,  89,  92,  95,  98, 102, 105, 108, 111, 114, 118, 121, 124, 127, 131, 134, 137, 140, 143, 146, 149, 152, 154, 158, 161, 163, 166, 169, 171, 173, 175, 177, 178,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67},
{  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  11,  12,  14,  15,  18,  20,  23,  26,  28,  31,  34,  37,  39,  43,  46,  49,  53,  55,  58,  62,  65,  68,  72,  75,  78,  82,  85,  88,  92,  95,  99, 102, 105, 109, 112, 115, 119, 122, 125, 129, 132, 135, 139, 141, 144, 148, 151, 154, 157, 160, 162, 165, 168, 170, 173, 175, 177, 178,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67},
{  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  11,  12,  14,  16,  18,  21,  23,  26,  29,  32,  35,  39,  41,  44,  48,  51,  54,  57,  61,  64,  68,  71,  75,  78,  81,  85,  88,  92,  95,  99, 102, 106, 109, 112, 116, 119, 123, 126, 130, 133, 137, 139, 143, 146, 149, 153, 155, 159, 161, 165, 167, 170, 172, 174, 177, 178,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67},
{  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  11,  13,  14,  17,  19,  22,  24,  27,  31,  33,  37,  39,  43,  46,  50,  53,  56,  60,  63,  67,  70,  74,  77,  81,  85,  88,  92,  95,  99, 102, 106, 110, 113, 117, 120, 124, 127, 131, 134, 138, 141, 144, 148, 151, 154, 157, 160, 164, 166, 169, 171, 174, 176, 178,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67},
{  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  11,  12,  14,  17,  19,  22,  25,  28,  31,  34,  38,  40,  44,  48,  52,  54,  58,  62,  66,  69,  73,  77,  80,  84,  88,  92,  95,  99, 103, 107, 110, 114, 118, 121, 125, 129, 133, 136, 139, 143, 147, 150, 153, 157, 160, 163, 166, 169, 171, 174, 177, 178,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67},
{  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  11,  12,  15,  17,  20,  23,  25,  28,  32,  35,  39,  42,  46,  50,  54,  56,  60,  64,  68,  72,  76,  80,  84,  88,  92,  95,  99, 103, 107, 111, 115, 119, 123, 127, 131, 134, 138, 141, 145, 149, 152, 156, 159, 163, 165, 168, 171, 174, 177, 178,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67},
{  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  12,  13,  15,  17,  20,  23,  26,  29,  33,  37,  41,  44,  48,  52,  56,  59,  63,  67,  71,  75,  79,  83,  87,  91,  96, 100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 139, 143, 147, 151, 155, 159, 162, 165, 168, 171, 174, 176, 177,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67},
{  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  12,  13,  16,  18,  21,  24,  28,  31,  34,  38,  42,  46,  50,  54,  58,  62,  66,  70,  74,  79,  83,  87,  91,  96, 100, 104, 108, 113, 117, 121, 125, 129, 134, 137, 141, 145, 150, 153, 157, 160, 164, 167, 170, 173, 176, 177,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67},
{  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  12,  13,  16,  18,  22,  25,  28,  32,  35,  40,  43,  48,  52,  57,  60,  65,  69,  73,  78,  82,  87,  91,  96, 100, 105, 109, 114, 118, 122, 127, 131, 135, 139, 144, 148, 152, 156, 160, 163, 166, 170, 173, 176, 177,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67},
{  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  13,  14,  17,  20,  23,  27,  30,  34,  38,  42,  46,  51,  55,  60,  63,  68,  73,  77,  82,  87,  91,  96, 100, 105, 110, 114, 119, 124, 128, 133, 136, 141, 146, 149, 154, 158, 161, 165, 168, 172, 175, 177,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67},
{  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  13,  15,  17,  21,  24,  27,  31,  35,  39,  44,  48,  53,  58,  62,  67,  71,  76,  81,  86,  91,  96, 101, 106, 111, 116, 120, 125, 130, 134, 139, 144, 148, 153, 157, 161, 164, 168, 171, 174, 176,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67},
{  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  14,  16,  19,  22,  25,  29,  33,  38,  42,  47,  51,  56,  61,  65,  70,  76,  81,  86,  91,  96, 101, 106, 111, 117, 122, 127, 131, 136, 141, 145, 150, 155, 159, 163, 167, 170, 173, 175,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67,  67},
{  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  15,  16,  19,  22,  26,  30,  35,  39,  44,  49,  54,  59,  64,  69,  74,  80,  85,  91,  96, 102, 107, 113, 118, 123, 128, 133, 139, 143, 149, 153, 158, 162, 166, 169, 173, 174,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68},
{  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  16,  18,  20,  24,  28,  32,  37,  41,  46,  52,  57,  63,  68,  73,  79,  85,  91,  96, 102, 108, 114, 119, 124, 130, 136, 141, 146, 151, 156, 160, 165, 168, 171, 173,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68},
{  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  18,  20,  23,  26,  30,  35,  39,  44,  50,  56,  61,  67,  73,  78,  84,  90,  97, 103, 109, 115, 120, 126, 132, 137, 143, 148, 153, 158, 162, 166, 169, 172,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68},
{  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  21,  22,  25,  29,  32,  37,  43,  48,  54,  59,  65,  71,  78,  84,  90,  97, 103, 110, 116, 122, 128, 134, 140, 145, 151, 156, 160, 164, 167, 169,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68},
{   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,  24,  25,  28,  31,  36,  40,  46,  51,  58,  64,  71,  77,  84,  90,  97, 104, 110, 117, 123, 130, 136, 142, 148, 153, 157, 161, 164, 166,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1},

};
const uint8_t transform_x[CAMERA_H][CAMERA_W] = { {   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7},
{   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7},
{   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7},
{   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7},
{   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7},
{   9,   9,   9,   9,   9,   9,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   9},
{   9,   9,   9,   9,   9,   9,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   9},
{   9,   9,   9,   9,   9,   9,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   9},
{   9,   9,   9,   9,   9,   9,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   9},
{   9,   9,   9,   9,   9,   9,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   9},
{   9,   9,   9,   9,   9,   9,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   9},
{   9,   9,   9,   9,   9,   9,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   9},
{   9,   9,   9,   9,   9,   9,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   9},
{   9,   9,   9,   9,   9,   9,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   6,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   9},
{  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,  10,  10,  10,  10,  10,  10},
{  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,  10,  10,  10,  10,  10,  10},
{  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,  10,  10,  10,  10,  10,  10},
{  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,  10,  10,  10,  10,  10,  10},
{  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,  10,  10,  10,  10,  10,  10},
{  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,  10,  10,  10,  10,  10,  10},
{  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,  10,  10,  10,  10,  10,  10},
{  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,  10,  10,  10,  10,  10,  10},
{  12,  12,  12,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  11,  11,  11,  11,  11,  11,  11,  11,  11},
{  12,  12,  12,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  11,  11,  11,  11,  11,  11,  11,  11,  11},
{  12,  12,  12,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  11,  11,  11,  11,  11,  11,  11,  11,  11},
{  12,  12,  12,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  11,  11,  11,  11,  11,  11,  11,  11,  11},
{  12,  12,  12,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  11,  11,  11,  11,  11,  11,  11,  11,  11},
{  12,  12,  12,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  11,  11,  11,  11,  11,  11,  11,  11,  11},
{  12,  12,  12,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  11,  11,  11,  11,  11,  11,  11,  11,  11},
{  13,  13,  13,  13,  13,  13,  13,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  13,  13},
{  13,  13,  13,  13,  13,  13,  13,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  13,  13},
{  13,  13,  13,  13,  13,  13,  13,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  13,  13},
{  13,  13,  13,  13,  13,  13,  13,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  13,  13},
{  13,  13,  13,  13,  13,  13,  13,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  13,  13},
{  13,  13,  13,  13,  13,  13,  13,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  13,  13},
{  15,  15,  14,  14,  14,  14,  14,  14,  14,  14,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  14,  14,  14,  14,  14,  14},
{  15,  15,  14,  14,  14,  14,  14,  14,  14,  14,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  14,  14,  14,  14,  14,  14},
{  15,  15,  14,  14,  14,  14,  14,  14,  14,  14,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  14,  14,  14,  14,  14,  14},
{  15,  15,  14,  14,  14,  14,  14,  14,  14,  14,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  14,  14,  14,  14,  14,  14},
{  15,  15,  14,  14,  14,  14,  14,  14,  14,  14,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  14,  14,  14,  14,  14,  14},
{  12,  12,  12,  12,  16,  16,  15,  15,  15,  15,  15,  15,  15,  15,  14,  14,  14,  14,  14,  14,  14,  14,  14,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  14,  14,  14,  14,  14,  14,  14,  14,  14,  15,  15,  15,  15,  15,  15,  12,  12,  12,  12},
{  12,  12,  12,  12,  16,  16,  15,  15,  15,  15,  15,  15,  15,  15,  14,  14,  14,  14,  14,  14,  14,  14,  14,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  14,  14,  14,  14,  14,  14,  14,  14,  14,  15,  15,  15,  15,  15,  15,  12,  12,  12,  12},
{  12,  12,  12,  12,  16,  16,  15,  15,  15,  15,  15,  15,  15,  15,  14,  14,  14,  14,  14,  14,  14,  14,  14,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  14,  14,  14,  14,  14,  14,  14,  14,  14,  15,  15,  15,  15,  15,  15,  12,  12,  12,  12},
{  12,  12,  12,  12,  16,  16,  15,  15,  15,  15,  15,  15,  15,  15,  14,  14,  14,  14,  14,  14,  14,  14,  14,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  14,  14,  14,  14,  14,  14,  14,  14,  14,  15,  15,  15,  15,  15,  15,  12,  12,  12,  12},
{  12,  12,  12,  12,  16,  16,  15,  15,  15,  15,  15,  15,  15,  15,  14,  14,  14,  14,  14,  14,  14,  14,  14,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  14,  14,  14,  14,  14,  14,  14,  14,  14,  15,  15,  15,  15,  15,  15,  12,  12,  12,  12},
{  13,  13,  13,  13,  13,  13,  13,  13,  17,  17,  16,  16,  16,  16,  16,  16,  16,  15,  15,  15,  15,  15,  15,  15,  15,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  15,  15,  15,  15,  15,  15,  15,  15,  15,  16,  16,  16,  16,  16,  13,  13,  13,  13,  13,  13,  13,  13},
{  13,  13,  13,  13,  13,  13,  13,  13,  17,  17,  16,  16,  16,  16,  16,  16,  16,  15,  15,  15,  15,  15,  15,  15,  15,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  15,  15,  15,  15,  15,  15,  15,  15,  15,  16,  16,  16,  16,  16,  13,  13,  13,  13,  13,  13,  13,  13},
{  13,  13,  13,  13,  13,  13,  13,  13,  17,  17,  16,  16,  16,  16,  16,  16,  16,  15,  15,  15,  15,  15,  15,  15,  15,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  15,  15,  15,  15,  15,  15,  15,  15,  15,  16,  16,  16,  16,  16,  13,  13,  13,  13,  13,  13,  13,  13},
{  13,  13,  13,  13,  13,  13,  13,  13,  17,  17,  16,  16,  16,  16,  16,  16,  16,  15,  15,  15,  15,  15,  15,  15,  15,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  12,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  15,  15,  15,  15,  15,  15,  15,  15,  15,  16,  16,  16,  16,  16,  13,  13,  13,  13,  13,  13,  13,  13},
{  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  17,  17,  17,  17,  17,  17,  17,  16,  16,  16,  16,  16,  16,  16,  16,  16,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  16,  16,  16,  16,  16,  16,  16,  16,  17,  17,  17,  17,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14},
{  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  17,  17,  17,  17,  17,  17,  17,  16,  16,  16,  16,  16,  16,  16,  16,  16,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  16,  16,  16,  16,  16,  16,  16,  16,  17,  17,  17,  17,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14},
{  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  17,  17,  17,  17,  17,  17,  17,  16,  16,  16,  16,  16,  16,  16,  16,  16,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  16,  16,  16,  16,  16,  16,  16,  16,  17,  17,  17,  17,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14},
{  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  17,  17,  17,  17,  17,  17,  17,  16,  16,  16,  16,  16,  16,  16,  16,  16,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  16,  16,  16,  16,  16,  16,  16,  16,  17,  17,  17,  17,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14},
{  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  18,  18,  18,  18,  18,  18,  17,  17,  17,  17,  17,  17,  17,  17,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  17,  17,  17,  17,  17,  17,  17,  17,  17,  18,  18,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15},
{  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  18,  18,  18,  18,  18,  18,  17,  17,  17,  17,  17,  17,  17,  17,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  17,  17,  17,  17,  17,  17,  17,  17,  17,  18,  18,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15},
{  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  18,  18,  18,  18,  18,  18,  17,  17,  17,  17,  17,  17,  17,  17,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  17,  17,  17,  17,  17,  17,  17,  17,  17,  18,  18,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15},
{  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  18,  18,  18,  18,  18,  18,  17,  17,  17,  17,  17,  17,  17,  17,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  17,  17,  17,  17,  17,  17,  17,  17,  17,  18,  18,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15},
{  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  19,  19,  19,  19,  18,  18,  18,  18,  18,  18,  18,  18,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  18,  18,  18,  18,  18,  18,  18,  19,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16},
{  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  19,  19,  19,  19,  18,  18,  18,  18,  18,  18,  18,  18,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  18,  18,  18,  18,  18,  18,  18,  19,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16},
{  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  19,  19,  19,  19,  18,  18,  18,  18,  18,  18,  18,  18,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  18,  18,  18,  18,  18,  18,  18,  19,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16},
{  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  20,  20,  20,  19,  19,  19,  19,  19,  19,  19,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  19,  19,  19,  19,  19,  19,  19,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17},
{  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  20,  20,  20,  19,  19,  19,  19,  19,  19,  19,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  19,  19,  19,  19,  19,  19,  19,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17},
{  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  20,  20,  20,  19,  19,  19,  19,  19,  19,  19,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  16,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  19,  19,  19,  19,  19,  19,  19,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17},
{  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  21,  21,  21,  20,  20,  20,  20,  20,  20,  20,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  19,  19,  19,  19,  19,  19,  19,  19,  19,  20,  20,  20,  20,  20,  20,  20,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18},
{  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  21,  21,  21,  20,  20,  20,  20,  20,  20,  20,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  19,  19,  19,  19,  19,  19,  19,  19,  19,  20,  20,  20,  20,  20,  20,  20,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18},
{  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  21,  21,  21,  20,  20,  20,  20,  20,  20,  20,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  19,  19,  19,  19,  19,  19,  19,  19,  19,  20,  20,  20,  20,  20,  20,  20,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18},
{  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  22,  21,  21,  21,  21,  21,  21,  21,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  21,  21,  21,  21,  21,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19},
{  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  22,  21,  21,  21,  21,  21,  21,  21,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  21,  21,  21,  21,  21,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19},
{  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  22,  22,  22,  22,  22,  22,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  21,  21,  21,  21,  21,  21,  21,  21,  21,  22,  22,  22,  22,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20},
{  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  22,  22,  22,  22,  22,  22,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  21,  21,  21,  21,  21,  21,  21,  21,  21,  22,  22,  22,  22,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20},
{  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  22,  22,  22,  22,  22,  22,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  21,  21,  21,  21,  21,  21,  21,  21,  21,  22,  22,  22,  22,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20},
{  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  23,  23,  23,  23,  23,  23,  22,  22,  22,  22,  22,  22,  22,  22,  22,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  22,  22,  22,  22,  22,  22,  22,  22,  23,  23,  23,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21},
{  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  23,  23,  23,  23,  23,  23,  22,  22,  22,  22,  22,  22,  22,  22,  22,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  20,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  22,  22,  22,  22,  22,  22,  22,  22,  23,  23,  23,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21},
{  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  24,  24,  24,  24,  23,  23,  23,  23,  23,  23,  23,  23,  23,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  23,  23,  23,  23,  23,  23,  23,  23,  24,  24,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22},
{  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  24,  24,  24,  24,  23,  23,  23,  23,  23,  23,  23,  23,  23,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  23,  23,  23,  23,  23,  23,  23,  23,  24,  24,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22},
{  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  25,  25,  25,  24,  24,  24,  24,  24,  24,  24,  24,  24,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  24,  24,  24,  24,  24,  24,  24,  24,  24,  25,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23},
{  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  25,  25,  25,  24,  24,  24,  24,  24,  24,  24,  24,  24,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  22,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  24,  24,  24,  24,  24,  24,  24,  24,  24,  25,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23},
{  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  26,  26,  25,  25,  25,  25,  25,  25,  25,  25,  25,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  25,  25,  25,  25,  25,  25,  25,  25,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24},
{  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  26,  26,  25,  25,  25,  25,  25,  25,  25,  25,  25,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  25,  25,  25,  25,  25,  25,  25,  25,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24},
{  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  27,  27,  26,  26,  26,  26,  26,  26,  26,  26,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  26,  26,  26,  26,  26,  26,  26,  26,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25},
{  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  27,  27,  27,  27,  27,  27,  27,  27,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  27,  27,  27,  27,  27,  27,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26},
{  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  27,  27,  27,  27,  27,  27,  27,  27,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  27,  27,  27,  27,  27,  27,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26},
{  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  28,  28,  28,  28,  28,  28,  28,  28,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  28,  28,  28,  28,  28,  28,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27},
{  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  29,  29,  29,  29,  29,  29,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  29,  29,  29,  29,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28},
{  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  29,  29,  29,  29,  29,  29,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  29,  29,  29,  29,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28},
{  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  30,  30,  30,  30,  30,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  30,  30,  30,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29},
{  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  31,  31,  31,  31,  31,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  31,  31,  31,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30},
{  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  32,  32,  32,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  32,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31},
{  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  32,  32,  32,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  30,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  32,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31},
{  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  33,  33,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32},
{  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  34,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33},
{  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34},
{  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  34,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35},
{  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  35,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36},
{  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  36,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,  37},
{  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  38,  38,  38,  38,  38,  38,  38,  38,  38,  38,  38,  38,  38,  38,  38,  38,  38,  38,  38,  38,  38,  38,  38,  38,  38,  38,  38,  38,  38,  38,  38,  38,  38,  38,  38,  38,  38,  38,  38,  38,  38,  38,  38,  38,  38,  38,  38,  38,  38,  38,  38,  38,  38,  38,  38,  38,  38,  38,  38,  38,  38,  38,  38,  38,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39},
{  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  39,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40},
{  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41},
{  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42},
{  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  43,  43,  43,  43,  43,  43,  43,  43,  43,  43,  43,  43,  43,  43,  43,  43,  43,  43,  43,  43,  43,  43,  43,  43,  43,  43,  43,  43,  43,  43,  43,  43,  43,  43,  43,  43,  43,  43,  43,  43,  43,  43,  43,  43,  43,  43,  43,  43,  43,  43,  43,  43,  43,  43,  43,  43,  43,  43,  43,  43,  43,  43,  43,  43,  43,  43,  43,  43,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44},
{  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46},
{  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47},
{  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49,  49},
{  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  49,  50,  50,  50,  50,  50,  50,  50,  50,  50,  50,  50,  50,  50,  50,  50,  50,  50,  50,  50,  50,  50,  50,  50,  50,  50,  50,  50,  50,  50,  50,  50,  50,  50,  50,  50,  50,  50,  50,  50,  50,  50,  50,  50,  50,  50,  50,  50,  50,  50,  50,  50,  50,  50,  50,  50,  50,  50,  50,  50,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51,  51},
{  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  51,  51,  51,  51,  52,  52,  52,  52,  52,  52,  52,  52,  52,  52,  52,  52,  52,  52,  52,  52,  52,  52,  52,  52,  52,  52,  52,  52,  52,  52,  52,  52,  52,  52,  52,  52,  52,  52,  52,  52,  52,  52,  52,  52,  52,  52,  52,  52,  52,  52,  52,  52,  52,  52,  52,  51,  51,  51,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  53},
{  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  53,  53,  53,  53,  53,  53,  54,  54,  54,  54,  54,  54,  54,  54,  54,  54,  54,  54,  54,  54,  54,  54,  54,  54,  54,  54,  54,  54,  54,  54,  54,  54,  54,  54,  54,  54,  54,  54,  54,  54,  54,  54,  54,  54,  54,  54,  54,  54,  54,  54,  54,  53,  53,  53,  53,  53,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55},
{  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  55,  55,  55,  55,  55,  55,  55,  56,  56,  56,  56,  56,  56,  56,  56,  56,  56,  56,  56,  56,  56,  56,  56,  56,  56,  56,  56,  56,  56,  56,  56,  56,  56,  56,  56,  56,  56,  56,  56,  56,  56,  56,  56,  56,  56,  56,  56,  56,  55,  55,  55,  55,  55,  55,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57,  57},
{  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  57,  58,  58,  58,  58,  58,  58,  58,  58,  59,  59,  59,  59,  59,  59,  59,  59,  59,  59,  59,  59,  59,  59,  59,  59,  59,  59,  59,  59,  59,  59,  59,  59,  59,  59,  59,  59,  59,  59,  59,  59,  59,  59,  59,  58,  58,  58,  58,  58,  58,  58,  58,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60},
{  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  60,  60,  60,  61,  61,  61,  61,  61,  61,  61,  62,  62,  62,  62,  62,  62,  62,  62,  62,  62,  62,  62,  62,  62,  62,  62,  62,  62,  62,  62,  62,  62,  62,  62,  62,  62,  62,  62,  62,  62,  62,  61,  61,  61,  61,  61,  61,  61,  60,  60,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63},
{  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  63,  63,  63,  63,  64,  64,  64,  64,  64,  64,  64,  65,  65,  65,  65,  65,  65,  65,  65,  65,  65,  65,  65,  65,  65,  65,  65,  65,  65,  65,  65,  65,  65,  65,  65,  65,  65,  65,  64,  64,  64,  64,  64,  64,  64,  63,  63,  63,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66,  66},
{  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  65,  65,  66,  66,  66,  67,  67,  67,  67,  67,  67,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  67,  67,  67,  67,  67,  67,  66,  66,  66,  66,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69},
{  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  69,  69,  69,  70,  70,  70,  71,  71,  71,  71,  71,  71,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  71,  71,  71,  71,  71,  71,  70,  70,  70,  69,  69,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73,  73},
{  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  71,  71,  72,  72,  73,  73,  73,  74,  74,  74,  74,  74,  74,  75,  75,  75,  75,  75,  75,  75,  75,  75,  75,  75,  75,  75,  75,  75,  75,  75,  75,  74,  74,  74,  74,  74,  73,  73,  73,  72,  72,  72,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76,  76},
{  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  75,  76,  76,  77,  77,  78,  78,  78,  79,  79,  79,  79,  79,  79,  80,  80,  80,  80,  80,  80,  80,  80,  80,  80,  80,  80,  80,  79,  79,  79,  79,  79,  79,  78,  78,  78,  77,  77,  76,  76,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81,  81},
{  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  78,  79,  80,  80,  81,  81,  82,  82,  83,  83,  83,  83,  83,  83,  83,  84,  84,  84,  84,  84,  84,  84,  84,  84,  83,  83,  83,  83,  83,  83,  83,  82,  82,  81,  81,  80,  80,  79,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84,  84},
{  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  83,  84,  85,  85,  86,  87,  87,  88,  88,  88,  89,  89,  89,  89,  89,  89,  89,  89,  89,  89,  89,  89,  89,  89,  89,  89,  89,  88,  88,  88,  87,  87,  86,  85,  84,  84,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,  90},
{  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  87,  88,  89,  90,  91,  92,  93,  93,  94,  94,  94,  95,  95,  95,  95,  95,  95,  95,  95,  95,  95,  95,  95,  95,  94,  94,  94,  93,  93,  92,  91,  90,  89,  88,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96},
{ 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101,  91,  93,  94,  95,  96,  97,  98,  99,  99, 100, 100, 100, 100, 101, 101, 101, 101, 101, 101, 101, 100, 100, 100, 100,  99,  98,  98,  97,  96,  95,  94,  92, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101},
{ 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108,  96,  98,  99, 101, 102, 104, 105, 105, 106, 107, 107, 107, 108, 108, 108, 108, 108, 108, 108, 107, 107, 107, 106, 105, 104, 103, 102, 101,  99,  97, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108},
{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5, 100, 103, 105, 107, 109, 110, 112, 113, 114, 114, 115, 115, 115, 115, 115, 115, 115, 115, 114, 114, 113, 112, 111, 110, 108, 106, 104, 102,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5},

};

////////////////////////////////////////////
//功能：逆透视、去畸变与二值化结合
//输入：
//输出：
//备注：
///////////////////////////////////////////
void transform(int wayThre)
{
    uint8_t* map;
    if (wayThre == 2) {
        map = fullBuffer;
        for (int i = 0; i < 120; i++) {
            if (i <= 40) {
                for (int j = 0; j < 188; j++) {
                    if (*(map + 188 * transform_x[i][j] + transform_y[i][j]) > thresholdUp) {
                        IMG[i][j] = white;
                    }
                    else {
                        IMG[i][j] = black;
                    }
                    if (j<left_side[i] || j>right_side[i]) {
                        IMG[i][j] = gray;
                    }
                }
            }
            else {
                for (int j = 0; j < 188; j++) {
                    if (*(map + 188 * transform_x[i][j] + transform_y[i][j]) > thresholdDown) {
                        IMG[i][j] = white;
                    }
                    else {
                        IMG[i][j] = black;
                    }
                    if (j<left_side[i] || j>right_side[i]) {
                        IMG[i][j] = gray;
                    }
                }
            }

        }
    }
    else {
        map = fullBuffer;
        for (int i = 0; i < 120; i++) {
            for (int j = 0; j < 188; j++) {
                if (*(map + 188 * transform_x[i][j] + transform_y[i][j]) > threshold) {
                    IMG[i][j] = white;
                }
                else {
                    IMG[i][j] = black;
                }
                if (j<left_side[i] || j>right_side[i]) {
                    IMG[i][j] = gray;
                }
            }
        }
    }

}

////////////////////////////////////////////
//功能：逆透视、去畸变与二值化结合
//输入：
//输出：
//备注：同SD卡
///////////////////////////////////////////
void transform_sd(int wayThre)
{
    uint8_t* map;
    uint8_t* threMap;
    //uint8_t* mapFullBuffer;

    map = fullBuffer;
    //mapFullBuffer = map;

    if (wayThre == 2 || wayThre == 1 || wayThre == 3) {
        //map = fullBuffer;
        threMap = fullBuffer;
        //mapFullBuffer = map;

        for (int i = 0; i < 86; i++) {
//            if (i <= 30) {
//                for (int j = 0; j < 188; j++) {
//                    if (*(threMap) > thresholdUp) {
//                        *(threMap) = 255;
//                    }
//                    else {
//                        *(threMap) = 0;
//                    }
//                }
//                threMap++;
//
//
//            }
//            else {
//                for (int j = 0; j < 188; j++) {
//                    if (*(threMap) > thresholdDown) {
//                        *(threMap) = 255;
//                    }
//                    else {
//                        *(threMap) = 0;
//                    }
//                }
//                threMap++;
//
//            }
        }
        for (int i = 0; i < 120; i++) {
            if (i < 30) {
                for (int j = 0; j < 188; j++) {
                    if (*(map + 188 * transform_x[i][j] + transform_y[i][j]) > thresholdUp) {
                        IMG[i][j] = white;
                    }
                    else {
                        IMG[i][j] = black;
                    }
                    if (j<left_side[i] || j>right_side[i]) {
                        IMG[i][j] = gray;
                    }
                }
            }
            else {
                for (int j = 0; j < 188; j++) {
                    if (*(map + 188 * transform_x[i][j] + transform_y[i][j]) > thresholdDown) {
                        IMG[i][j] = white;
                    }
                    else {
                        IMG[i][j] = black;
                    }
                    if (j<left_side[i] || j>right_side[i]) {
                        IMG[i][j] = gray;
                    }
                }
            }

        }
    }
    else if (0) {
        for (int i = 0; i < 2; i++) {
            for (int j = 0; j < 4; j++) {
                map = fullBuffer + 188 * 43 * i + j * 47;
                for (int m = 0; m < 43; m++) {
                    threMap = map + 188 * m;
                    for (int n = 0; n < 47; n++) {
                        if (*threMap > thresholdAdapt[4 * i + j]) {
                            *threMap = 255;
                        }
                        else {
                            *threMap = 0;
                        }
                        threMap++;
                    }
                }


            }
        }
        for (int i = 0; i < 120; i++) {
            for (int j = 0; j < 188; j++) {
                if (*(fullBuffer + 188 * transform_x[i][j] + transform_y[i][j]) > 100)
                    IMG[i][j] = white;
                else if (*(fullBuffer + 188 * transform_x[i][j] + transform_y[i][j]) <= 100)
                    IMG[i][j] = black;

                if (j<left_side[i] || j>right_side[i]) {
                    IMG[i][j] = gray;
                }
            }
        }

    }
    else {
    //  map = fullBuffer;
        threMap = fullBuffer;
        //mapFullBuffer = fullBuffer;
        //////////printf("thre:\n");
        for (int i = 0; i < 86; i++) {
            for (int j = 0; j < 188; j++) {
                if (*(threMap) > threshold) {
                    *(threMap) = 255;
                }
                else {
                    *(threMap) = 0;
                }

                //////////printf("%d,", *(fullBuffer));
                //fullBuffer++;
                threMap++;
            }
            //////////printf("\n");
        }
        //map = mapFullBuffer;
        for (int i = 0; i < 120; i++) {
            for (int j = 0; j < 188; j++) {
                if (*(map + 188 * transform_x[i][j] + transform_y[i][j]) > threshold)
                    IMG[i][j] = white;
                else if (*(map + 188 * transform_x[i][j] + transform_y[i][j]) <= threshold)
                    IMG[i][j] = black;

                if (j<left_side[i] || j>right_side[i]) {
                    IMG[i][j] = gray;
                }
            }
        }
    }

}



void image_Preprocess(void)
{
    uint16_t image_histGram[256] = { 0 };
    float image_histPorprotion[256];
    uint8_t ThreMax = maxThre, ThreMin = minThre/*, threMiddle = 255*/;
    float image_threUpFix = part_klow1.floatVal, image_threDownFix = part_khigh1.floatVal/*, image_threMiddleFix = 1.0*/;
    uint8_t startLine = 0,endLine=86;
    float* ptrhistPorprotion = &image_histPorprotion[0];
        uint16_t* ptrHistGramCy = image_histGram;
        uint8_t* fullBufferCy = fullBuffer;
        for (uint16_t i = 0; i < 256; i++, ptrHistGramCy++)
        {
            *ptrHistGramCy = 0; //初始化灰度直方图
        }
        ptrHistGramCy = image_histGram;
        for (uint8_t i = startLine; i < endLine; i++)
        {
            for (uint8_t j = 2; j < CAMERA_W; j++, fullBufferCy++)
            {
                (*(ptrHistGramCy + (*fullBufferCy)))++; //统计每个灰度值的个数信息
            }
        }
        //归一化
        for (uint16_t i = 0; i < 256; i++, ptrHistGramCy++, ptrhistPorprotion++)
        {
            *ptrhistPorprotion = (float)(*ptrHistGramCy) / (endLine - startLine)*188;
        }



    int thresholdOrigin = 0;
        uint16_t minValue = 0, maxValue = 255, * ptrHistGram;
        float forePorprotion = 0, backPorprotion = 0, foreAverage = 0, backAverage = 0, maxVariance = 0, tmpVariance = 0, * ptrHistPorprotion;
        float tmpBackAverage = 0, tmpForeAverage = 0;
        //测试
        /*uint16_t amount = 0;
        float porAmount = 0;
        for (uint16_t i = CUT_LINE; i < 256; i++)
        {
            amount += image_histGram[i];
            porAmount += image_histPorprotion[i];
        }
        ////////printf("amount:%d\n", amount);
        ////////printf("porAmount:%f\n", porAmount);*/

        ptrHistGram = &image_histGram[0];
        for (minValue = 0; (*ptrHistGram) == 0 && minValue < 256; minValue++, ptrHistGram++);
        ptrHistGram = &image_histGram[255];
        for (maxValue = 255; (*ptrHistGram) == 0 && maxValue > 0; maxValue--, ptrHistGram--);
        ptrHistPorprotion = &image_histPorprotion[minValue];
        for (uint16_t i = minValue; i <= maxValue; i++, ptrHistPorprotion++)
        {
            forePorprotion += (*ptrHistPorprotion);
            tmpForeAverage += (i * (*ptrHistPorprotion));
        }
        ptrHistPorprotion = &image_histPorprotion[minValue];
        for (uint16_t i = minValue; i <= maxValue; i++, ptrHistPorprotion++)
        {
            //背景
            backPorprotion += (*ptrHistPorprotion);
            tmpBackAverage += (i * (*ptrHistPorprotion));
            backAverage = tmpBackAverage / backPorprotion;
            //前景
            forePorprotion -= (*ptrHistPorprotion);
            tmpForeAverage -= (i * (*ptrHistPorprotion));
            foreAverage = tmpForeAverage / forePorprotion;
            //
            tmpVariance = backPorprotion * forePorprotion * (backAverage - foreAverage) * (backAverage - foreAverage);
            if (tmpVariance > maxVariance)
            {
                maxVariance = tmpVariance;
                thresholdOrigin = i;
            }
        }
    threOriginal = thresholdOrigin;


    if (threOriginal > ThreMax)threOriginal = ThreMax;
    if (threOriginal < ThreMin)threOriginal = ThreMin;
    thresholdUp = threOriginal * image_threUpFix, thresholdDown = threOriginal * image_threDownFix/*, threMiddle = threOriginal * image_threMiddleFix*/;

    ////////printf("ThreUp:%d\n", threUp);
    ////////printf("ThreDown:%d\n", threDown);
    //image_RemoveDistortion();
}


////////////////////////////////////////////
//功能：局部阈值分割
//输入：
//输出：
//备注：
///////////////////////////////////////////
void adapt_threshold() {

    uint8_t* map;
    uint8_t* map1;
    for (int i = 0; i < 2; i++) {
        for (int j = 0; j < 4; j++) {
            map = fullBuffer + 188 * 43 * i + j * 47;
            uint8_t my_threshold = 0;
            long int sum = 0;
            uint8_t thre[256] = { 0 };

            for (int m = 0; m < 43; m++) {
                map1 = map + 188 * m;
                for (int n = 0; n < 47; n++) {
                    thre[*(map1)]++;
                    sum += *(map1);
                    map1++;
                }
            }
            int averange = sum / (43 * 47);

            uint8_t max_num = 0, num = 0;

            int min = 160;
            int max = 200;
            // 对不同区域max min 修改,最好使用 “比例”，这样调好之后就不要过多干涉
            if (4 * i + j == 0) {

            }
            else if (4 * i + j == 1) {

            }
            else if (4 * i + j == 2) {

            }
            else if (4 * i + j == 3) {

            }
            else if (4 * i + j == 4) {

            }
            else if (4 * i + j == 5) {

            }
            else if (4 * i + j == 6) {

            }
            else if (4 * i + j == 7) {

            }


            for (int k = 160; k <= 200; k++) {
                int a_less, a_more;
                float p_less, p_more;
                int count_less = 0, count_more = 0;
                int sum_less = 0, sum_more = 0;
                for (int i = 0; i < k; i++) {
                    count_less += thre[i];
                    sum_less += thre[i] * i;
                }
                for (int i = k; i < 255; i++) {
                    count_more += thre[i];
                    sum_more += thre[i] * i;
                }
                p_less = (float)sum_less / (43 * 47);
                p_more = (float)sum_more / (43 * 47);
                if (count_less == 0 || count_more == 0) {
                    continue;
                }
                a_less = sum_less / (count_less);
                a_more = sum_more / (count_more);
                num = count_less * count_more * (a_less - a_more) * (a_less - a_more);
                if (num >= max_num) {
                    max_num = num;
                    my_threshold = k;
                }
            }
            if (my_threshold == 0) {
                my_threshold = threshold;
            }
            //////////printf("thre:threshold=%d\n", my_threshold);
            thresholdAdapt[i * 4+j] = my_threshold;
//            ////////printf("%d=%d\n", i * 4 + j, my_threshold);
        }
    }


}
////////////////////////////////////////////
//功能：阈值的确定
//输入：
//输出：
//备注：大津算法
///////////////////////////////////////////
void OTSU() {
    uint8_t* map;
        uint8_t* my_map;

        map = fullBuffer;
        uint8_t my_threshold = 0;
        uint8_t thre[256] = { 0 };
        double pthre[256] = { 0 };

        for (int i = 0; i < 86 * 188; i++) {
            thre[*(map)]++;
            map++;
        }
        for (int i = 0; i < 256; i++) {
            pthre[i] = (double)thre[i]/(86 * 188);
        }

        uint8_t min_thre, max_thre;
        for (min_thre = 0; thre[min_thre] == 0 && min_thre < 256;  min_thre++);
        for (max_thre = 255; thre[max_thre] == 0 && max_thre >= 0; max_thre--);
        double num = 0, max_num = 0;
        double p_sum_less = 0;
        double p_sum_more = 0;
        double m_Less = 0;
        double m_More = 0;
        double M_Less = 0;
        double M_More = 0;
        for (int i = min_thre; i <= max_thre; i++) {
            p_sum_more += pthre[i];
            m_More += i * pthre[i];
        }
        for (int k = min_thre; k <= max_thre; k++) {
            p_sum_less += pthre[k];
            p_sum_more -= pthre[k];
            m_Less += k * pthre[k];
            m_More -= k * pthre[k];
            M_Less = m_Less / p_sum_less;
            M_More = m_More / p_sum_more;
            num = p_sum_less * p_sum_more * (M_Less - M_More) * (M_Less - M_More);
            if (num > max_num) {
                max_num = num;
                threshold = k;
            }
        }
    //    if(lastThre==0){
    //           lastThre=threshold;
    //       }else{
    //           if(abs(threshold - lastThre) > 7){
    //               threshold=lastThre;
    //           }
    //       }

        uint8_t maxThre1 = maxThre, minThre1 = minThre;
        double upFix = part_klow1.floatVal, downFix = part_khigh1.floatVal;
        if (threshold > maxThre1) threshold = maxThre1;
        if (threshold < minThre1) threshold = minThre1;
        thresholdUp = threshold * upFix;
        thresholdDown = threshold * downFix;
    //  //////printf("upthre=%d,downthre=%d\n", thresholdUp, thresholdDown);


}


uint8_t lastThreUp=0, lastThreDown = 0;
////////////////////////////////////////////
//功能：分区阈值的确定
//输入：
//输出：
//备注：大津算法
///////////////////////////////////////////
void part_OUST() {
        uint8_t* map;
        uint8_t* my_map;
        uint8_t min_thre = minThre, max_thre = maxThre;
        map = fullBuffer;
        uint8_t my_threshold = 0;
        uint8_t thre1[256] = { 0 };
        uint8_t thre2[256] = { 0 };
        double pthre1[256] = { 0 };
        double pthre2[256] = { 0 };
        uint8_t *pt1=thre1,*pt2=thre2;
        double *ppt1=pthre1,*ppt2=pthre2;

        double a;
        double b;
        double c;
        int threB=(max_thre + 25);
        int threA=min_thre;
        int threNewB=threB*1.1;
        int threNewA=threA*0.9;

        if(threNewB > 255) threNewB = 255;
        if(threNewA < 0) threNewA = 0;

        a = (double)threNewA / (double)threA;
        b = (double)(threNewB - threNewA) / (double)(threB - threA);
        c = (double)(255 - threNewB) / (double)(255 - threB);
        int newOne;



        for (int i = 0; i < 30; i++) {
            for(int j=0;j<188;j++){
//                if(40 <= j && j <= 156)   *(map)=(uint8_t)strenghen_contrast_ratio((int)*(map),(int)(min_thre),(int)((min_thre)*0.9),(int)(max_thre + 25),(int)((max_thre + 25)*1.1));

                          thre1[*map]++;
                           map++;
            }
//            if(i>15 * 188){
//                if (*(map) < threA) {
//                    *(map) = a * (*(map));
//                    if(*(map) <= 0) *(map)=0;
//                }
//                else if (threA <= *(map) && threB > *(map)) {
//                    *(map) = b * (*(map) -threA) + threNewA;
//                }
//                else if (threB <= *(map)) {
//                    *(map) = c * (int)(*(map) - threB) + threNewB;
//                    if (*(map) >= 255)  *(map) = 255;
//
//                }
           // }

        }

        for (int i = 30; i < 86; i++) {
            for(int j=0;j<188;j++){
//                if(i<=40 && 40 <= j && j <= 156)  *(map)=(uint8_t)strenghen_contrast_ratio((int)*(map),(int)(min_thre),(int)((min_thre)*0.9),(int)(max_thre + 25),(int)((max_thre + 25)*1.1));
                //            if(i<=40*188){
                //                if (*(map) < threA) {
                //                    *(map) = a * (*(map));
                //                    if(*(map) <= 0) *(map)=0;
                //                }
                //                else if (threA <= *(map) && threB > *(map)) {
                //                    *(map) = b * (*(map) -threA) + threNewA;
                //                }
                //                else if (threB <= *(map)) {
                //                    *(map) = c * (int)(*(map) - threB) + threNewB;
                //                    if (*(map) >= 255)  *(map) = 255;
                //
                //                }
                //            }



                            thre2[(*map)]++;
                            map++;
            }

        }
        for (int i = 0; i < 256; i++) {
            pthre1[i] = (double)(thre1[i]) / (30 * 188);
            pthre2[i] = (double)(thre2[i]) / (56 * 188);
        }
       // uint8_t min_thre = minThre, max_thre = maxThre;
        double numU = 0, max_numU = 0;
        double p_sum_lessU = 0;
        double p_sum_moreU = 0;
        double m_LessU = 0;
        double m_MoreU = 0;
        double M_LessU = 0;
        double M_MoreU = 0;

        double num = 0, max_num = 0;
        double p_sum_less = 0;
        double p_sum_more = 0;
        double m_Less = 0;
        double m_More = 0;
        double M_Less = 0;
        double M_More = 0;

        for (int i = 0; i < min_thre* part_klow1.floatVal - 1; i++) {
            p_sum_lessU +=  pthre1[i];
            m_LessU += i *pthre1[i];
        }
        for (int i = min_thre * part_klow1.floatVal - 1; i < 256; i++) {
            p_sum_moreU += pthre1[i];
            m_MoreU += i *pthre1[i];

        }
        for (int k = min_thre* part_klow1.floatVal; k <= max_thre* part_klow1.floatVal; k++) {
            p_sum_lessU += pthre1[k];
            m_LessU += k*pthre1[k];
            p_sum_moreU -= pthre1[k];
            m_MoreU -= k*pthre1[k];

            M_LessU = m_LessU / p_sum_lessU;
            M_MoreU = m_MoreU / p_sum_moreU;

            numU = p_sum_lessU * p_sum_moreU * (M_LessU - M_MoreU) * (M_LessU - M_MoreU);
            if (numU >= max_numU) {
                max_numU = numU;
                thresholdUp = k ;
            }

        }
        for (int i = 0; i < min_thre- 1; i++){
            p_sum_less += pthre2[i];
            m_Less += i *pthre2[i];
        }
        for (int i = min_thre - 1; i < 256; i++){
            p_sum_more += pthre2[i];
            m_More+=i*pthre2[i];
        }
        for(int k=min_thre;k<=max_thre;k++){
            p_sum_less += pthre2[k];
            m_Less += k *pthre2[k];
            p_sum_more -= pthre2[k];
            m_More -= k * pthre2[k];

            M_Less = m_Less / p_sum_less;
            M_More = m_More / p_sum_more;

            num = p_sum_less * p_sum_more * (M_Less - M_More) * (M_Less - M_More);
            if (num >= max_num) {
                max_num = num;
                thresholdDown = k;
            }
        }
        if(thresholdUp - lastThreUp > 7 && lastThreUp != 0){
            thresholdUp = lastThreUp + 7;
        }else if(thresholdUp - lastThreUp < -7 && lastThreUp != 0){
            thresholdUp = lastThreUp - 7;
        }
        if(thresholdUp>max_thre* part_klow1.floatVal) thresholdUp = max_thre* part_klow1.floatVal;
        if(thresholdUp<min_thre* part_klow1.floatVal) thresholdUp = min_thre* part_klow1.floatVal;

        lastThreUp = thresholdUp;


        if(thresholdDown - lastThreDown > 7 && lastThreDown != 0){
            thresholdDown = lastThreDown + 7;
        }else if(thresholdDown -  lastThreDown< -7 && lastThreDown != 0){
            thresholdDown = lastThreDown - 7;
        }
        if(thresholdDown>max_thre) thresholdDown = max_thre;
        if(thresholdDown<min_thre) thresholdDown = min_thre;
        lastThreDown = thresholdDown;


        //////////printf("upthre=%d,downtgre=%d\n", thresholdUp, thresholdDown);



}

////////////////////////////////////////////
//功能：阈值的确定
//输入：
//输出：
//备注：迭代算法
///////////////////////////////////////////
void iteration() {
    uint8_t* map;
    map = fullBuffer;
    uint8_t threshold1 = 0;
    uint8_t threshold2 = 255;
    float threshold_origin = 0;
    uint8_t img_max = *(map), img_min = *(map);
    for (int i = 0; i < 188 * 120; i++) {
        if (*(map) >= img_max) {
            img_max = *(map);
        }
        else if (*(map) < img_min) {
            img_min = *(map);
        }
        map++;
    }
    threshold_origin = (img_max + img_min) / 2;

    float my_threshold = threshold_origin;

    do {
        threshold_origin = my_threshold;
        map = fullBuffer;
        float img_sum1 = 0, img_sum2 = 0;
        int img_num1 = 0, img_num2 = 0;
        for (int i = 0; i < 120; i++) {
            for (int j = 0; j < 188; j++) {
                if (*(map) >= threshold_origin) {
                    img_sum2 += *(map);
                    img_num2++;
                }
                else {
                    img_sum1 += *(map);
                    img_num1++;
                }
                map++;
            }
        }
        if (img_num1 == 0 || img_num2 == 0) {
            continue;
        }
        else {
            threshold1 = (float)img_sum1 / img_num1;
            threshold2 = (float)img_sum2 / img_num2;
            my_threshold = ((float)(threshold1 + threshold2)) / 2;
        }

    } while (threshold_origin - my_threshold != 0);
    threshold = threshold_origin;
}

////////////////////////////////////////////
//功能：去畸变
//输入：灰度图片
//输出：二值化图片
//备注：
///////////////////////////////////////////
void distortion() {
    uint8_t image_undis[CAMERA_H][CAMERA_W];
    uint8_t image_dis[CAMERA_H][CAMERA_W];

    for (int i = 0; i < 120; i++) {
        for (int j = 0; j < 188; j++) {
            image_dis[i][j] = *(fullBuffer);
            fullBuffer++;
        }
    }


    double fx = 61.5913;
    double fy = 62.0027;
    double u0 = 92.6154;
    double v0 = 63.9785;
    double k1 = -0.0147;
    double k2 = -0.0129;
    double k3 = 0;
    double p1 = -9.6308e-5;
    double p2 = 4.3509e-4;
    double cx = u0, cy = v0;

    for (int x = 0; x < 188; x++) {
        for (int y = 0; y < 120; y++) {
            double x_distorted = 0, y_distorted = 0;
            double x1, y1, x2, y2;
            x1 = (x - cx) / fx;
            y1 = (y - cy) / fy;
            double r2;
            r2 = pow(x1, 2) + pow(y1, 2);
            x2 = x1 * (1 + k1 * r2 + k2 * pow(r2, 2) + k3 * pow(r2, 3)) + 2 * p1 * x1 * y1 + p2 * (r2 + 2 * x1 * x1);
            y2 = y1 * (1 + k1 * r2 + k2 * pow(r2, 2) + k3 * pow(r2, 3)) + p1 * (r2 + 2 * y1 * y1) + 2 * p2 * x1 * y1;
            x_distorted = x2 * fx + cx;
            y_distorted = y2 * fy + cy;

            if (x_distorted >= 0 && y_distorted >= 0 && ((int)x_distorted) < 188 && ((int)y_distorted) < 120) {

                image_undis[y][x] = image_dis[(int)y_distorted][(int)x_distorted];
            }
            else {
                image_undis[y][x] = 0;
            }
        }
    }
    fullBuffer = &image_undis[0][0];

}

////////////////////////////////////////////
//功能：二值化
//输入：灰度图片
//输出：二值化图片
//备注：
///////////////////////////////////////////
void THRE(int num)
{
    if (num != 2) {
        uint8_t* map;
        uint8_t* my_map;
        uint8_t* my_map1;
        map = fullBuffer;

        for (int i = 0; i < 120; i++)
        {
            my_map = &IMG[i][0];
            for (int j = 0; j < 188; j++)
            {
                if ((*map) > threshold)
                    (*my_map) = white;
                else (*my_map) = black;
                map++;
                my_map++;
            }
        }
    }
    else if (num == 2) {
        uint8_t* map;
        uint8_t* my_map;
        uint8_t* my_map1;
        map = fullBuffer;

        for (int i = 0; i < 120; i++)
        {
            my_map = &IMG[i][0];
            if (i < 60) {
                threshold = thresholdUp;
            }
            else if (i >= 120) {
                threshold = thresholdDown;
            }
            for (int j = 0; j < 188; j++)
            {
                if ((*map) > threshold)
                    (*my_map) = white;
                else (*my_map) = black;
                map++;
                my_map++;
            }
        }
    }


}
int My_Max(signed int i, signed int j)
{
    if (i < j)
        return j;
    return i;
}
//取最小值
int My_Min(signed int i, signed int j)
{
    if (i > j)
        return j;
    return i;
}


void ZHAO_THRE()
{

    uint8_t* plineadd = NULL;
    uint8_t* pNextLine = NULL;
    uint8_t* pPreLine = NULL;
    uint8_t* map;
    uint8_t* my_map;
    map = fullBuffer;
    int Grads = 0, sumGrads = 0, sumGrayGrads = 0;

    for (uint8_t i = 1; i < 85; i++)
    {
        plineadd = map + (i * 188);
        pNextLine = map + (i + 1) * 188;
        pPreLine = map + (i - 1) * 188;
        for (uint8_t j = 1; j < 188; j++)
        {
            // 求 水 平 或 垂 直 方 向 的 最 大 梯 度
            Grads = My_Max(abs((int)pPreLine[j] - (int)pNextLine[j]), abs((int)plineadd[j - 1] - (int)plineadd[j + 1]));
            //max( xGrads , yGrads )
            sumGrads += Grads;
            // 梯 度 与 当 前 点 灰 度 的 积
            sumGrayGrads += Grads * ((int)plineadd[j]);
        }
    }
    threshold = sumGrayGrads / sumGrads + 7;

    //以下是使用固定阈值的切换，不用时注释掉
    //threshold = threshold_fix;

    /*for (int i = 0; i < 86; i++)
    {
        my_map = &img_original[i][0];
        for (int j = 0; j < 188; j++)
        {
            if ((*map) > threshold)
                (*my_map) = 1;
            else (*my_map) = 0;
            map++;
            my_map++;
        }
    }*/

}

////////////////////////////////////////////
//功能：逆透视变换 // 指针优化版
//输入：
//输出：
//备注：无
///////////////////////////////////////////
void IPM_map(void)
{
        //int i;
        //int j;
        //uint8_t* pp = NULL;
        //uint8_t* ss = NULL;
        //pp = &left_side[0];
        //ss = &right_side[0];
        //uint8_t* str = NULL;
        //uint8_t* ptr = NULL;
        //str = &IMG;//变换后数组
        //ptr = fullBuffer;//变换前数组
        //uint8_t* pptr = NULL;
        //uint8_t* sstr = NULL;
        //pptr = &i_fix[0];
        //sstr = &j_fix[0][0];
        //int j_begin, j_end;
        //uint8_t* tstr = NULL;
        //uint8_t* tsstr = NULL;
        //uint8_t* tptr = NULL;
        //for (i = 0; i < CAMERA_H; i++)
        //{
        //    j_begin = *(pp + i);
        //    j_end = *(ss + i);
        //    tstr = str + i * 188;
        //    tsstr = sstr + i * 188;
        //    tptr = ptr + *(pptr + i) * 188;
        //    for (j = j_begin; j <= j_end; j++)
        //    {
        //        *(tstr + j) = *(tptr + *(tsstr + j));
        //        if (*(tptr + *(tsstr + j)) > threshold) {
        //            *(tstr + j) = white;
        //        }
        //        else {
        //            *(tstr + j) = black;
        //        }
        //        if(i<=40){
        //            if (*(tptr + *(tsstr + j)) > thresholdUp) {
        //                *(tstr + j) = white;
        //                  }
        //            else {
        //                *(tstr + j) = black;
        //            }
        //        }else{
        //            if (*(tptr + *(tsstr + j)) > thresholdDown) {
        //                *(tstr + j) = white;
        //            }
        //            else {
        //                *(tstr + j) = black;
        //            }
        //        }
        //    }
        //}
        //for (int m = 0; m < 120; m++) {
        //    for (int n = 0; n < 188; n++) {
        //      IMG[m][n] = IMG_IMP[m][n];
        //    }
        //}
}//map

////////////////////////////////////////////
//功能：粗犷的清车头
//输入：
//输出：
//备注：要根据自己车头的大小进行修改
///////////////////////////////////////////
void head_clear(void)
{
    uint8_t* my_map;
    for (int i = 85; i >= 79; i--)
    {
        my_map = &IMG[i][0];
        for (int j = 62; j <= 112; j++)
        {
            *(my_map + j) = white;
        }
    }
}

////////////////////////////////////////////
//功能：查找父节点
//输入：节点编号
//输出：最老祖先
//备注：含路径压缩
///////////////////////////////////////////
int find_f(int node)
{
    if (f[node] == node)return node;//找到最古老祖先，return
    f[node] = find_f(f[node]);//向上寻找自己的父节点
    return f[node];
}

////////////////////////////////////////////
//功能：提取跳变沿 并对全部白条子标号
//输入：IMG[120][188]
//输出：white_range[120]
//备注：指针提速
///////////////////////////////////////////
void search_white_range()
{
    uint8_t i, j;
    int istart = NEAR_LINE;//处理起始行
    int iend = FAR_LINE;//处理终止行
    int tnum = 0;//当前行白条数
    all_connect_num = 0;//白条编号初始化
    uint8_t* map = NULL;
    uint8_t* ptrLeftSide = &left_side[0];
    uint8_t* ptrRightSide = &right_side[0];
    for (i = istart; i >= iend; i--)
    {
        //map = &IMG[i][LEFT_SIDE];//指针行走加快访问速度
        map = &IMG[i][ptrLeftSide[i]];
        tnum = 0;
        for (j = ptrLeftSide[i]; j <= ptrRightSide[i]; j++, map++)//j为横坐标
        {
            if ((*map))//遇白条左边界
            {
                tnum++;
                if (tnum >= white_num_MAX)break;
                range* now_white = &white_range[i].area[tnum];
                now_white->left = j;

                //开始向后一个一个像素点找这个白条右边界
                map++;
                j++;

                while ((*map) && j <= ptrRightSide[i])
                {
                    map++;
                    j++;
                }
                now_white->right = j - 1;
                now_white->connect_num = ++all_connect_num;//白条数加一，给这个白条编号
            }
        }
        white_range[i].num = tnum;
    }
}

////////////////////////////////////////////
//功能：寻找白条子连通性，将全部联通白条子的节点编号刷成最古老祖先的节点编号
//输入：
//输出：
//备注：
///////////////////////////////////////////
void find_all_connect()
{
    //f数组初始化
    for (int i = 1; i <= all_connect_num; i++)
        f[i] = i;

    //u为up d为down 即为当前处理的这两行中的上面那行和下面那行
    //u_num：上面行白条数
    //u_left：上面行当前白条左边界
    //u_right：上面行当前白条右边界
    //i_u：当前处理的这个白条是当前这行（上面行）白条中的第i_u个
    int u_num, i_u, u_left, u_right;
    int d_num, i_d, d_left, d_right;
    all_range* u_white = NULL;
    all_range* d_white = NULL;
    for (int i = NEAR_LINE; i > FAR_LINE; i--)//因为每两行每两行比较 所以循环到FAR_LINE+1
    {
        u_num = white_range[i - 1].num;
        d_num = white_range[i].num;
        u_white = &white_range[i - 1];
        d_white = &white_range[i];
        i_u = 1; i_d = 1;

        //循环到当前行或上面行白条子数耗尽为止/-
        while (i_u <= u_num && i_d <= d_num)
        {
            //变量先保存，避免下面访问写的冗杂且访问效率低
            u_left = u_white->area[i_u].left;
            u_right = u_white->area[i_u].right;
            d_left = d_white->area[i_d].left;
            d_right = d_white->area[i_d].right;

            if (u_left <= d_right && u_right >= d_left)//如果两个白条联通
                f[find_f(u_white->area[i_u].connect_num)] = find_f(d_white->area[i_d].connect_num);//父节点连起来

            //当前算法规则，手推一下你就知道为啥这样了
            if (d_right > u_right)i_u++;
            if (d_right < u_right)i_d++;
            if (d_right == u_right) { i_u++; i_d++; }
        }
    }
}

////////////////////////////////////////////
//功能：寻找赛道
//输入：
//输出：
//备注：
///////////////////////////////////////////
void find_road()
{
    uint8_t istart = NEAR_LINE;
    uint8_t iend = FAR_LINE;
    top_road = NEAR_LINE;//赛道最高处所在行数，先初始化话为最低处
    int road_f = -1;//赛道所在连通域父节点编号，先初始化为-1，以判断是否找到赛道
    int while_range_num = 0, roud_while_range_num = 0;
    all_range* twhite_range = NULL;
    road* tmy_road = NULL;
    //寻找赛道所在连通域
    // 寻找最中心的白条子
    for (int i = 1; i <= white_range[istart].num; i++)
        if (white_range[istart].area[i].left <= CAMERA_W / 2
            && white_range[istart].area[i].right >= CAMERA_W / 2 && (white_range[istart].area[i].right - white_range[istart].area[i].left) >= 90)
            road_f = find_f(white_range[istart].area[i].connect_num);

    if (road_f == -1)//若赛道没在中间，在113行选一行最长的认为这就是赛道
    {
        int widthmax = 0, jselect = 1;
        for (int i = 1; i <= white_range[istart].num; i++)
            if (white_range[istart].area[i].right - white_range[istart].area[i].left > widthmax)
            {
                widthmax = white_range[istart].area[i].right - white_range[istart].area[i].left;
                jselect = i;
            }
        road_f = find_f(white_range[istart].area[jselect].connect_num);
    }

    //现在我们已经得到了赛道所在连通域父节点编号，接下来把所有父节点编号是road_f的所有白条子扔进赛道数组就行了
    for (int i = istart; i >= iend; i--)
    {
        //变量保存，避免之后写的冗杂且低效
        twhite_range = &white_range[i];
        tmy_road = &my_road[i];
        while_range_num = twhite_range->num;
        tmy_road->white_num = 0;
        roud_while_range_num = 0;
        for (int j = 1; j <= while_range_num; j++)
        {
            if (find_f(twhite_range->area[j].connect_num) == road_f)
            {
                top_road = i;
                tmy_road->white_num++; roud_while_range_num++;
                tmy_road->connected[roud_while_range_num].left = twhite_range->area[j].left;
                tmy_road->connected[roud_while_range_num].right = twhite_range->area[j].right;
                tmy_road->connected[roud_while_range_num].width = twhite_range->area[j].right - twhite_range->area[j].left;

            }
        }
    }
}

////////////////////////////////////////////
//功能：返回相连下一行白条子编号
//输入：i_start起始行  j_start白条标号
//输出：白条标号
//备注：认为下一行与本行赛道重叠部分对多的白条为选定赛道
///////////////////////////////////////////
uint8_t find_continue(uint8_t i_start, uint8_t j_start)
{
    uint8_t j_return;
    uint8_t j;
    uint8_t width_max = 0;
    uint8_t width_new = 0;
    uint8_t left = 0;
    uint8_t right = 0;
    uint8_t dright, dleft, uright, uleft;
    j_return = MISS;//如果没找到，输出255
    if (j_start > my_road[i_start].white_num)
        return MISS;
    //选一个重叠最大的
    for (j = 1; j <= my_road[i_start - 1].white_num; j++)
    {
        dleft = my_road[i_start].connected[j_start].left;
        dright = my_road[i_start].connected[j_start].right;
        uleft = my_road[i_start - 1].connected[j].left;
        uright = my_road[i_start - 1].connected[j].right;
        if (//相连
            dleft < uright
            &&
            dright > uleft
            )
        {
            //计算重叠大小
            if (dleft < uleft) left = uleft;
            else left = dleft;

            if (dright > uright) right = uright;
            else right = dright;

            width_new = right - left + 1;

            if (width_new > width_max)
            {
                width_max = width_new;
                j_return = j;
            }
        }

    }
    return j_return;
}

////////////////////////////////////////////
//功能：通用决定双边（找连通路径）
//输入：
//输出：
//备注：
///////////////////////////////////////////
void ordinary_two_line(void)
{
    uint8_t i;
    uint8_t j;
    //uint8_t j_continue[CAMERA_H];//第一条连通路径
    uint8_t i_start;
    uint8_t i_end;
    uint8_t j_start = MISS;
    int width_max;

    //寻找起始行最宽的白条子
    i_start = NEAR_LINE;
    i_end = FAR_LINE;
    width_max = 0;

    for (j = 1; j <= my_road[i_start].white_num; j++)
    {
        ////////////////////////////////////////////////////////////////printf("n=%d", my_road[j].white_num);
        if (my_road[i_start].connected[j].width > width_max)
        {
            width_max = my_road[i_start].connected[j].width;
            j_start = j;
        }
    }
    j_continue[i_start] = j_start;

    //记录连贯区域编号
    for (i = i_start; i > i_end; i--)
    {
        //如果相连编号大于该行白条数，非正常，从此之后都MISS
        if (j_continue[i] > my_road[i].white_num)
        {
            j_continue[i - 1] = MISS;
        }
        else
        {
            j_continue[i - 1] = find_continue(i, j_continue[i]);
        }

    }

    //全部初始化为MISS
    my_memset(left_line, MISS, CAMERA_H);
    my_memset(right_line, MISS, CAMERA_H);


    for (i = i_start; i > i_end; i--)
    {
        if (j_continue[i] <= my_road[i].white_num)
        {

            right_line[i] = my_road[i].connected[j_continue[i]].right;
            left_line[i] = my_road[i].connected[j_continue[i]].left;
            /*IMG[i][left_line[i]] = blue;
            IMG[i][right_line[i]] = red;*/
        }
        else
        {
            left_line[i] = MISS;
            right_line[i] = MISS;
        }
    }
}

////////////////////////////////////////////
//功能：通用决定双边
//输入：
//输出：
//备注：历史寻路法
///////////////////////////////////////////
void orinary_two_line_history() {
    uint8_t i;
    uint8_t j;
    //uint8_t j_continue[CAMERA_H];//第一条连通路径
    uint8_t i_start;
    uint8_t i_end;
    uint8_t j_start = MISS;
    int width_max;


    //寻找起始行最宽的白条子
    i_start = NEAR_LINE;
    i_end = FAR_LINE;
    width_max = 0;

    for (j = 1; j <= my_road[i_start].white_num; j++)
    {
        if (my_road[i_start].connected[j].width > width_max)
        {
            width_max = my_road[i_start].connected[j].width;
            j_start = j;
        }
    }
    j_continue[i_start] = j_start;

    for (int i = i_start; i > i_end; i--) {
        uint8_t midComb[100];
        uint8_t min = 1;
        int flag = 0;
        if (mid_line[i] == 0) {
            mid_line[i] = 94;
        }
        ////////////////////////////////////////////////////printf("%d=%d\n", i, mid_line[i]);
        for (int j = 1; j <= my_road[i].white_num; j++) {
            midComb[j] = (my_road[i].connected[j].left + my_road[i].connected[j].right) / 2;

            if (my_road[i].connected[j].width < 10) {
                continue;
            }
            else {
                if (abs(mid_line[i] - midComb[min]) >= abs(mid_line[i] - midComb[j])) {
                    min = j;
                    flag = 1;
                }
            }

        }
        j_continue[i] = min;
        ////////////////////////////////////////////////////printf("j=%d", j_continue[i]);
    }

    //记录连贯区域编号
    /*for (i = i_start; i > i_end; i--)
    {
        //如果相连编号大于该行白条数，非正常，从此之后都MISS
        if (j_continue[i] > my_road[i].white_num)
        {
            j_continue[i - 1] = MISS;
        }
        else
        {
            j_continue[i - 1] = find_continue(i, j_continue[i]);
        }

    }*/

    //全部初始化为MISS
    my_memset(left_line, MISS, CAMERA_H);
    my_memset(right_line, MISS, CAMERA_H);


    for (i = i_start; i > i_end; i--)
    {
        if (j_continue[i] <= my_road[i].white_num)
        {

            right_line[i] = my_road[i].connected[j_continue[i]].right;
            left_line[i] = my_road[i].connected[j_continue[i]].left;
        }
        else
        {
            left_line[i] = MISS;
            right_line[i] = MISS;
        }
    }
}

////////////////////////////////////////////
//功能：数组初始化
//输入：uint8_t* ptr 数组首地址, uint8_t num初始化的值, uint8_t size数组大小
//输出：
//备注：因为k66库中认为memset函数不安全，所以无法使用；因此需要自己写一个my_memset
///////////////////////////////////////////
void my_memset(uint8_t* ptr, uint8_t num, uint8_t size)
{
    uint8_t* p = ptr;
    uint8_t my_num = num;
    uint8_t Size = size;
    for (int i = 0; i < Size; i++, p++)
    {
        *p = my_num;
    }
}

////////////////////////////////////////////
//功能：中线合成
//输入：左右边界
//输出：中线
//备注：
///////////////////////////////////////////
void get_mid_line(void)
{
    my_memset(mid_line, MISS, CAMERA_H);
        for (int i = NEAR_LINE; i >= FAR_LINE; i--) {
            if (left_line[i] != MISS && my_road[i].white_num!=0)
            {
                mid_line[i] = (left_line[i] + right_line[i]) / 2;
            }
            else
            {

                mid_line[i] = mid_line[i + 1];
            }
           // last_mid_line[i] = mid_line[i];
        }
//    my_memset(mid_line, MISS, CAMERA_H);
//
//    for (int i = NEAR_LINE; i >= FAR_LINE; i--){
//        if (left_line[i] != MISS && my_road[i].white_num!=0)
//        {
//            mid_line[i] = (left_line[i] + right_line[i]) / 2;
//        }
//        else if (left_line[i] == MISS && state != stateRampway)
//        {
//
//            mid_line[i] = mid_line[i + 1];
//        }
//        else if(left_line[i] == MISS && state == stateRampway)
//        {
//            int way=1;
//            if(way == 1){
//                mid_line[i] = 92;
//            }else if(way == 2){
//                if(my_road[i].white_num!=0){
//                    mid_line[i]=(my_road[i].connected[1].left+my_road[i].connected[1].right)/2;
//                    for(int j=1;j<=my_road[i].white_num;j++){
//                        if(abs((my_road[i].connected[j].left+my_road[i].connected[j].right)/2-92)<abs(mid_line[i]-92)){
//                            mid_line[i]=(my_road[i].connected[j].left+my_road[i].connected[j].right)/2;
//                        }
//                    }
//                }else{
//                    mid_line[i] = mid_line[i + 1];
//                }
//
//            }
//
//        }
//        last_mid_line[i] = mid_line[i];
//    }


}
////////////////////////////////////////////
//功能：增强对比度
//输入：像素值，对比度节点
//输出：像素值
//备注：
///////////////////////////////////////////
int strenghen_contrast_ratio(int oldThre,int threA, int threNewA, int threB, int threNewB) {

    double a;
    double b;
    double c;

    if(threNewB > 255) threNewB = 255;
    if(threNewA < 0) threNewA = 0;
    a = (double)threNewA / (double)threA;
    b = (double)(threNewB - threNewA) / (double)(threB - threA);
    c = (double)(255 - threNewB) / (double)(255 - threB);
    int newOne;

    if (oldThre < threA) {
        newOne = a * oldThre;
        if(newOne <= 0) newOne=0;
    }
    else if (threA <= oldThre && threB > oldThre) {
        newOne = b * (oldThre -threA) + threNewA;
    }
    else if (threB <= oldThre) {
        newOne = c * (int)(oldThre - threB) + threNewB;
        if (newOne >= 255)  newOne = 255;

    }

    return newOne;

}
////////////////////////////////////////////
//功能：图像处理主程序
//输入：
//输出：
//备注：
///////////////////////////////////////////
void image_main()
{
    threshold = presentTHRE.intVal;
    int wayThreshold = wayThre.intVal;
    protection();
//    strenghen_contrast_ratio();
//    uint64 tim1 = 0, tim2 = 0;


//    tim1 = Systick_Get(STM0)/100000;
    switch (wayThreshold) {
    case 0:break;
    case 1:OTSU();
        break;
    case 2:part_OUST();
        break;
    case 3:image_Preprocess();
        break;
    case 4:ZHAO_THRE();
        break;
    case 5:iteration();
        break;
    }

//    tim2 = Systick_Get(STM0)/100000;
//    test_varible[14] = (float)(tim1);
//    test_varible[15] = (float)(tim2);
    //distortion();
    //THRE(wayThreshold);
    //IPM_map();
    //decide_miss();
    //head_clear();
   // transform(wayThreshold);


//
    transform_sd(wayThreshold);

    //



    search_white_range();
    find_all_connect();
    find_road();
    /*到此处为止 我们已经得到了属于赛道的结构体数组my_road[CAMERA_H]*/
    ordinary_two_line();

    if(parkStart == 0)
    {
        judge_type_road();

    }

    test_varible[13]=state;

    for (int i = NEAR_LINE; i > FAR_LINE; i--)
    {

        IMG[i][left_line[i]] = red;
        IMG[i][right_line[i]] = blue;
    }
    get_mid_line();
    mid_line_filter();
    averMidLine = mid_aver();
//    test_varible[15] = valid_row();
//    for (int )
    for (int i = NEAR_LINE; i >= FAR_LINE; i--)
        if (mid_line[i] != MISS)
            IMG[i][mid_line[i]] = green;

    IMG[74][mid_line[74]] = purple;
}

////////////////////////////////////////////
//功能：道路类型判断
//输入：
//输出：
//备注：初判断应该会出现很多混淆，之后会进行类似元素的单独判断
///////////////////////////////////////////
void judge_type_road() {
//    state=100;
//    islandWhere=RIGHT;
    leftUpJumpPoint = 119;
    leftDownJumpPoint = 119;
    rightUpJumpPoint = 119;
    rightDownJumpPoint = 119;
    int lastState = state;
    int flagChange = 0;


    if(state != laststate)
    {
        laststate = state;
        integerSpeedCNT += (integerSpeedR - integerSpeedL) / 2;
        test_varible[14] = integerSpeedCNT;
        integerSpeedL = 0;
        integerSpeedR = 0;
    }
    CTRL_encoderCount();

//    CCD();

    //十字
    if (state == stateStart && flagChange == 0) {
        //cross_in();
        if (my_road[40].white_num != 0)
            folk_road_in();
            folkTimesCNT();
            test_varible[6] = folkCNT;

      //  T_island_in_start();
//        if (lastState != state) {
//            flagChange = 1;
//        }

    }
    if (state == stateStart) {
        if (flagIT == stateIslandFinal * RIGHT || flagIT == stateTOut * RIGHT) {
            if (my_road[NEAR_LINE - 1].connected[j_continue[NEAR_LINE - 1]].width < 28) {
                if(file1.intVal == 1 || file1.intVal == 0)
                {
                    if(islandTimes != 2)
                    {
                        if(carParkTimes == 0 || folkOutTimes == 2)
                        {
                            T_island_in_start();

                        }
//
                    }

                }
                else if(file1.intVal == -1)
                {
                    if(islandTimes <= 2)
                    {
                        T_island_in_start();

                    }
                }
            }

        }
        else {
            if(file1.intVal == 1 || file1.intVal == 0)
            {
                if(islandTimes != 2)
                {
                    if(carParkTimes == 0 || folkOutTimes == 2)
                    {
                        T_island_in_start();

                    }
                }

            }
            else if(file1.intVal == -1)
            {
                if(islandTimes <= 2)
                {
                    T_island_in_start();

                }
            }
//            T_island_in_start();
        }
        if (lastState != state) {
            flagChange = 1;
        }
    }
    if (state != 0) {
        flagIT = 0;
    }
    if (state == stateCrossIn && flagChange == 0) {
        cross_over();
        if (lastState != state) {
            flagChange = 1;
        }

    }
    if (state == stateFolkRoadIn && flagChange == 0) {
        folk_road_out();
        if (lastState != state) {
            flagChange = 1;
        }

    }
    if (state == stateTIslandIn && flagChange == 0) {
        T_or_island();
     //   island_radius();
        if (lastState != state) {
            flagChange = 1;
        }

    }
    if (state == stateSTIsland && flagChange == 0) {
        straightT_or_island();
//            island_radius();
            if (lastState != state) {
                flagChange = 1;
            }

        }

    if (state == stateIslandIng && (flagChange == 0 || state == stateSTIsland)) {
        island_turn();
        if (lastState != state) {
            flagChange = 1;
        }

    }
    if (state == stateIslandTurn && flagChange == 0) {
        island_circle();
        if (lastState != state) {
            flagChange = 1;
        }

    }
    if (state == stateIslandCircle && flagChange == 0) {

        islandCircleCount += 1;
        if(islandCircleCount >= 4)
        {
            island_out();

        }
        if (lastState != state) {
            flagChange = 1;
        }

    }
    if (state == stateIslandOut && flagChange == 0) {
        island_straight();
        if (lastState != state) {
            flagChange = 1;
        }

    }
    if (state == stateIslandFinal && flagChange == 0) {
        island_final();
        if (lastState != state) {
            flagChange = 1;
        }

    }
    if (state == stateTIn && flagChange == 0) {
//        TcircleFix();
        cross_T_out_start();
        if (lastState != state) {
            flagChange = 1;
        }


    }
    if (state == stateTOut && flagChange == 0) {
        cross_T_out_over();
        if (lastState != state) {
            flagChange = 1;
        }

    }

    carPark_main();

    if (lastState == 30 && state == 70) {
        islandTimes++;
    }
//    test_varible[14] = islandTimes;
    if (islandTimes == 1) {
//        IslandRadius = 100;
        IslandRadius = islandParam6.intVal;
    }
    else if (islandTimes == 2) {
//        IslandRadius = 50;
        IslandRadius = islandParam6.intVal;
    }
    else if(islandTimes == 3) {
        IslandRadius = islandParam6.intVal;
//        IslandRadius = 100;
    }
    else if (islandTimes == 4) {
        IslandRadius = islandParam6.intVal;
//        IslandRadius = 50;

    }

//        else if (islandTimes == 5) {
//            IslandRadius;
//        }
//        else if (islandTimes == 6) {
//            IslandRadius;
//        }

    if(lastState == 60 && state == 40){
        islandTimes--;
    }

    if(state == 50 && lastState == 40)
    {
        tCrossTimes += 1;
    }


//    if(file1.intVal == 1)
//    {
//        if(state == 0 && lastState == 20)
//        {
//            folkTimes += 1;
//        }
//        if(folkTimes >= 4)
//        {
//            leftPark = 0;
//            rightPark = 1;
////            searchParkLine();
//        }
//    }
//
//    else if(file1.intVal == -1)
//    {
//        if(lastState == 50)
//        {
//            tCrossTimes += 1;
//        }
//
//        if(tCrossTimes >= 2)
//        {
//            leftPark = 1;
//            rightPark = 0;
////            searchParkLine();
//        }
//    }
//    searchParkLine();
//    test_varible[15] = folkTimes;
//    test_varible[14] = lastState;
    //补线
    if (state == stateCrossIn) {
        design_cross_ing();

    }
    if (state == stateFolkRoadIn) {
        design_folk_road();
    }
    if (state == stateTIslandIn || state == stateSTIsland) {
        design_T_island_in();
        tInCount = 0;

    }
    if (state == stateIslandIng) {
        design_island_ing();
    }
    if (state == stateIslandTurn) {
        design_island_turn();
    }
    if (state == stateIslandCircle) {
        design_island_circle();
        roof();
    }
    if (state == stateIslandOut) {
        design_island_out();
    }
    if (state == stateIslandFinal) {
        design_island_straight();
    }
    if (state == stateTIn) {
        design_cross_T_circle();
        roof();
    }
    if (state == stateTOut) {
        design_cross_T_out();
    }



    if(state == stateFolkRoadIn  || state == stateStart )
    {
        if(rampTimes == 0 && folkTimes == 3 && integerSpeedCNT >= 150000)
        {
            rampwayOn();

        }
//        if(rampJudgeCount >= 200)
//        {
//            rampwayOn();
//
//        }
        lastTwoState = 0;
        rampWayCount = 0;
        //        lastRampGyro = 0;
        //        rampGyro = 0;
        //        rampGyroMax = 0;
    }

    if(state == stateRampway)
    {
        GPIO_Set(P22, 0, 1);
        rampWayCount += 1;
        rampwayDown();

        if(rampWayCount > rampCount.intVal)
        {

            state = 0;
//            afterRampFlag = 1;
            rampWayCount=0;
        }

        if(state == 0)
        {
            afterRampFlag = 1;
        }
    }

    else if(state != stateRampway)
    {
//        GPIO_Set(P22, 0, 0);
        rampWayCount = 0;
    }

    if(afterRampFlag == 1)
    {

        if(integerSpeedAver > 3000)
        {
            afterRampFlag = 0;
        }
    }

    if(state != stateRampway && state != stateParkIn){
//        TcircleFix();
        rampJudgeCount += 1;
    }

    if(state != stateRampway)
    {
        straight_define();

//        test_varible[14] = straightFlag;
    }

    roadMemory();
//    if(sRoadFlag == 0)
//    {
//        small_s_road();
//        sRoadCount = 0;
//    }
//    else if(sRoadFlag == 1)
//    {
//        big_mid_line_filter();
//        sRoadCount += 1;
//        if(sRoadCount >= 80)
//        {
//            sRoadFlag = 0;
//        }
//    }
//    test_varible[14] = sRoadFlag;
//    if(folkTimes == 1 || folkTimes == 3)
//    {
//        big_mid_line_filter();
//    }

    //关于想区分环岛与T字路口的想法失败
    //因此不得不再次尝试共用状态
    if (state != 30 && state != 40 && state != 50 && state != 60 && state != 70 && state != 80 && state != 90 && state != 100 && state != 110 ) {
        TIslandWhere = 0;
        islandWhere = 0;
        TWhere = 0;
    }
    if (state != 30 && state != 70 && state != 80 && state != 90 && state != 100 && state != 110) {
        midDownDistance = 0;
        midTimes = 0;
    }



//    if (state == 10 || state == 20 ) {
//        forceOut++;
//        if (state == 10 || state == 20) {
//            if (forceOut >= 50) {
//                state = 0;
//                forceOut = 0;
//            }
//        }
////        if (state == 50 || state == 110) {
////            if (forceOut >= 50) {
////                state = 0;
////                forceOut = 0;
////            }
////        }
//    }
//    else {
//        forceOut = 0;
//    }
    if(state != 80){
        lastUpPoint = 0;
    }

    if(state != lastState){
        Loud=0;
        Loud++;
    }else if(Loud !=0){
        Loud++;
    }

    if(Loud > 0 && Loud <= 5){
        GPIO_Set(P22,0,1);
    }else{
        GPIO_Set(P22,0,0);
        Loud=0;
    }


}

////////////////////////////////////////////
//功能：斜率计算
//输入：起点，终点，起点,终点所在数组
//输出：斜率
//备注：最小二乘法
///////////////////////////////////////////
double calculate_slope(int start, int end, int side[CAMERA_H]) {
    double ySum = 0;
    double y2Sum = 0;
    double xSum = 0;
    double xySum = 0;

    if (end >= NEAR_LINE) {
        end = NEAR_LINE - 1;
    }
    if (start <= 0) {
        start = 0;
    }
    int num = end - start + 1;
    for (int i = start; i <= end; i++) {
        xSum += side[i];
        ySum += i;
        y2Sum += i * i;
        xySum += i * side[i];
    }
    if ((num * y2Sum - ySum * ySum) != 0) {

        double Slope = (double)(num * xySum - xSum * ySum) / (num * y2Sum - ySum * ySum);
        return Slope;
    }
    else {
        return 0;
    }
}

////////////////////////////////////////////
//功能：斜率计算
//输入：起点，终点，起点,终点所在数组
//输出：斜率
//备注：最小二乘法
///////////////////////////////////////////
double calculate_slope_uint(int start, int end, uint8_t side[CAMERA_H]) {
    double ySum = 0;
    double y2Sum = 0;
    double xSum = 0;
    double xySum = 0;

    if (end >= NEAR_LINE) {
        end = NEAR_LINE;
    }
    if (start <= 0) {
        start = 0;
    }
    int num = end - start + 1;
    for (int i = start; i <= end; i++) {
        xSum += side[i];
        ySum += i;
        y2Sum += i * i;
        xySum += i * side[i];
    }
    if ((num * y2Sum - ySum * ySum) != 0) {

        double Slope = (double)(num * xySum - xSum * ySum) / (num * y2Sum - ySum * ySum);
        return Slope;
    }
    else {
        return 0;
    }
}

////////////////////////////////////////////
//功能：斜率计算
//输入：起点，终点，起点,终点所在数组
//输出：斜率
//备注：最小二乘法
///////////////////////////////////////////
double calculate_slope_struct(int start, int end, uint8_t j_mid[CAMERA_H],int type) {
    double ySum = 0;
    double y2Sum = 0;
    double xSum = 0;
    double xySum = 0;

    if (end >= NEAR_LINE) {
        end = NEAR_LINE;
    }
    if (start <= 1) {
        start = 1;
    }
    int num = end - start + 1;

    uint8_t side[CAMERA_H];

    if (type == LEFT) {
        for (int i = end; i >= start; i--) {
            side[i] = my_road[i].connected[j_mid[i]].left;
        }
    }
    else if (type == RIGHT) {
        for (int i = end; i >= start; i--) {
            side[i] = my_road[i].connected[j_mid[i]].right;
        }
    }

    for (int i = start; i <= end; i++) {
        xSum += side[i];
        ySum += i;
        y2Sum += i * i;
        xySum += i * side[i];
    }
    if ((num * y2Sum - ySum * ySum) != 0) {

        double Slope = (double)(num * xySum - xSum * ySum) / (num * y2Sum - ySum * ySum);
        return Slope;
    }
    else {
        return 0;
    }
}

////////////////////////////////////////////
//功能：斜率计算
//输入：起点，终点，起点,终点横坐标
//输出：斜率
//备注：两点式
///////////////////////////////////////////
double calculate_two_point_slope(int start, int xStart, int end, int xEnd) {

    double k = (double)(xStart - xEnd) / (start - end);
    return k;

}

////////////////////////////////////////////
//功能：方差
//输入：
//输出：
//备注：
///////////////////////////////////////////
double variance(int yStart, int yEnd, int side[CAMERA_H]) {

    int xSum = 0;
    int ySum = 0;
    int x[CAMERA_H];
    double xAverange = 0;
    double x2Delta = 0;
    double D;

    for (int i = yStart; i <= yEnd; i++) {
        xSum += side[i];
    }

    xAverange = (double)xSum / (yEnd - yStart + 1);

    for (int i = yStart; i < yEnd; i++) {
        x2Delta += (side[i] - xAverange) * (side[i] - xAverange);
    }

    D = x2Delta / (yEnd - yStart);
    return D;
}

////////////////////////////////////////////
//功能：相关系数
//输入：
//输出：
//备注：
///////////////////////////////////////////
double correlation_coefficient(int start, int end, int side[CAMERA_W]) {
    int xSum = 0;
    int ySum = 0;
    for (int i = start; i <= end; i++) {
        xSum += i;
        ySum += side[i];
    }
    double xAver = (double)xSum / (end - start + 1);
    double yAver = (double)ySum / (end - start + 1);

    double xy = 0;
    double x2 = 0;
    double y2 = 0;
    for (int i = start; i <= end; i++) {
        xy += (double)(i - xAver) * (side[i] - yAver);
        x2 += (double)(i - xAver) * (i - xAver);
        y2 += (double)(side[i] - yAver) * (side[i] - yAver);
    }
    if (x2 != 0 && y2 != 0) {
        double r = xy / (sqrt(x2) * sqrt(y2));
        return r;
    }
    else {
        return 2;
    }


}

////////////////////////////////////////////
//功能：余弦值
//输入：
//输出：
//备注：
///////////////////////////////////////////
double cos_angle(int x1, int x2, int x3, int y1, int y2, int y3) {

    ////////////////////////余弦函数计算
    double l1 = sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
    double l2 = sqrt((x2 - x3) * (x2 - x3) + (y2 - y3) * (y2 - y3));
    double l3 = sqrt((x1 - x3) * (x1 - x3) + (y1 - y3) * (y1 - y3));

    if (x3 > NEAR_LINE) {
        x3 = NEAR_LINE;
    }
    if (x1 <= 1) {
        x1 = 1;
    }
    double cosA;
    if (l1 != 0 && l2 != 0) {
        cosA = (double)(l1 * l1 + l2 * l2 - l3 * l3) / (2 * l1 * l2);
    }
    else {
        if (l1 * l1 + l2 * l2 - l3 * l3 > 0) {
            cosA = 2;
        }
        else {
            cosA = -2;
        }
    }


    return cosA;

    ////////////////////////
}

////////////////////////////////////////////
//功能：线性判断
//输入：
//输出：
//备注：
///////////////////////////////////////////
double linear_judgement(int start, int end, uint8_t side[CAMERA_H]) {

    //先拟合直线
    double k = calculate_slope_uint(start, end, side);

    int xSum = 0;
    int ySum = 0;
    for (int i = start; i <= end; i++) {
        xSum += side[i];
        ySum += i;
    }
    double xAve = (double)xSum / (end - start + 1);
    double yAve = (double)ySum / (end - start + 1);

    double b = xAve - k * yAve;
//    //////printf("k=%f,b=%f\n", k, b);
    int difference[CAMERA_H] = { 0 };
    int sumA = 0;
    for (int i = start; i <= end; i++) {
        difference[i] = ((int)side[i] - (int)(k * i + b));
        sumA += difference[i];
//        //////printf("dx:%d=%d-%d=%d,%d\n", i, side[i], (int)(k * i + b),difference[i],sumA);
    }
    double ave = (double)sumA / (end - start + 1);
//    //////printf("sum=%d,ave=%f\n",sumA, ave);
    double dv = 0;
    for (int i = start; i <= end; i++) {
        dv += (difference[i] - ave) * (difference[i] - ave);
    }
    return dv;

}


////////////////////////////////////////////
//功能：线性判断
//输入：
//输出：
//备注：
///////////////////////////////////////////
double linear_judgement_struct(int start, int end, uint8_t j[CAMERA_H],int direction) {

    uint8_t side[CAMERA_H];
    for (int i = start; i <= end; i++) {
        if (direction == LEFT)side[i] = my_road[i].connected[j[i]].left;
        else if (direction == RIGHT)side[i] = my_road[i].connected[j[i]].right;
    }


    //先拟合直线
    double k = calculate_slope_uint(start, end, side);

    int xSum = 0;
    int ySum = 0;
    for (int i = start; i <= end; i++) {
        xSum += side[i];
        ySum += i;
    }
    double xAve = (double)xSum / (end - start + 1);
    double yAve = (double)ySum / (end - start + 1);

    double b = xAve - k * yAve;
    //printf("k=%f,b=%f\n", k, b);
    int difference[CAMERA_H] = { 0 };
    int sumA = 0;
    for (int i = start; i <= end; i++) {
        difference[i] = ((int)side[i] - (int)(k * i + b));
        sumA += difference[i];
        //printf("dx:%d=%d-%d=%d,%d\n", i, side[i], (int)(k * i + b),difference[i],sumA);
    }
    double ave = (double)sumA / (end - start + 1);
    //printf("sum=%d,ave=%f\n",sumA, ave);
    double dv = 0;
    for (int i = start; i <= end; i++) {
        dv += (difference[i] - ave) * (difference[i] - ave);
    }
    return dv;

}


///////////////////////////////////////////
//功能：模拟CCD获取新的赛道数据
//输入：
//输出：
//备注：
///////////////////////////////////////////
void CCD() {
//    uint8_t* map;
//    map = fullBuffer;
//    uint8_t j_num = 1;
//    //再一次得到全新的二值化结果
//    my_road[35] = my_road[95];
//    for (int i = 34; i >= 0; i--) {
//        for (int j = 0; j < 188; j++) {
//            if(188 * transform_x[i + 60][j] < 30){
//                if (*(map + 188 * transform_x[i + 60][j] + transform_y[i + 60][j]) > thresholdUp *1.2) {
//                    IMG[i][j] = white;
//                }
//                else {
//                    IMG[i][j] = black;
//                }
//                if (j<left_side[i + 60] || j>right_side[i + 60]) {
//                    IMG[i][j] = black;
//                }
//            }
//            else {
//                if (*(map + 188 * transform_x[i + 60][j] + transform_y[i + 60][j]) > thresholdDown *1.2) {
//                    IMG[i][j] = white;
//                }
//                else {
//                    IMG[i][j] = black;
//                }
//                if (j<left_side[i + 60] || j>right_side[i + 60]) {
//                    IMG[i][j] = black;
//                }
//
//            }
//        //  ////printf("%d*%d:%d-%d\n", i + 25, j, IMG[i + 24][j], IMG_zebra[i][j]);
//        }
//        uint8_t* white_road = &IMG[i][0];
//        int flag = 0;
//        int start_white, end_white;
//        //这里寻找连通域，找到所有赛道
//        for (int j = left_side[i + 60]; j < right_side[i + 60]; j++) {
//            if (*(white_road + j) == white && *(white_road + j - 1) == black && flag == 0) {
//                start_white = j;
//                flag = 1;
//            }
//            if (*(white_road + j) == white && *(white_road + j + 1) == black && flag == 1) {
//                end_white = j;
//                for (int k = 1; k <= my_road[i + 1].white_num; k++) {
//                    if ((my_road[i + 1].connected[k].left <= start_white && start_white < my_road[i + 1].connected[k].right) || (my_road[i + 1].connected[k].left < end_white && end_white <= my_road[i + 1].connected[k].right)
//                        || (my_road[i + 1].connected[k].left >= start_white && end_white >= my_road[i + 1].connected[k].right) || (my_road[i + 1].connected[k].left <= start_white && end_white <= my_road[i + 1].connected[k].right)) {
//                        my_road[i].connected[j_num].left = start_white;
//                        my_road[i].connected[j_num].right = end_white;
//                        //IMG[i + 60][my_road[i].connected[j_num].left] = red, IMG[i  +60][my_road[i].connected[j_num].right] = blue;
//                        my_road[i].connected[j_num].width = end_white - start_white + 1;
//                        j_num++;
//                        flag = 0;
//                        break;
//                    }
//                }
//            }
//
//        }
//        my_road[i].white_num = j_num - 1;
//        j_num = 1;
//
//    }

}

////////////////////////////////////////////
//功能：进十字
//输入：
//输出：
//备注：
///////////////////////////////////////////
void cross_in() {
    leftUpJumpPoint = 119;
    leftDownJumpPoint = 119;
    rightUpJumpPoint = 119;
    rightDownJumpPoint = 119;

    //只有同时看到四个点我们才确定是十字

    //我们认为下方点到100行之前就必须识别上，不然就晚了

    //寻找正确的上方赛道

    int mid[CAMERA_H];
    for (int i = NEAR_LINE; i >= 100; i--) {
        mid[i] = (left_line[i] + right_line[i]) / 2;
    }

    double kMid = calculate_slope(100, NEAR_LINE - 1, mid);
    int direction;
    double kRange = 0.2;
    if (fabs(kMid) <= kRange) {
        direction = 0;
    }
    else if (kMid > kRange) {
        direction = LEFT;
    }
    else if (kMid < -1 * kRange) {
        direction = RIGHT;
    }

    for (int i = 99; i >= 1; i--) {
        mid[i] = kMid * (i - 100) + mid[100];
    //  IMG[i][mid[i]] = purple;
    }

    uint8_t j_mid[CAMERA_H];

    for (int i = NEAR_LINE; i >= 1; i--) {
        j_mid[i] = j_continue[i];
        for (int j = 1; j <= my_road[i].white_num; j++) {
            if (abs((my_road[i].connected[j].left + my_road[i].connected[j].right) / 2 - mid[i]) < abs((my_road[i].connected[j_mid[i]].left + my_road[i].connected[j_mid[i]].right) / 2 - mid[i])
                && my_road[i].connected[j].width > 10) {
                j_mid[i] = j;
            }
        }
         //////printf("%d:l=%d,r=%d\n", i, my_road[i].connected[j_mid[i]].left, my_road[i].connected[j_mid[i]].width);
    }
    uint8_t jumpLine = 119;
    for (int i = 113; i >= 30; i--) {
        if (my_road[i - 2].connected[j_mid[i - 2]].width - my_road[i].connected[j_mid[i]].width >= 4
            && abs(my_road[i + 1].connected[j_mid[i + 1]].width - my_road[i].connected[j_mid[i]].width) <= 3
            && my_road[i].connected[j_mid[i]].width <= 45
            && my_road[i].connected[j_mid[i]].right < right_side[i] - 2 && my_road[i].connected[j_mid[i]].left > left_side[i] + 2
            ) {
            jumpLine = i;
            break;
        }
    }
    //////printf("j=%d,d=%d\n", jumpLine, direction);
    //Q弯看不到底下的角针对Q弯写的三点十字，一定要和三叉区分开！！！！！

    int way = 1;
    int sumDR = 0;
    int sumDL = 0;
    if (way == 0) {
        for (int i = NEAR_LINE; i >= 102; i--) {
            if (right_line[i] >= right_side[i] - 3) {
                sumDR++;
            }
            if (left_line[i] <= left_side[i] + 3) {
                sumDL++;
            }
        }
    }

    //////printf("sr=%d,sl=%d", sumDR, sumDL);
    if (sumDR >= 10 && sumDL <= 2) {
        for (int i = NEAR_LINE; i >= 100; i--) {
            mid[i] = (left_line[i] + right_line[i]) / 2;
        }

        kMid = calculate_slope_uint(102, NEAR_LINE - 1, right_line);
        //////printf("km=%f\n", kMid);

        for (int i = NEAR_LINE - 3; i >= 10; i--) {
            mid[i] = kMid * (i - 110) + (left_line[110]+right_line[110]) / 2;
            if (mid[i] > right_side[i]) {
                mid[i] = right_side[i];
            }
            if (mid[i] < left_side[i]) {
                mid[i] = left_side[i];
            }
        }

        uint8_t j_mid[CAMERA_H];

        for (int i = NEAR_LINE; i >= 1; i--) {
            j_mid[i] = j_continue[i];
            for (int j = 1; j <= my_road[i].white_num; j++) {
                if (abs((my_road[i].connected[j].left + my_road[i].connected[j].right) / 2 - mid[i]) < abs((my_road[i].connected[j_mid[i]].left + my_road[i].connected[j_mid[i]].right) / 2 - mid[i])
                    && my_road[i].connected[j].width > 20) {
                    j_mid[i] = j;
                }
            }

        }

        int yMax = NEAR_LINE - 3;
        if (1) {
            int i = NEAR_LINE - 3;
            while (i >= 70 && my_road[i].connected[j_mid[i]].left > left_side[i] + 1
                && abs(my_road[i].connected[j_mid[i]].left - my_road[i + 1].connected[j_mid[i + 1]].left) <= 5
                ){
                if (my_road[i].connected[j_mid[i]].left >= my_road[yMax].connected[j_mid[yMax]].left - 1
                    && calculate_slope_struct(i - 18, i - 3, j_mid, LEFT) * calculate_slope_struct(i + 3, i + 18, j_mid, LEFT) <= 0) {
                    yMax = i;
                }
                i--;
            }
            leftDownJumpPoint = yMax;
        }
        if (leftDownJumpPoint <= 110 && leftDownJumpPoint >= 70) {
            int start = leftDownJumpPoint - 40;

            uint8_t jumpLineD = 119;
            for (int i = start; i <= jumpLine; i++) {
                if (my_road[i + 2].connected[j_mid[i + 2]].width - my_road[i].connected[j_mid[i]].width >= 5
                    && abs(my_road[i - 1].connected[j_mid[i - 1]].width - my_road[i].connected[j_mid[i]].width) <= 3
                    && my_road[i].connected[j_mid[i]].width < 40
                    && my_road[i].connected[j_mid[i]].right < right_side[i] - 2 && my_road[i].connected[j_mid[i]].left > left_side[i] + 2
                    ) {
                    jumpLineD = i;
                    break;
                }


            }

            leftUpJumpPoint = jumpLineD;
            int i = jumpLineD - 1;
            rightUpJumpPoint = i;
            while (i <= jumpLineD + 30 && my_road[i].connected[j_mid[i]].right <= right_side[i] - 5) {
                if (my_road[i].connected[j_mid[i]].right <= my_road[rightUpJumpPoint].connected[j_mid[rightUpJumpPoint]].right
                    && calculate_slope_struct(i - 18, i - 3, j_mid, RIGHT) * calculate_slope_struct(i + 3, i + 18, j_mid, RIGHT) <= 0
                    && abs(my_road[i].connected[j_mid[i]].right - my_road[i - 1].connected[j_mid[i - 1]].right) <= 5) {
                    rightUpJumpPoint = i;
                }

                i++;
            }


            if (jumpLineD - 1 < leftUpJumpPoint && jumpLineD - 1 < rightUpJumpPoint
                && leftUpJumpPoint <= jumpLine && rightUpJumpPoint <= jumpLine
                && leftDownJumpPoint - 5 > leftUpJumpPoint
                && leftDownJumpPoint - 5 > rightUpJumpPoint
                //右上的拐点不应该在左下拐点的左边,同理，左上拐点不应该在右下拐点的右边
                && my_road[rightUpJumpPoint].connected[j_mid[rightUpJumpPoint]].right > my_road[leftDownJumpPoint].connected[j_mid[leftDownJumpPoint]].left
                && my_road[leftUpJumpPoint].connected[j_mid[leftUpJumpPoint]].left > my_road[leftDownJumpPoint].connected[j_mid[leftDownJumpPoint]].left
                && my_road[leftUpJumpPoint + 7].connected[j_mid[leftUpJumpPoint + 7]].left < my_road[leftUpJumpPoint].connected[j_mid[leftUpJumpPoint]].left
                && my_road[rightUpJumpPoint + 7].connected[j_mid[rightUpJumpPoint + 7]].right > my_road[rightUpJumpPoint].connected[j_mid[rightUpJumpPoint]].right
                && my_road[leftDownJumpPoint - 7].connected[j_mid[leftDownJumpPoint - 7]].left < my_road[leftDownJumpPoint].connected[j_mid[leftDownJumpPoint]].left
                && my_road[rightDownJumpPoint - 7].connected[j_mid[rightDownJumpPoint - 7]].right > my_road[rightDownJumpPoint].connected[j_mid[rightDownJumpPoint]].right
                //&& fabs(calculate_slope_struct(leftUpJumpPoint - 16, leftUpJumpPoint - 1, j_mid, LEFT) - calculate_slope_struct(rightUpJumpPoint - 16, rightUpJumpPoint - 1, j_mid, RIGHT)) < 0.2
                ) {
                //这个时候我们已经找到了四个点，但这四个点不一定准

                //区别三叉
                double dk;
                double dk2;

                    //  ////printf("d=%d,ku=%f,kd=%f\n", direction, calculate_slope_struct(rightUpJumpPoint - 20 + 2, rightUpJumpPoint - 5 + 2, j_mid, RIGHT), calculate_slope_struct(leftDownJumpPoint + 5 - 2, leftDownJumpPoint + 20 - 2, j_mid, LEFT));
                dk = fabs(calculate_slope_struct(rightUpJumpPoint - 18, rightUpJumpPoint - 3, j_mid, RIGHT) - calculate_slope_struct(leftDownJumpPoint + 3, leftDownJumpPoint + 18, j_mid, LEFT));
                dk2= fabs(calculate_slope_struct(leftUpJumpPoint - 18, leftUpJumpPoint - 3, j_mid, LEFT) - calculate_slope_struct(leftDownJumpPoint + 3, leftDownJumpPoint + 18, j_mid, LEFT));




                if (dk < 0.2 && dk2 < 0.2) {
                    //区别环岛，T字路口

                    double kl1 = calculate_slope_struct(leftUpJumpPoint - 15, leftUpJumpPoint - 1, j_mid, LEFT);
                    double kl2 = calculate_slope_struct(leftUpJumpPoint + 1, leftDownJumpPoint - 1, j_mid, LEFT);
                    double kl3 = calculate_slope_struct(leftDownJumpPoint + 1, leftDownJumpPoint + 15, j_mid, LEFT);
                    double kr1 = calculate_slope_struct(rightUpJumpPoint - 15, rightUpJumpPoint - 1, j_mid, RIGHT);
                    double kr2 = calculate_slope_struct(rightUpJumpPoint + 1, leftDownJumpPoint - 1, j_mid, RIGHT);
                    double kr3 = calculate_slope_struct(rightDownJumpPoint + 1, leftDownJumpPoint + 15, j_mid, RIGHT);
                    //////printf("dk=%f\n", fabs(kl2 - kl3));
                    if (((fabs(kl1 - kl2) < 0.2 && fabs(kl1 - kl3) < 0.2 && fabs(kl2 - kl3) < 0.2) || (fabs(kr1 - kr2) < 0.2 && fabs(kr1 - kr3) < 0.2 && fabs(kr2 - kr3) < 0.2))) {

                    }
                    else {
                        state = stateCrossIn;
                    }

                }
            }


        }

    }
    else if (sumDR <= 2 && sumDL >= 10) {
        for (int i = NEAR_LINE; i >= 100; i--) {
            mid[i] = (left_line[i] + right_line[i]) / 2;
        }

        kMid = calculate_slope_uint(102, NEAR_LINE - 1, left_line);

        for (int i = NEAR_LINE - 3; i >= 10; i--) {
            mid[i] = kMid * (i - 110) + (left_line[110] + right_line[110]) / 2;

        }

        uint8_t j_mid[CAMERA_H];

        for (int i = NEAR_LINE; i >= 1; i--) {
            j_mid[i] = j_continue[i];
            for (int j = 1; j <= my_road[i].white_num; j++) {
                if (abs((my_road[i].connected[j].left + my_road[i].connected[j].right) / 2 - mid[i]) < abs((my_road[i].connected[j_mid[i]].left + my_road[i].connected[j_mid[i]].right) / 2 - mid[i])
                    && my_road[i].connected[j].width > 20) {
                    j_mid[i] = j;
                }
            }

        }
        int yMin = NEAR_LINE;
        if (1) {
            int i = NEAR_LINE - 3;
            while (i >= 70 && my_road[i].connected[j_mid[i]].right < right_side[i] - 1
                && abs(my_road[i].connected[j_mid[i]].right - my_road[i + 1].connected[j_mid[i + 1]].right) <= 5
                ) {
                if (my_road[i].connected[j_mid[i]].right <= my_road[yMin].connected[j_mid[yMin]].right + 1
                    && calculate_slope_struct(i - 18, i - 3, j_mid, RIGHT) * calculate_slope_struct(i + 3, i + 18, j_mid, RIGHT) <= 0) {
                    yMin = i;
                }
                i--;
            }
            rightDownJumpPoint = yMin;
        }
    if (rightDownJumpPoint <= 110 && rightDownJumpPoint >= 70) {
        int start = rightDownJumpPoint - 40;

        uint8_t jumpLineD = 119;
        for (int i = start; i <= jumpLine; i++) {
            if (my_road[i + 2].connected[j_mid[i + 2]].width - my_road[i].connected[j_mid[i]].width >= 5
                && abs(my_road[i - 1].connected[j_mid[i - 1]].width - my_road[i].connected[j_mid[i]].width) <= 3
                && my_road[i].connected[j_mid[i]].width < 40
                && my_road[i].connected[j_mid[i]].right < right_side[i] - 2 && my_road[i].connected[j_mid[i]].left > left_side[i] + 2
                ) {
                jumpLineD = i;
                break;
            }


        }
        rightUpJumpPoint = jumpLineD;
        int i = jumpLineD - 1;
        leftUpJumpPoint = i;
        while (i <= jumpLineD + 30 && my_road[i].connected[j_mid[i]].left >= left_side[i] + 5) {
            if (my_road[i].connected[j_mid[i]].left >= my_road[leftUpJumpPoint].connected[j_mid[leftUpJumpPoint]].left
                && calculate_slope_struct(i - 18, i - 3, j_mid, LEFT) * calculate_slope_struct(i + 3, i + 18, j_mid, LEFT) <= 0
                && abs(my_road[i].connected[j_mid[i - 1]].left-my_road[i - 1].connected[j_mid[i - 1]].left) <= 5) {
                leftUpJumpPoint = i;
            }

            i++;
        }


        if (jumpLineD - 1 < leftUpJumpPoint && jumpLineD - 1 < rightUpJumpPoint
            && leftUpJumpPoint <= jumpLine && rightUpJumpPoint <= jumpLine
            && rightDownJumpPoint - 5 > leftUpJumpPoint
            && rightDownJumpPoint - 5 > rightUpJumpPoint
            //右上的拐点不应该在左下拐点的左边,同理，左上拐点不应该在右下拐点的右边
            && my_road[rightUpJumpPoint].connected[j_mid[rightUpJumpPoint]].right < my_road[rightDownJumpPoint].connected[j_mid[rightDownJumpPoint]].right
            && my_road[leftUpJumpPoint].connected[j_mid[leftUpJumpPoint]].left < my_road[rightDownJumpPoint].connected[j_mid[rightDownJumpPoint]].right
            //&& fabs(calculate_slope_struct(leftUpJumpPoint - 16, leftUpJumpPoint - 1, j_mid, LEFT) - calculate_slope_struct(rightUpJumpPoint - 16, rightUpJumpPoint - 1, j_mid, RIGHT)) < 0.2
            ) {
            //这个时候我们已经找到了四个点，但这四个点不一定准

            //区别三叉
            double dk = 2;

            dk = fabs(calculate_slope_struct(rightUpJumpPoint - 18, rightUpJumpPoint - 3, j_mid, RIGHT) - calculate_slope_struct(rightDownJumpPoint + 3, rightDownJumpPoint + 18, j_mid, RIGHT));
            double dk2= fabs(calculate_slope_struct(leftUpJumpPoint - 18, leftUpJumpPoint - 3, j_mid, LEFT) - calculate_slope_struct(rightDownJumpPoint + 3, rightDownJumpPoint + 18, j_mid, RIGHT));




            if (dk < 0.2 && dk2 < 0.2) {
                //区别环岛，T字路口

                double kl1 = calculate_slope_struct(leftUpJumpPoint - 15, leftUpJumpPoint - 1, j_mid, LEFT);
                double kl2 = calculate_slope_struct(leftUpJumpPoint + 1, rightDownJumpPoint - 1, j_mid, LEFT);
                double kl3 = calculate_slope_struct(leftDownJumpPoint + 1, rightDownJumpPoint + 15, j_mid, LEFT);
                double kr1 = calculate_slope_struct(rightUpJumpPoint - 15, rightUpJumpPoint - 1, j_mid, RIGHT);
                double kr2 = calculate_slope_struct(rightUpJumpPoint + 1, rightDownJumpPoint - 1, j_mid, RIGHT);
                double kr3 = calculate_slope_struct(rightDownJumpPoint + 1, rightDownJumpPoint + 15, j_mid, RIGHT);
                //////printf("dk=%f\n", fabs(kl2 - kl3));
                if (((fabs(kl1 - kl2) < 0.2 && fabs(kl1 - kl3) < 0.2 && fabs(kl2 - kl3) < 0.2) || (fabs(kr1 - kr2) < 0.2 && fabs(kr1 - kr3) < 0.2 && fabs(kr2 - kr3) < 0.2))) {

                }
                else {
                    state = stateCrossIn;
                }

            }
        }


    }
    }
    else {
        //统一坐标
        if (60 < jumpLine && jumpLine <= NEAR_LINE - 1) {
            uint8_t jumpLineEnd = jumpLine + 15;
            if (jumpLineEnd >= NEAR_LINE) {
                jumpLineEnd = NEAR_LINE;
            }
            for (int i = jumpLine; i <= jumpLineEnd; i++) {
                mid[i] = (left_line[i] + right_line[i]) / 2;
            }

            double kMid = calculate_slope(jumpLine, jumpLineEnd, mid);
            if (fabs(kMid) <= kRange) {
                direction = 0;
            }
            else if (kMid > kRange) {
                direction = LEFT;
            }
            else if (kMid < -1 * kRange) {
                direction = RIGHT;
            }
            if (direction == 0) {
                if (my_road[jumpLine - 10].connected[j_mid[jumpLine - 10]].right + 1 >= my_road[jumpLine].connected[j_mid[jumpLine]].right
                    && my_road[jumpLine - 10].connected[j_mid[jumpLine - 10]].left - 1 <= my_road[jumpLine].connected[j_mid[jumpLine]].left) {
                    leftDownJumpPoint = jumpLine;
                    rightDownJumpPoint = jumpLine;
                }
            }
            else if (direction == LEFT) {
                leftDownJumpPoint = jumpLine;
                int i = jumpLine + 1;
                rightDownJumpPoint = i;
                while (i >= jumpLine - 30 && my_road[i].connected[j_mid[i]].right <= my_road[jumpLine].connected[j_mid[jumpLine]].right + 10) {
                    if (my_road[i].connected[j_mid[i]].right <= my_road[rightDownJumpPoint].connected[j_mid[rightDownJumpPoint]].right
                        && calculate_slope_struct(i - 18, i - 3, j_mid, RIGHT) * calculate_slope_struct(i + 3, i + 18, j_mid, RIGHT) <= 0) {
                        rightDownJumpPoint = i;
                    }

                    i--;
                }

            }
            else if (direction == RIGHT) {
                rightDownJumpPoint = jumpLine;
                int i = jumpLine + 1;
                leftDownJumpPoint = i;
                while (i >= jumpLine - 30 && my_road[i].connected[j_mid[i]].left >= my_road[jumpLine].connected[j_mid[jumpLine]].left - 10) {
                    if (my_road[i].connected[j_mid[i]].left >= my_road[leftDownJumpPoint].connected[j_mid[leftDownJumpPoint]].left
                        && calculate_slope_struct(i - 18, i - 3, j_mid, LEFT) * calculate_slope_struct(i + 3, i + 18, j_mid, LEFT) <= 0) {
                        leftDownJumpPoint = i;
                    }

                    i--;
                }
            }
//            ////printf("%d=%d,%d=%d\n", leftDownJumpPoint, my_road[leftDownJumpPoint].connected[j_mid[leftDownJumpPoint]].left, rightDownJumpPoint, my_road[rightDownJumpPoint].connected[j_mid[rightDownJumpPoint]].right);
            if (leftDownJumpPoint < jumpLine + 1 && rightDownJumpPoint < jumpLine + 1
                && fabs(calculate_slope_struct(leftDownJumpPoint + 1,leftDownJumpPoint + 16, j_mid, LEFT) - calculate_slope_struct(rightDownJumpPoint + 1, rightDownJumpPoint + 16, j_mid, RIGHT)) < 0.3
                && my_road[15].white_num != 0) {


                //矫正mid与direction
                for (int i = jumpLine; i >= 1; i--) {
                    mid[i] = kMid * (i - jumpLine) + mid[jumpLine];
                //  IMG[i][mid[i]] = purple;
                }
                for (int i = jumpLine; i >= 1; i--) {
                    j_mid[i] = j_continue[i];
                    for (int j = 1; j <= my_road[i].white_num; j++) {
                        if (abs((my_road[i].connected[j].left + my_road[i].connected[j].right) / 2 - mid[i]) < abs((my_road[i].connected[j_mid[i]].left + my_road[i].connected[j_mid[i]].right) / 2 - mid[i])
                            && my_road[i].connected[j].width > 10) {
                            j_mid[i] = j;
                        }
                    }
//                    ////printf("%d:l=%d,r=%d\n", i, my_road[i].connected[j_mid[i]].left, my_road[i].connected[j_mid[i]].width);
                }

                //这时候我们认为我们已经找到了下方两个突变点的坐标，
                //我们继续寻找上方两个坐标点

                int start = jumpLine - 50;

                if (my_road[start].connected[j_mid[start]].width >= 45
                    ) {
                    while (start <= jumpLine - 20 && my_road[start].connected[j_mid[start]].width >= 35) {
                        start++;
                    }
                }
                uint8_t jumpLineD = 119;
//                ////printf("start = %d\n", start);
                for (int i = start; i <= jumpLine; i++) {
                    if (my_road[i + 2].connected[j_mid[i + 2]].width - my_road[i].connected[j_mid[i]].width >= 6
                        && abs(my_road[i - 1].connected[j_mid[i - 1]].width - my_road[i].connected[j_mid[i]].width) <= 4
                        && my_road[i].connected[j_mid[i]].width < 40
                        && my_road[i].connected[j_mid[i]].right < right_side[i] - 2 && my_road[i].connected[j_mid[i]].left > left_side[i] + 2
                        ) {
                        jumpLineD = i;
                        break;
                    }


                }
//                ////printf("jd=%d\n", jumpLineD);
                if (direction == 0) {

                    if (my_road[jumpLineD + 5].connected[j_mid[jumpLineD + 5]].right + 1 >= my_road[jumpLine].connected[j_mid[jumpLine]].right
                        && my_road[jumpLineD + 5].connected[j_mid[jumpLineD + 5]].left - 1 <= my_road[jumpLine].connected[j_mid[jumpLine]].left) {
                        leftUpJumpPoint = jumpLineD;
                        rightUpJumpPoint = jumpLineD;
                    }


                }
                else if (direction == LEFT) {
                    rightUpJumpPoint = jumpLineD;
                    int i = jumpLineD - 1;
                    leftUpJumpPoint = i;
                    while (i <= jumpLineD + 30 && my_road[i].connected[j_mid[i]].left >= left_side[i] + 5) {
                        if (my_road[i].connected[j_mid[i]].left >= my_road[leftUpJumpPoint].connected[j_mid[leftUpJumpPoint]].left
                            && calculate_slope_struct(i - 18, i - 3, j_mid, LEFT) * calculate_slope_struct(i + 3, i + 18, j_mid, LEFT) <= 0) {
                            leftUpJumpPoint = i;
                        }

                        i++;
                    }

                }
                else if (direction == RIGHT) {
                    leftUpJumpPoint = jumpLineD;
                    int i = jumpLineD - 1;
                    rightUpJumpPoint = i;
                    while (i <= jumpLineD + 30 && my_road[i].connected[j_mid[i]].right <= right_side[i] - 5) {
                        if (my_road[i].connected[j_mid[i]].right <= my_road[rightUpJumpPoint].connected[j_mid[rightUpJumpPoint]].right
                            && calculate_slope_struct(i - 18, i - 3, j_mid, RIGHT) * calculate_slope_struct(i + 3, i + 18, j_mid, RIGHT) <= 0) {
                            rightUpJumpPoint = i;
                        }

                        i++;
                    }
                }
                //////printf("jD=%d\n", jumpLineD);
//                ////printf("lu:%d=%d,ru:%d=%d\n", leftUpJumpPoint, my_road[leftUpJumpPoint].connected[j_mid[leftUpJumpPoint]].left, rightUpJumpPoint, my_road[rightUpJumpPoint].connected[j_mid[rightUpJumpPoint]].right);
//                ////printf("ld:%d=%d,rd:%d=%d\n", leftDownJumpPoint, my_road[leftDownJumpPoint].connected[j_mid[leftDownJumpPoint]].left, rightDownJumpPoint, my_road[rightDownJumpPoint].connected[j_mid[rightDownJumpPoint]].right);
                if (jumpLineD - 1 < leftUpJumpPoint && jumpLineD - 1 < rightUpJumpPoint
                    && jumpLine-jumpLineD <= 65
                    && leftUpJumpPoint <= jumpLine && rightUpJumpPoint <= jumpLine
                    && leftDownJumpPoint  > leftUpJumpPoint - 7 && rightDownJumpPoint  > leftUpJumpPoint - 7
                    && leftDownJumpPoint  > rightUpJumpPoint - 7 && rightDownJumpPoint > rightUpJumpPoint - 7
                    //右上的拐点不应该在左下拐点的左边,同理，左上拐点不应该在右下拐点的右边
                    && my_road[rightUpJumpPoint].connected[j_mid[rightUpJumpPoint]].right >= my_road[leftDownJumpPoint].connected[j_mid[leftDownJumpPoint]].left - 7
                    && my_road[leftUpJumpPoint].connected[j_mid[leftUpJumpPoint]].left <= my_road[rightDownJumpPoint].connected[j_mid[rightDownJumpPoint]].right + 7
                    /*&& my_road[leftUpJumpPoint + 6].connected[j_mid[leftUpJumpPoint + 6]].left < my_road[leftUpJumpPoint].connected[j_mid[leftUpJumpPoint]].left
                    && my_road[rightUpJumpPoint + 6].connected[j_mid[rightUpJumpPoint + 6]].right > my_road[rightUpJumpPoint].connected[j_mid[rightUpJumpPoint]].right
                    && my_road[leftDownJumpPoint - 6].connected[j_mid[leftDownJumpPoint - 6]].left < my_road[leftDownJumpPoint].connected[j_mid[leftDownJumpPoint]].left
                    && my_road[rightDownJumpPoint - 6].connected[j_mid[rightDownJumpPoint - 6]].right > my_road[rightDownJumpPoint].connected[j_mid[rightDownJumpPoint]].right
                    */&& my_road[rightUpJumpPoint].connected[j_mid[rightUpJumpPoint]].right > my_road[leftUpJumpPoint].connected[j_mid[leftUpJumpPoint]].left
                    && my_road[rightDownJumpPoint].connected[j_mid[rightDownJumpPoint]].right > my_road[leftDownJumpPoint].connected[j_mid[leftDownJumpPoint]].left

                    //&& fabs(calculate_slope_struct(leftUpJumpPoint - 16, leftUpJumpPoint - 1, j_mid, LEFT) - calculate_slope_struct(rightUpJumpPoint - 16, rightUpJumpPoint - 1, j_mid, RIGHT)) < 0.2
                    ) {
                    //这个时候我们已经找到了四个点，但这四个点不一定准

                    //区别三叉
                    double dk;

                    if (direction == 0) {
                        // ////printf("d=%d,ku=%f,kd=%f\n", direction, calculate_slope_struct(leftUpJumpPoint - 20 + 2, leftUpJumpPoint - 5 + 2, j_mid, LEFT), calculate_slope_struct(leftDownJumpPoint + 5 - 2, leftDownJumpPoint + 20 - 2, j_mid, LEFT));
                        dk = fabs(calculate_slope_struct(leftUpJumpPoint - 18, leftUpJumpPoint - 3, j_mid, LEFT) - calculate_slope_struct(leftDownJumpPoint + 3, leftDownJumpPoint + 18, j_mid, LEFT));
                    }
                    else if (direction == LEFT) {
                        //////printf("d=%d,ku=%f,kd=%f\n", direction, calculate_slope_struct(leftUpJumpPoint - 20 + 2, leftUpJumpPoint - 5 + 2, j_mid, LEFT), calculate_slope_struct(rightDownJumpPoint + 5 - 2, rightDownJumpPoint + 20 - 2, j_mid, RIGHT));
                        dk = fabs(calculate_slope_struct(leftUpJumpPoint - 18, leftUpJumpPoint - 3, j_mid, LEFT) - calculate_slope_struct(rightDownJumpPoint + 3, rightDownJumpPoint + 18, j_mid, RIGHT));
                    }
                    else if (direction == RIGHT) {
                        //  ////printf("d=%d,ku=%f,kd=%f\n", direction, calculate_slope_struct(rightUpJumpPoint - 20 + 2, rightUpJumpPoint - 5 + 2, j_mid, RIGHT), calculate_slope_struct(leftDownJumpPoint + 5 - 2, leftDownJumpPoint + 20 - 2, j_mid, LEFT));
                        dk = fabs(calculate_slope_struct(rightUpJumpPoint - 18, rightUpJumpPoint - 3, j_mid, RIGHT) - calculate_slope_struct(leftDownJumpPoint + 3, leftDownJumpPoint + 18, j_mid, LEFT));
                    }


//                    ////printf("ld:%d=%d,rd:%d=%d,lu:%d=%d,ru:%d=%d\n", leftDownJumpPoint, my_road[leftDownJumpPoint].connected[j_mid[leftDownJumpPoint]].left, rightDownJumpPoint, my_road[rightDownJumpPoint].connected[j_mid[rightDownJumpPoint]].right, leftUpJumpPoint, my_road[leftUpJumpPoint].connected[j_mid[leftUpJumpPoint]].left, rightUpJumpPoint, my_road[rightUpJumpPoint].connected[j_mid[rightUpJumpPoint]].right);
                    if (dk < 0.3) {
                        //区别环岛，T字路口

                        /*double kl1 = calculate_slope_struct(leftUpJumpPoint - 15, leftUpJumpPoint - 1, j_mid, LEFT);
                        double kl2 = calculate_slope_struct(leftUpJumpPoint + 1, leftDownJumpPoint - 1, j_mid, LEFT);
                        double kl3 = calculate_slope_struct(leftDownJumpPoint + 1, leftDownJumpPoint + 15, j_mid, LEFT);
                        double kr1 = calculate_slope_struct(rightUpJumpPoint - 15, rightUpJumpPoint - 1, j_mid, RIGHT);
                        double kr2 = calculate_slope_struct(rightUpJumpPoint + 1, rightDownJumpPoint - 1, j_mid, RIGHT);
                        double kr3 = calculate_slope_struct(rightDownJumpPoint + 1, rightDownJumpPoint + 15, j_mid, RIGHT);*/
                        double kl1 = calculate_slope_struct(40, 55, j_mid, LEFT);
                        double kl2 = calculate_slope_struct(60, 75, j_mid, LEFT);
                        double kl3 = calculate_slope_struct(80, 95, j_mid, LEFT);
                        double kr1 = calculate_slope_struct(40, 55, j_mid, RIGHT);
                        double kr2 = calculate_slope_struct(60, 75, j_mid, RIGHT);
                        double kr3 = calculate_slope_struct(80, 95, j_mid, RIGHT);
                        uint8_t left_road[CAMERA_H];
                        uint8_t right_road[CAMERA_H];
                        for (int i = leftUpJumpPoint - 7; i <= leftDownJumpPoint + 7; i++) {
                            left_road[i] = my_road[i].connected[j_mid[i]].left;
                        }
                        for (int i = rightUpJumpPoint - 7; i <= rightDownJumpPoint + 7; i++) {
                            right_road[i] = my_road[i].connected[j_mid[i]].right;
                        }
                        //////printf("dvl=%f,dvr=%f\n", linear_judgement(leftUpJumpPoint-7,leftDownJumpPoint+7,left_road), linear_judgement(rightUpJumpPoint - 7, rightDownJumpPoint + 7, right_road));

                        //////printf("dk=%f\n", fabs(kl2 - kl3));
                        if (/*((fabs(kl1 - kl2) < 0.2 && fabs(kl1 - kl3) < 0.2 && fabs(kl2 - kl3) < 0.2) || (fabs(kr1 - kr2) < 0.2 && fabs(kr1 - kr3) < 0.2 && fabs(kr2 - kr3) < 0.2))*/
                            linear_judgement(leftUpJumpPoint - 7, leftDownJumpPoint + 7, left_road)< 100 ||  linear_judgement(rightUpJumpPoint - 7, rightDownJumpPoint + 7, right_road) < 100) {

                        }
                        else {
                            state = stateCrossIn;
                        }

                    }
                }

            }

        }



    }



}

////////////////////////////////////////////
//功能：进十字补线
//输入：
//输出：
//备注：
///////////////////////////////////////////
void design_cross_ing() {
    int mid[CAMERA_H];
    for (int i = NEAR_LINE; i >= 100; i--) {
        mid[i] = (left_line[i] + right_line[i]) / 2;
    }

    double kMid = calculate_slope(100, 113, mid);
    int direction;
    double kRange = 0.2;
    if (fabs(kMid) <= kRange) {
        direction = 0;
    }
    else if (kMid > kRange) {
        direction = LEFT;
    }
    else if (kMid < -1 * kRange) {
        direction = RIGHT;
    }

    for (int i = 99; i >= 1; i--) {
        mid[i] = kMid * (i - 100) + mid[100];
        if (mid[i] <= left_side[i]) {
            mid[i] = left_side[i];
        }
        if (mid[i] >= right_line[i]) {
            mid[i] = right_side[i];
        }
        //IMG[i][mid[i]] = purple;
    }



    uint8_t j_mid[CAMERA_H];

    for (int i = NEAR_LINE; i >= 1; i--) {
        j_mid[i] = j_continue[i];
        for (int j = 1; j <= my_road[i].white_num; j++) {
            if (abs((my_road[i].connected[j].left + my_road[i].connected[j].right) / 2 - mid[i]) < abs((my_road[i].connected[j_mid[i]].left + my_road[i].connected[j_mid[i]].right) / 2 - mid[i])
                && my_road[i].connected[j].width > 20) {
                j_mid[i] = j;
            }
        }

    }
    uint8_t jumpLine = 119;
    for (int i = 110; i >= 30; i--) {
        if (my_road[i - 2].connected[j_mid[i - 2]].width - my_road[i].connected[j_mid[i]].width >= 4
            && abs(my_road[i + 1].connected[j_mid[i + 1]].width - my_road[i].connected[j_mid[i]].width) <= 3
            && my_road[i].connected[j_mid[i]].width <= 45
            && my_road[i].connected[j_mid[i]].right < right_side[i] - 2 && my_road[i].connected[j_mid[i]].left > left_side[i] + 2
            ) {
            jumpLine = i;
            break;
        }
        if (my_road[i].connected[j_mid[i]].left == left_side[i] || my_road[i].connected[j_mid[i]].right == right_side[i]) {
            break;
        }
    }
    //////printf("jl=%d", jumpLine);
    if (60 < jumpLine && jumpLine <= 110) {

        for (int i = NEAR_LINE; i >= jumpLine + 1; i--) {
            mid[i] = (left_line[i] + right_line[i]) / 2;
        }
        if (jumpLine >= 105) {
            if (right_line[jumpLine - 4] > right_line[jumpLine] + 2 && abs(left_line[jumpLine - 4] - left_line[jumpLine]) <= 2 ) {
                kMid = calculate_slope_uint(jumpLine - 3, jumpLine + 10, left_line);
            }
            else if (abs(right_line[jumpLine - 4] - right_line[jumpLine]) <= 2 && left_line[jumpLine - 4] < left_line[jumpLine] - 2) {
                kMid = calculate_slope_uint(jumpLine - 3, jumpLine + 10, right_line);
            }
            else {
                kMid = calculate_slope(jumpLine , jumpLine + 15, mid);
            }
        }
        else {
            kMid = calculate_slope(jumpLine + 1, jumpLine + 15, mid);
        }


        if (fabs(kMid) <= kRange) {
            direction = 0;
        }
        else if (kMid > kRange) {
            direction = LEFT;
        }
        else if (kMid < -1 * kRange) {
            direction = RIGHT;
        }

        for (int i = jumpLine + 3; i >= 1; i--) {
            mid[i] = kMid * (i - jumpLine - 3) + mid[jumpLine + 3];
           // IMG[i][mid[i]] = gray;
        }
        for (int i = NEAR_LINE; i >= 1; i--) {
            j_mid[i] = j_continue[i];
            if (!(1 <= j_continue[i] && j_continue[i] <= my_road[i].white_num)) {
                j_mid[i] = 1;
            }
            for (int j = 1; j <= my_road[i].white_num; j++) {

                if (abs((my_road[i].connected[j].left + my_road[i].connected[j].right) / 2 - mid[i]) < abs((my_road[i].connected[j_mid[i]].left + my_road[i].connected[j_mid[i]].right) / 2 - mid[i])
                    && my_road[i].connected[j].width >= 10
                    ) {
                    j_mid[i] = j;

                }
            }
        //  ////printf("%d:l=%d,r=%d\n",i,my_road[i].connected[j_mid[i]].left,my_road[i].connected[j_mid[i]].right);
        }
//        for (int i = NEAR_LINE; i >= 1; i--) {
//            ////printf("%d:l=%d,r=%d\n", i, my_road[i].connected[j_mid[i]].left, my_road[i].connected[j_mid[i]].right);
//        }
        for (int i = 20; i <= NEAR_LINE; i++) {
            if (my_road[i].connected[j_mid[i]].left > my_road[i - 1].connected[j_mid[i - 1]].right
                && my_road[i].connected[j_mid[i]].left > my_road[i - 2].connected[j_mid[i - 2]].right
                && my_road[i].connected[j_mid[i]].left > my_road[i - 3].connected[j_mid[i - 3]].right
                && my_road[i].connected[j_mid[i]].left > my_road[i - 4].connected[j_mid[i - 4]].right
                && my_road[i].connected[j_mid[i]].left > my_road[i - 5].connected[j_mid[i - 5]].right
                && my_road[i].connected[j_mid[i]].left > my_road[i - 6].connected[j_mid[i - 6]].right
                && my_road[i - 1].connected[j_mid[i - 1]].left < my_road[i - 2].connected[j_mid[i - 2]].right
                && my_road[i - 1].connected[j_mid[i - 1]].left < my_road[i - 3].connected[j_mid[i - 3]].right
                && my_road[i - 1].connected[j_mid[i - 1]].left < my_road[i - 4].connected[j_mid[i - 4]].right
                && my_road[i - 1].connected[j_mid[i - 1]].left < my_road[i - 5].connected[j_mid[i - 5]].right
                && my_road[i - 1].connected[j_mid[i - 1]].left < my_road[i - 6].connected[j_mid[i - 6]].right
                && my_road[i - 2].connected[j_mid[i - 2]].left < my_road[i - 3].connected[j_mid[i - 3]].right
                && my_road[i - 2].connected[j_mid[i - 2]].left < my_road[i - 4].connected[j_mid[i - 4]].right
                && my_road[i - 2].connected[j_mid[i - 2]].left < my_road[i - 5].connected[j_mid[i - 5]].right
                && my_road[i - 2].connected[j_mid[i - 2]].left < my_road[i - 6].connected[j_mid[i - 6]].right
                && my_road[i - 3].connected[j_mid[i - 3]].left < my_road[i - 4].connected[j_mid[i - 4]].right
                && my_road[i - 3].connected[j_mid[i - 3]].left < my_road[i - 5].connected[j_mid[i - 5]].right
                && my_road[i - 3].connected[j_mid[i - 3]].left < my_road[i - 6].connected[j_mid[i - 6]].right
                && my_road[i - 4].connected[j_mid[i - 4]].left < my_road[i - 5].connected[j_mid[i - 5]].right
                && my_road[i - 4].connected[j_mid[i - 4]].left < my_road[i - 6].connected[j_mid[i - 6]].right
                && my_road[i - 5].connected[j_mid[i - 5]].left < my_road[i - 6].connected[j_mid[i - 6]].right
                && my_road[i].connected[j_mid[i]].width < my_road[i + 5].connected[j_mid[i + 5]].width - 20
                && my_road[i].connected[j_mid[i]].width < my_road[i + 6].connected[j_mid[i + 6]].width - 20
                && my_road[i].connected[j_mid[i]].width<32
                && j_mid[i] > 1
                ) {
                j_mid[i] -= 1;
                i--;
//                ////printf("-1\n");
            }
        }
        for (int i = 20; i <= NEAR_LINE; i++) {
            if (my_road[i].connected[j_mid[i]].right < my_road[i - 1].connected[j_mid[i - 1]].left
                && my_road[i].connected[j_mid[i]].right < my_road[i - 2].connected[j_mid[i - 2]].left
                && my_road[i].connected[j_mid[i]].right < my_road[i - 3].connected[j_mid[i - 3]].left
                && my_road[i].connected[j_mid[i]].right < my_road[i - 4].connected[j_mid[i - 4]].left
                && my_road[i].connected[j_mid[i]].right < my_road[i - 5].connected[j_mid[i - 5]].left
                && my_road[i].connected[j_mid[i]].right < my_road[i - 6].connected[j_mid[i - 6]].left
                && my_road[i - 1].connected[j_mid[i - 1]].right > my_road[i - 2].connected[j_mid[i - 2]].left
                && my_road[i - 1].connected[j_mid[i - 1]].right > my_road[i - 3].connected[j_mid[i - 3]].left
                && my_road[i - 1].connected[j_mid[i - 1]].right > my_road[i - 4].connected[j_mid[i - 4]].left
                && my_road[i - 1].connected[j_mid[i - 1]].right > my_road[i - 5].connected[j_mid[i - 5]].left
                && my_road[i - 1].connected[j_mid[i - 1]].right > my_road[i - 6].connected[j_mid[i - 6]].left
                && my_road[i - 2].connected[j_mid[i - 2]].right > my_road[i - 3].connected[j_mid[i - 3]].left
                && my_road[i - 2].connected[j_mid[i - 2]].right > my_road[i - 4].connected[j_mid[i - 4]].left
                && my_road[i - 2].connected[j_mid[i - 2]].right > my_road[i - 5].connected[j_mid[i - 5]].left
                && my_road[i - 2].connected[j_mid[i - 2]].right > my_road[i - 6].connected[j_mid[i - 6]].left
                && my_road[i - 3].connected[j_mid[i - 3]].right > my_road[i - 4].connected[j_mid[i - 4]].left
                && my_road[i - 3].connected[j_mid[i - 3]].right > my_road[i - 5].connected[j_mid[i - 5]].left
                && my_road[i - 3].connected[j_mid[i - 3]].right > my_road[i - 6].connected[j_mid[i - 6]].left
                && my_road[i - 4].connected[j_mid[i - 4]].right > my_road[i - 5].connected[j_mid[i - 5]].left
                && my_road[i - 5].connected[j_mid[i - 5]].right > my_road[i - 6].connected[j_mid[i - 6]].left
                && my_road[i - 6].connected[j_mid[i - 6]].right > my_road[i - 6].connected[j_mid[i - 6]].left
                //&& my_road[i].connected[j_mid[i]].width < my_road[i + 4].connected[j_mid[i + 4]].width - 20
                && my_road[i].connected[j_mid[i]].width < my_road[i + 5].connected[j_mid[i + 5]].width - 20
                && my_road[i].connected[j_mid[i]].width < my_road[i + 6].connected[j_mid[i + 6]].width - 20
                && my_road[i].connected[j_mid[i]].width < 32
                && j_mid[i] < my_road[i].white_num
                ) {
                j_mid[i] += 1;
                i--;
//                ////printf("1\n");
            }
        }

        for (int i = NEAR_LINE; i >= 1; i--) {
//            ////printf("%d:l=%d,r=%d\n", i, my_road[i].connected[j_mid[i]].left, my_road[i].connected[j_mid[i]].right);
        }

        if (direction == 0) {
            int dy = 10;
            if (1) {
                leftDownJumpPoint = jumpLine;
                rightDownJumpPoint = jumpLine;
            }
        }
        else if (direction == LEFT) {
            leftDownJumpPoint = jumpLine;
            int i = jumpLine + 5;
            if (jumpLine + 5 > NEAR_LINE) {
                i = NEAR_LINE;
            }
            rightDownJumpPoint = i;
            while (i >= jumpLine - 30 && my_road[i].connected[j_mid[i]].right <= right_side[i] - 3 && my_road[i].connected[j_mid[i]].right <= my_road[NEAR_LINE].connected[j_mid[NEAR_LINE]].right + 15) {
                if (my_road[i].connected[j_mid[i]].right <= my_road[rightDownJumpPoint].connected[j_mid[rightDownJumpPoint]].right + 1) {
                    rightDownJumpPoint = i;
                }

                i--;
            }

        }
        else if (direction == RIGHT) {
            rightDownJumpPoint = jumpLine;
            int i = jumpLine + 5;
            if (i >= NEAR_LINE) {
                i = NEAR_LINE;
            }
            leftDownJumpPoint = i;
            while (i >= jumpLine - 30 && my_road[i].connected[j_mid[i]].left >= left_side[i] + 5 && my_road[i].connected[j_mid[i]].left > my_road[NEAR_LINE].connected[j_mid[NEAR_LINE]].left - 15) {
                if (my_road[i].connected[j_mid[i]].left >= my_road[leftDownJumpPoint].connected[j_mid[leftDownJumpPoint]].left - 1) {
                    leftDownJumpPoint = i;
                }

                i--;
            }
        }
        //////printf("%d=%d,%d=%d\n", leftDownJumpPoint, my_road[leftDownJumpPoint].connected[j_mid[leftDownJumpPoint]].left, rightDownJumpPoint, my_road[rightDownJumpPoint].connected[j_mid[rightDownJumpPoint]].right);
        if (leftDownJumpPoint <= jumpLine + 1 && rightDownJumpPoint <= jumpLine + 1
            && my_road[jumpLine - 60].white_num != 0) {
            //这时候我们认为我们已经找到了下方两个突变点的坐标，
            //我们继续寻找上方两个坐标点

            int start = jumpLine - 45;

            if (my_road[start].connected[j_mid[start]].width >= 45
                ) {
                while (start <= jumpLine - 20 && my_road[start].connected[j_mid[start]].width >= 35) {
                    start++;
                }
            }
            uint8_t jumpLineD = 119;
            for (int i = start; i <= jumpLine; i++) {
                if (my_road[i + 2].connected[j_mid[i + 2]].width - my_road[i].connected[j_mid[i]].width >= 5
                    && abs(my_road[i - 1].connected[j_mid[i - 1]].width - my_road[i].connected[j_mid[i]].width) <= 3
                    && my_road[i].connected[j_mid[i]].width < 45
                    && my_road[i].connected[j_mid[i]].right < right_side[i] - 2 && my_road[i].connected[j_mid[i]].left > left_side[i] + 2
                    ) {
                    jumpLineD = i;
                    break;
                }


            }
            //////printf("jlD=%d\n", jumpLineD);
            if (direction == 0) {
                if (my_road[jumpLineD + 10].connected[j_mid[jumpLineD + 10]].right + 4 >= my_road[jumpLineD].connected[j_mid[jumpLineD]].right
                    && my_road[jumpLineD + 10].connected[j_mid[jumpLineD + 10]].left - 4 <= my_road[jumpLineD].connected[j_mid[jumpLineD]].left) {
                    leftUpJumpPoint = jumpLineD;
                    rightUpJumpPoint = jumpLineD;
                }
            }
            else if (direction == LEFT) {
                rightUpJumpPoint = jumpLineD;
                int i = jumpLineD;
                leftUpJumpPoint = i;
                while (i <= jumpLineD + 30 && my_road[i].connected[j_mid[i]].left >= left_side[i] + 5
                    && my_road[i].connected[j_mid[i]].left >= my_road[jumpLineD].connected[j_mid[jumpLineD]].left - 10) {
                    if (my_road[i].connected[j_mid[i]].left >= my_road[leftUpJumpPoint].connected[j_mid[leftUpJumpPoint]].left ) {
                        leftUpJumpPoint = i;
                    }

                    i++;
                }

            }
            else if (direction == RIGHT) {
                leftUpJumpPoint = jumpLineD;
                int i = jumpLineD;
                rightUpJumpPoint = i;
                while (i <= jumpLineD + 30 && my_road[i].connected[j_mid[i]].right <= right_side[i] - 5
                    && my_road[i].connected[j_mid[i]].right <= my_road[jumpLineD].connected[j_mid[jumpLineD]].right + 15
                    ) {
                    if (my_road[i].connected[j_mid[i]].right <= my_road[rightUpJumpPoint].connected[j_mid[rightUpJumpPoint]].right  ) {
                        rightUpJumpPoint = i;
                    }

                    i++;
                }
            }
            //////printf("ru=%d\n", rightUpJumpPoint);
            //////printf("%d:l=%d,r=%d", rightUpJumpPoint, my_road[rightUpJumpPoint].connected[j_mid[rightUpJumpPoint]].left, my_road[rightUpJumpPoint].connected[j_mid[rightUpJumpPoint]].right);


            if (jumpLineD - 5 <= leftUpJumpPoint && jumpLineD - 5 <= rightUpJumpPoint
                && leftUpJumpPoint <= jumpLine && rightUpJumpPoint <= jumpLine) {

                for (int i = NEAR_LINE; i >= 1; i--) {
                    left_line[i] = my_road[i].connected[j_mid[i]].left;
                    right_line[i] = my_road[i].connected[j_mid[i]].right;
                    double kl = calculate_two_point_slope(leftUpJumpPoint, my_road[leftUpJumpPoint].connected[j_mid[leftUpJumpPoint]].left, leftDownJumpPoint, my_road[leftDownJumpPoint].connected[j_mid[leftDownJumpPoint]].left);
                    if (leftUpJumpPoint <= i && i <= leftDownJumpPoint) {
                        left_line[i] = kl * (i - leftDownJumpPoint) + my_road[leftDownJumpPoint].connected[j_mid[leftDownJumpPoint]].left;
                    }
                    double kr = calculate_two_point_slope(rightUpJumpPoint, my_road[rightUpJumpPoint].connected[j_mid[rightUpJumpPoint]].right, rightDownJumpPoint, my_road[rightDownJumpPoint].connected[j_mid[rightDownJumpPoint]].right);
                    if (rightUpJumpPoint <= i && i <= rightDownJumpPoint) {
                        right_line[i] = kr * (i - rightDownJumpPoint) + my_road[rightDownJumpPoint].connected[j_mid[rightDownJumpPoint]].right;
                    }
                    // ////printf("%d:w=%d\n", i, right_line[i] - left_line[i]);
                }

            }


        }
    }
    else if (jumpLine == 119 || jumpLine <= 60 || jumpLine > 106) {

        //并不成功的想法  //根据上一张图的中线来确定新图的中线大致范围

        //确定中线，寻找上突变点
        //根据底端白条，计算依赖阈值需要看的比较全
        int sumL = 0, sumR = 0;
        int FIRSTL = 119, FIRSTR = 119;
        int endL = 119, endR = 119;
        int numL = 0, numR = 0;
        for (int i = NEAR_LINE; i >= 60; i--) {
            if (i >= 103) {
                if (left_line[i] <= left_side[i] + 1) {
                    sumL++;
                    if (FIRSTL == 119) {
                        FIRSTL = i;
                    }
                }

                if (right_line[i] >= right_side[i] - 1) {
                    sumR++;
                    if (FIRSTR == 119) {
                        FIRSTR = i;
                    }
                }
            }
            if (left_line[i] > left_side[i] + 1 && left_line[i + 1] <= left_side[i + 1] + 1 && left_line[i + 2] <= left_side[i + 2] + 1
                && endL == 119 && FIRSTL != 119) {
                endL = i;
            }

            if (right_line[i] < right_side[i] - 1 && right_line[i + 1] <= right_side[i + 1] - 1 && right_line[i + 2] <= right_side[i + 2] - 1
                && endR == 119 && FIRSTR != 119) {
                endR = i;
            }
            if (i == 60) {
                if (endR == 119) {
                    endR = 60;
                }
                if (endL == 119) {
                    endL = 60;
                }
            }


        }
        //////printf("L:fl=%d,el=%d\nR:fr=%d,er=%d\n", FIRSTL, endL, FIRSTR, endR);

        /*if ((FIRSTL >= 106 && FIRSTL <= NEAR_LINE)  && (FIRSTR <= 106 || FIRSTR > NEAR_LINE)) {
            direction = LEFT;
        }
        else if ((FIRSTR >= 106 && FIRSTR <= NEAR_LINE) && (FIRSTL <= 106 || FIRSTL > NEAR_LINE)) {
            direction = RIGHT;
        }
        else {
            if ((FIRSTL >= 106 && FIRSTL <= NEAR_LINE) && (FIRSTR > 106 && FIRSTR <= NEAR_LINE)
                && endL < endR - 5) {
                direction = LEFT;
            }
            else if ((FIRSTL >= 106 && FIRSTL <= NEAR_LINE) && (FIRSTR > 106 && FIRSTR <= NEAR_LINE)
                && endR < endL - 5) {
                direction = RIGHT;
            }
            else {
                direction = 0;
            }
        }*/
        if (FIRSTL > FIRSTR && FIRSTL <= NEAR_LINE && FIRSTR <= NEAR_LINE) {
            direction = LEFT;
        }
        else if (FIRSTL < FIRSTR && FIRSTL <= NEAR_LINE && FIRSTR <= NEAR_LINE) {
            direction = RIGHT;
        }
        else {
            if (endL < endR - 5) {
                direction =RIGHT;
            }
            else if (endR < endL - 5) {
                direction = LEFT;
            }
            else {
                direction = 0;
            }
        }
        /*if (sumL >= sumR + 3) {
            direction = LEFT;
        }
        else if (sumL + 3 <= sumR) {
            direction = RIGHT;
        }
        else {
            direction = 0;
        }*/
        j_mid[NEAR_LINE] = j_continue[NEAR_LINE];
        if (direction == 0) {
            for (int i = NEAR_LINE - 1; i >= 1; i--) {
                j_mid[i] = j_continue[i];
                for (int j = 1; j <= my_road[i].white_num; j++) {
                    if (abs((my_road[i].connected[j].left + my_road[i].connected[j].right) / 2 - 92) <= abs((my_road[i].connected[j_mid[i]].left + my_road[i].connected[j_mid[i + 1]].right) / 2 - 92)
                        && my_road[i].connected[j].width > 15) {
                        j_mid[i] = j;
                    }
                }
            }
        }
        else if (direction == LEFT) {
            for (int i = NEAR_LINE - 1; i >= 2; i--) {
                j_mid[i] = j_continue[i];
                for (int j = 1; j <= my_road[i].white_num; j++) {
                    if (abs(my_road[i].connected[j].left - my_road[i + 1].connected[j_mid[i + 1]].left) < abs(my_road[i].connected[j_mid[i]].left - my_road[i + 1].connected[j_mid[i + 1]].left)
                        && my_road[i].connected[j].width > 15) {
                        j_mid[i] = j;

                    }

                }
            }
        }
        else if (direction == RIGHT) {
            for (int i = NEAR_LINE - 1; i >= 2; i--) {
                j_mid[i] = j_continue[i];
                for (int j = 1; j <= my_road[i].white_num; j++) {
                    if (abs(my_road[i].connected[j].right - my_road[i + 1].connected[j_mid[i + 1]].right) < abs(my_road[i].connected[j_mid[i]].right - my_road[i + 1].connected[j_mid[i + 1]].right)
                        && my_road[i].connected[j].width > 15) {
                        j_mid[i] = j;

                    }

                }
            }
        }



        int start = 110;
        if (my_road[start].connected[j_mid[start]].width >= 35
            ) {
            while (start <= 110 && my_road[start].connected[j_mid[start]].width >= 35) {
                start++;
            }
        }

        uint8_t jumpLineD = 119;
        for (int i = start; i >= 60; i--) {
            if (my_road[i + 2].connected[j_mid[i + 2]].width - my_road[i].connected[j_mid[i]].width >= 5
                && abs(my_road[i - 1].connected[j_mid[i - 1]].width - my_road[i].connected[j_mid[i]].width) <= 3
                && my_road[i].connected[j_mid[i]].width < 35
                && my_road[i].connected[j_mid[i]].right < right_side[i] - 2 && my_road[i].connected[j_mid[i]].left > left_side[i] + 2
                ) {
                jumpLineD = i;
                break;
            }


        }
        for (int i = jumpLineD - 1; i >= jumpLineD - 20; i--) {
            mid[i] = (my_road[i].connected[j_mid[i]].right + my_road[i].connected[j_mid[i]].left) / 2;
        }
        kMid = calculate_slope(jumpLineD - 15, jumpLineD - 3, mid);
        kRange = 0.2;

        if (fabs(kMid) <= kRange) {
            direction = 0;
        }
        else if (kMid > kRange) {
            direction = LEFT;
        }
        else if (kMid < -1 * kRange) {
            direction = RIGHT;
        }

        if (direction == 0) {
            if (1) {
                leftUpJumpPoint = jumpLineD;
                rightUpJumpPoint = jumpLineD;
            }
        }
        else if (direction == LEFT) {
            rightUpJumpPoint = jumpLineD;
            int i = jumpLineD;
            leftUpJumpPoint = i;
            while (i <= jumpLineD + 30 && my_road[i].connected[j_mid[i]].left >= left_side[i] + 5) {
                if (my_road[i].connected[j_mid[i]].left >= my_road[leftUpJumpPoint].connected[j_mid[leftUpJumpPoint]].left) {
                    leftUpJumpPoint = i;
                }

                i++;
            }

        }
        else if (direction == RIGHT) {
            leftUpJumpPoint = jumpLineD;
            int i = jumpLineD;
            rightUpJumpPoint = i;
            while (i <= jumpLineD + 30 && my_road[i].connected[j_mid[i]].right <= right_side[i] - 5) {
                if (my_road[i].connected[j_mid[i]].right <= my_road[rightUpJumpPoint].connected[j_mid[rightUpJumpPoint]].right) {
                    rightUpJumpPoint = i;
                }

                i++;
            }
        }

        for (int i = NEAR_LINE; i >= 1; i--) {
            left_line[i] = my_road[i].connected[j_mid[i]].left;
            right_line[i] = my_road[i].connected[j_mid[i]].right;
            double kl = calculate_slope_struct(leftUpJumpPoint - 20, leftUpJumpPoint - 5, j_mid, LEFT);
            if (leftUpJumpPoint <= i) {
                left_line[i] = kl * (i - leftUpJumpPoint) + my_road[leftUpJumpPoint].connected[j_mid[leftUpJumpPoint]].left;
            }
            double kr = calculate_slope_struct(rightUpJumpPoint - 20, rightUpJumpPoint - 5, j_mid, RIGHT);
            if (rightUpJumpPoint <= i) {
                right_line[i] = kr * (i - rightUpJumpPoint) + my_road[rightUpJumpPoint].connected[j_mid[rightUpJumpPoint]].right;
            }
            // ////printf("1\n");
        }


    }
}

////////////////////////////////////////////
//功能：出十字
//输入：
//输出：
//备注：
///////////////////////////////////////////
void cross_over() {

    int sumD = 0;
    for (int i = NEAR_LINE - 2; i >= 103; i--) {
        if (right_line[i] - left_line[i] >= 32) {
            sumD++;
        }
    }

    double kl = calculate_slope_uint(85, 100, left_line);
    double kr = calculate_slope_uint(85, 100, right_line);

    int sumU = 0;
    for (int i = 90; i <= 105; i++) {
        if (right_line[i] - left_line[i] < 35) {
            sumU++;
        }
    }

    if (sumD >=2 && sumD <= 7 && sumU >= 5 && right_line[NEAR_LINE - 1] - left_line[NEAR_LINE - 1] > 30) {
        if (fabs(kl - kr) < 0.2) {
            if (1) {
                state = stateStart;
            }
        }
    }

    if (my_road[55].white_num == 0) {
        state = stateStart;
    }

}


////////////////////////////////////////////
//功能：进T字路口或者环岛
//输入：
//输出：
//备注：
///////////////////////////////////////////
void T_island_in_start() {
    int flag = 0;
    for (int i = 112; i > 40; i--) {
        if (right_line[i - 1] - right_line[i] > 4 && right_line[i - 2] - right_line[i] > 4
            && left_line[i - 1] - left_line[i] <= 2 && left_line[i - 2] - left_line[i] <= 2) {
            TIslandWhere = RIGHT;
            break;
        }
        if (left_line[i - 1] - left_line[i] < -4 && left_line[i - 2] - left_line[i] < -4
            && right_line[i - 1] - right_line[i] <= 2 && right_line[i - 2] - right_line[i] <= 2) {
            TIslandWhere = LEFT;
            break;
        }
    }
    //////printf("TIslandWhere=%d\n", TIslandWhere);
    if (TIslandWhere == RIGHT) {
        //左侧是直道
        uint8_t left_road[CAMERA_H];
        uint8_t j_mid[CAMERA_H];
        for (int i = NEAR_LINE; i >= 2; i--) {
            j_mid[i] = j_continue[i];
            for (int j = 1; j <= my_road[i].white_num; j++) {
                if (abs(my_road[i].connected[j].left - my_road[i + 1].connected[j_mid[i + 1]].left) < abs(my_road[i].connected[j_mid[i]].left - my_road[i + 1].connected[j_mid[i + 1]].left)
                    && my_road[i].connected[j].width > 15) {
                    j_mid[i] = j;

                }

            }
            left_road[i] = my_road[i].connected[j_mid[i]].left;
            if(70<=i&&i<=90) {
            //  ////printf("lr:%d=%d\n", i, left_road[i]);
            }

        }
    //  ////printf("dv=%f\n", linear_judgement(70, 90, left_road));
        int downPoint = 119;
        if (calculate_slope_struct(80, 95, j_mid, LEFT) <= 0) {
            for (int i = NEAR_LINE - 1; i >= 30; i--) {
                if (my_road[i - 1].connected[j_mid[i - 1]].right - my_road[i].connected[j_mid[i]].right > 4
                    && abs(my_road[i + 1].connected[j_mid[i + 1]].right - my_road[i].connected[j_mid[i]].right) <= 2
                    && my_road[i].connected[j_mid[i]].width < 40
                    && my_road[i + 1].connected[j_mid[i + 1]].width < 40
                    ) {
                    downPoint = i;
                    break;
                }
            }

        }
        else {
            int num = 110;
            downPoint = num;
            while (num >= 40 && my_road[num].connected[j_mid[num]].right <= right_side[num] - 1
                && abs(my_road[num - 1].connected[j_mid[num - 1]].right - my_road[num].connected[j_mid[num]].right) <= 4
                && abs(my_road[num + 1].connected[j_mid[num + 1]].right - my_road[num].connected[j_mid[num]].right) <= 4
                ) {
                if (my_road[num].connected[j_mid[num]].right <= my_road[downPoint].connected[j_mid[downPoint]].right + 1

                    ) {
                    downPoint = num;
                }

                num--;
            }
        }

        //由于T路的特征，不一定都是直线，另一边绝对不能是边界，不然与十字说不清
        double kl1;
        double kl2;
        double kl3;
        if (downPoint >= 105) {
            kl1 = calculate_slope_struct(50, 65, j_mid, LEFT);
            kl2 = calculate_slope_struct(70, 85, j_mid, LEFT);
            kl3 = calculate_slope_struct(90, 105, j_mid, LEFT);
        }
        else {
            kl1 = calculate_slope_struct(40, 55, j_mid, LEFT);
            kl2 = calculate_slope_struct(60, 80, j_mid, LEFT);
            kl3 = calculate_slope_struct(85, 100, j_mid, LEFT);
        }
        //double kl4 = calculate_slope_struct(85, 100, j_mid, LEFT);
        int sumL = 0;
        int sumD = 0;
        for (int i = 30; i <= 110; i++) {
            if (my_road[i].connected[j_mid[i]].left <= left_side[i] + 3) {
                sumL++;
            }
        }
        for (int i = NEAR_LINE; i >= 105; i--) {
            if (my_road[i].connected[j_mid[i]].right >= right_side[i]) {
                sumD++;
            }
        }
        int Break = 0;
        for (int i = 50; i <= 100; i++) {
            if (abs(my_road[i].connected[j_mid[i]].left - my_road[i + 2].connected[j_mid[i + 2]].left) >= 5) {
                Break = 1;
            }
        }
        if (fabs(kl1 - kl2) < 0.2 && fabs(kl1 - kl3) < 0.2  && fabs(kl2 - kl3) < 0.2
            && sumL <= 10 && Break == 0) {


            if (fabs(calculate_slope_struct(downPoint - 7, downPoint + 7, j_mid, LEFT) - calculate_slope_struct(downPoint + 1, downPoint + 15, j_mid, RIGHT)) < 0.2
                && downPoint <= 110 && 75 <= downPoint ) {
                //寻找上方窄道
                int upPoint = 119;
                double kr = calculate_slope_struct(downPoint + 1, downPoint + 15, j_mid, RIGHT);
                int rightRoad[CAMERA_H];
                rightRoad[downPoint + 1] = my_road[downPoint + 1].connected[j_mid[downPoint + 1]].right + 10;
                int rightside[CAMERA_W];

                for (int i = downPoint; i >= 2; i--) {
                    rightRoad[i] = kr * (i - downPoint) + my_road[downPoint].connected[j_mid[downPoint]].right + 10;
                    if (rightRoad[i] > right_side[i]) {
                        rightRoad[i] = right_side[i];
                    }
                    //    IMG[i][rightRoad[i]] = purple;
                    if ((my_road[i + 1].connected[j_mid[i + 1]].right >= rightRoad[i + 1] && my_road[i].connected[j_mid[i]].right < rightRoad[i])
                        || (my_road[i + 1].connected[j_mid[i + 1]].right > rightRoad[i + 1] && my_road[i].connected[j_mid[i]].right <= rightRoad[i])) {
                        upPoint = i;
                        break;
                    }

                }

                //////printf("u=%d,d=%d\n", upPoint, downPoint);
                if (upPoint < downPoint - 10) {
                    int sumU = 0;
                    for (int i = upPoint; i >= upPoint - 30; i--) {
                        if (my_road[i].connected[j_mid[i]].width < my_road[downPoint + 2].connected[j_mid[downPoint + 2]].width + 10) {
                            sumU++;
                        }

                    }

                    if (sumU > 5) {
                        state = stateTIslandIn;
                    }
                    else {
                        TIslandWhere = 0;
                    }
                }


            }
        }



    }
    else if (TIslandWhere == LEFT) {
        uint8_t j_mid[CAMERA_H];
        uint8_t left_road[CAMERA_H];
        for (int i = NEAR_LINE; i >= 2; i--) {
            j_mid[i] = j_continue[i];
            for (int j = 1; j <= my_road[i].white_num; j++) {
                if (abs(my_road[i].connected[j].right - my_road[i + 1].connected[j_mid[i + 1]].right) < abs(my_road[i].connected[j_mid[i]].right - my_road[i + 1].connected[j_mid[i + 1]].right)
                    && my_road[i].connected[j].width > 15) {
                    j_mid[i] = j;

                }

            }
            left_road[i] = my_road[i].connected[j_mid[i]].right;

        }
        //////printf("dv=%f\n", linear_judgement(70, 90, left_road));
        int downPoint = 119;
        if (calculate_slope_struct(80, 95, j_mid, RIGHT) >= 0) {
            for (int i = NEAR_LINE - 1; i >= 30; i--) {
                if (my_road[i - 1].connected[j_mid[i - 1]].left - my_road[i].connected[j_mid[i]].left < -4
                    && abs(my_road[i + 1].connected[j_mid[i + 1]].left - my_road[i].connected[j_mid[i]].left) <= 2
                    && my_road[i].connected[j_mid[i]].width < 40
                    && my_road[i + 1].connected[j_mid[i + 1]].width < 40
                    ) {
                    downPoint = i;
                    break;
                }
            }

        }
        else {

            int num = 110;
            downPoint = num;
            while (num >= 40 && my_road[num].connected[j_mid[num]].left >= left_side[num] + 1
                && abs(my_road[num - 1].connected[j_mid[num - 1]].left - my_road[num].connected[j_mid[num]].left) <= 4
                && abs(my_road[num + 1].connected[j_mid[num + 1]].left - my_road[num].connected[j_mid[num]].left) <= 4
                ) {
                if (my_road[num].connected[j_mid[num]].left >= my_road[downPoint].connected[j_mid[downPoint]].left - 1

                    ) {
                    downPoint = num;
                }

                num--;
            }
        }
        double kl1;
        double kl2;
        double kl3;
        if(downPoint >= 105){
            kl1 = calculate_slope_struct(50, 65, j_mid, RIGHT);
            kl2 = calculate_slope_struct(70, 85, j_mid, RIGHT);
            kl3 = calculate_slope_struct(90, 105, j_mid, RIGHT);
        }
        else {
            kl1 = calculate_slope_struct(40, 55, j_mid, RIGHT);
            kl2 = calculate_slope_struct(60, 80, j_mid, RIGHT);
            kl3 = calculate_slope_struct(85, 100, j_mid, RIGHT);
        }

        //double kl4 = calculate_slope_struct(95, 110, j_mid, RIGHT);
        int sumR = 0;
        int sumD = 0;
        int Break = 0;
        for (int i = 50; i <= 100; i++) {
            if (abs(my_road[i].connected[j_mid[i]].right - my_road[i + 2].connected[j_mid[i + 2]].right) >= 5) {
                Break = 1;
            }
        }


        for (int i = 30; i <= 110; i++) {
            if (my_road[i].connected[j_mid[i]].right >= right_side[i] - 3) {
                sumR++;
            }
        }
        for (int i = NEAR_LINE; i >= 105; i--) {
            if (my_road[i].connected[j_mid[i]].left <= left_side[i]) {
                sumD++;
            }
        }
        if (fabs(kl1 - kl2) < 0.2 && fabs(kl1 - kl3) < 0.2  && fabs(kl2 - kl3) < 0.2
            && sumR <= 10 && sumD <= 5 && Break == 0) {


            //////printf("dp=%d", downPoint);
            //下方是直道，控制一下
            if (fabs(calculate_slope_struct(downPoint -7, downPoint + 7, j_mid, RIGHT) - calculate_slope_struct(downPoint + 1, downPoint + 15, j_mid, LEFT)) < 0.2
                && downPoint <= 110 && 70 <= downPoint) {
                //寻找上方圆环
                int upPoint = 119;
                double kl = calculate_slope_struct(downPoint + 1, downPoint + 15, j_mid, LEFT);
                int leftRoad[CAMERA_H];
                leftRoad[downPoint + 1] = my_road[downPoint + 1].connected[j_mid[downPoint + 1]].left - 10;
                for (int i = downPoint; i >= downPoint - 50; i--) {

                    leftRoad[i] = kl * (i - downPoint) + my_road[downPoint].connected[j_mid[downPoint]].left - 10;
                    if (leftRoad[i] < left_side[i]) {
                        leftRoad[i] = left_side[i];
                    }
                    //   IMG[i][leftRoad[i]] = purple;
                    if ((my_road[i + 1].connected[j_mid[i + 1]].left <= leftRoad[i + 1] && my_road[i].connected[j_mid[i]].left > leftRoad[i])
                        || (my_road[i + 1].connected[j_mid[i + 1]].left < leftRoad[i + 1] && my_road[i].connected[j_mid[i]].left >= leftRoad[i])) {
                        upPoint = i;
                        break;
                    }
                }
                //////printf("u=%d,d=%d\n", upPoint, downPoint);
                //根据找到的点，确定周围环岛点
                if (upPoint < downPoint - 10) {
                    int sumU = 0;
                    for (int i = upPoint; i >= upPoint - 30; i--) {
                        if (my_road[i].connected[j_mid[i]].width < my_road[downPoint + 2].connected[j_mid[downPoint + 2]].width + 10) {
                            sumU++;
                        }

                    }
                    //////printf("d=%d,u=%d\n", downPoint, upPoint);
                    if (sumU > 5) {
                        state = stateTIslandIn;
                    }
                    else {
                        TIslandWhere = 0;
                    }
                }

            }
        }
    }
}

////////////////////////////////////////////
//功能：环岛大小的判断
//输入：
//输出：
//备注：
///////////////////////////////////////////
void island_radius() {
    if (TIslandWhere == RIGHT) {
        int rightRoad[CAMERA_H];
        uint8_t j_mid[CAMERA_H];
        for (int i = NEAR_LINE; i >= 2; i--) {
            j_mid[i] = j_continue[i];
            for (int j = 1; j <= my_road[i].white_num; j++) {
                if (abs(my_road[i].connected[j].left - my_road[i + 1].connected[j_mid[i + 1]].left) < abs(my_road[i].connected[j_mid[i]].left - my_road[i + 1].connected[j_mid[i + 1]].left)
                    && my_road[i].connected[j].width > 15) {
                    j_mid[i] = j;
                    //  break;
                }

            }
            rightRoad[i] = my_road[i].connected[j_mid[i]].right;
        }
        int downPoint = 119;
        if (calculate_slope_struct(80, 95, j_mid, LEFT) <= 0) {
            for (int i = NEAR_LINE - 1; i >= 30; i--) {
                if (my_road[i - 1].connected[j_mid[i - 1]].right - my_road[i].connected[j_mid[i]].right > 4
                    && abs(my_road[i + 1].connected[j_mid[i + 1]].right - my_road[i].connected[j_mid[i]].right) <= 2
                    && my_road[i].connected[j_mid[i]].width < 40
                    && my_road[i + 1].connected[j_mid[i + 1]].width < 40
                    ) {
                    downPoint = i;
                    break;
                }
            }

        }
        else {
            int num = 110;
            downPoint = num;
            while (num >= 40 && my_road[num].connected[j_mid[num]].right <= right_side[num] - 1
                && abs(my_road[num - 1].connected[j_mid[num - 1]].right - my_road[num].connected[j_mid[num]].right) <= 4
                && abs(my_road[num + 1].connected[j_mid[num + 1]].right - my_road[num].connected[j_mid[num]].right) <= 4
                ) {
                if (my_road[num].connected[j_mid[num]].right <= my_road[downPoint].connected[j_mid[downPoint]].right + 1

                    ) {
                    downPoint = num;
                }

                num--;
            }
        }
        //uint8_t xMin = my_road[downPoint - 3].connected[j_mid[downPoint - 3]].right, yMin = downPoint - 3;
        if(downPoint == 119) {
            downPoint = 111;
        }
        uint8_t xMin = my_road[downPoint - 3].connected[j_mid[downPoint - 3]].right, yMin = downPoint - 3;
        int start = 0, end = 0;
        for (int i = downPoint - 3; i >= 30; i--) {
            if (xMin >= my_road[i].connected[j_mid[i]].right
                && abs(my_road[i].connected[j_mid[i]].right - my_road[i + 1].connected[j_mid[i + 1]].right) <= 1 && abs(my_road[i].connected[j_mid[i]].right - my_road[i - 1].connected[j_mid[i - 1]].right) <= 1
                ) {

                int is = i + 1, ie = i - 1;
                while (is < i + 10 && my_road[is].connected[j_mid[is]].right == my_road[i].connected[j_mid[i]].right) {
                    is++;
                }
                while (ie > i - 10 && my_road[ie].connected[j_mid[ie]].right == my_road[i].connected[j_mid[i]].right) {
                    ie--;
                }
                int flag = 0;
                for (int j = ie; j >= ie - 7; j--) {
                    if (my_road[j].connected[j_mid[j]].right < my_road[i].connected[j_mid[i]].right) {
                        flag = 1;
                        break;
                    }
                }
                for (int j = is; j <= is + 7; j++) {
                    if (my_road[j].connected[j_mid[j]].right < my_road[i].connected[j_mid[i]].right) {
                        flag = 1;
                        break;
                    }
                }
                if (flag == 0 //&& abs(my_road[is].connected[j_mid[is]].left-my_)
                    ) {
                    yMin = i;
                    xMin = my_road[i].connected[j_mid[i]].right;
                }
            }
            if (i <= downPoint - 40 && my_road[i].connected[j_mid[i]].right >= my_road[downPoint].connected[j_mid[downPoint]].right + 8) {
                break;
            }
        }
        /*start = yMin;
        while (start <= yMin + 20 && my_road[start].connected[j_mid[start]].right == xMin) {
            start++;
        }
        yMin = (start + yMin) / 2;
        xMin = my_road[yMin].connected[j_mid[yMin]].right;*/
        int dis = 0;
        double k = calculate_slope_struct(80, 100, j_mid, LEFT);
        if (fabs(k) < 0.2 && downPoint <= 110 && yMin < downPoint - 3) {
            dis = (int)((double)(downPoint - yMin) / (sqrt(1 - k * k)));
            if (midDownDistance == 0) {
                if (1) {
                    midDownDistance += dis;
                    midTimes++;
                }
            }
            else {
                if (abs(midDownDistance - dis) <= 15) {
                    midDownDistance = (midDownDistance * midTimes + dis) / (midTimes + 1);
                    midTimes++;
                }
            }
        }
    //  ////////printf("mD=%d,midTimes=%d,downPoint=%d,ymin=%d\n", midDownDistance, midTimes, downPoint, yMin);


    }
    else if (TIslandWhere == LEFT) {
        uint8_t j_mid[CAMERA_H];
        int leftRoad[CAMERA_H];
        for (int i = NEAR_LINE; i >= 2; i--) {
            j_mid[i] = j_continue[i];
            for (int j = 1; j <= my_road[i].white_num; j++) {
                if (abs(my_road[i].connected[j].right - my_road[i + 1].connected[j_mid[i + 1]].right) < abs(my_road[i].connected[j_mid[i]].right - my_road[i + 1].connected[j_mid[i + 1]].right)
                    && my_road[i].connected[j].width > 10) {
                    j_mid[i] = j;
                    //  break;
                }
            }
            leftRoad[i] = my_road[i].connected[j_mid[i]].left;
        }
        int downPoint = 119;
        if (calculate_slope_struct(80, 95, j_mid, RIGHT) >= 0) {
            for (int i = NEAR_LINE - 1; i >= 30; i--) {
                if (my_road[i - 1].connected[j_mid[i - 1]].left - my_road[i].connected[j_mid[i]].left < -4
                    && abs(my_road[i + 1].connected[j_mid[i + 1]].left - my_road[i].connected[j_mid[i]].left) <= 2
                    && my_road[i].connected[j_mid[i]].width < 40
                    && my_road[i + 1].connected[j_mid[i + 1]].width < 40
                    ) {
                    downPoint = i;
                    break;
                }
            }

        }
        else {

            int num = 110;
            downPoint = num;
            while (num >= 40 && my_road[num].connected[j_mid[num]].left >= left_side[num] + 1
                && abs(my_road[num - 1].connected[j_mid[num - 1]].left - my_road[num].connected[j_mid[num]].left) <= 4
                && abs(my_road[num + 1].connected[j_mid[num + 1]].left - my_road[num].connected[j_mid[num]].left) <= 4
                ) {
                if (my_road[num].connected[j_mid[num]].left >= my_road[downPoint].connected[j_mid[downPoint]].left - 1

                    ) {
                    downPoint = num;
                }

                num--;
            }
        }

        if (downPoint == 119) {
            downPoint = 111;
        }

        uint8_t xMin = my_road[downPoint - 3].connected[j_mid[downPoint - 3]].left, yMin = downPoint - 3;
        int start = 0, end = 0;
        for (int i = downPoint - 3; i >= 20; i--) {
            if (xMin <= my_road[i].connected[j_mid[i]].left && abs(my_road[i].connected[j_mid[i]].left - my_road[i + 1].connected[j_mid[i + 1]].left) <= 1 && abs(my_road[i].connected[j_mid[i]].left - my_road[i - 1].connected[j_mid[i - 1]].left) <= 1) {
                int is = i + 1, ie = i - 1;
                while (is < i + 10 && my_road[is].connected[j_mid[is]].left == my_road[i].connected[j_mid[i]].left) {
                    is++;
                }
                while (ie > i - 10 && my_road[ie].connected[j_mid[ie]].left == my_road[i].connected[j_mid[i]].left) {
                    ie--;
                }
                int flag = 0;
                for (int j = ie; j >= ie - 7; j--) {
                    if (my_road[j].connected[j_mid[j]].left > my_road[i].connected[j_mid[i]].left) {
                        flag = 1;
                        break;
                    }
                }
                for (int j = is; j <= is + 7; j++) {
                    if (my_road[j].connected[j_mid[j]].left > my_road[i].connected[j_mid[i]].left) {
                        flag = 1;
                        break;
                    }
                }
                if (flag == 0 //&& abs(my_road[is].connected[j_mid[is]].left-my_)
                    ) {
                    yMin = i;
                    xMin = my_road[i].connected[j_mid[i]].left;
                }
            }
            if (i <= downPoint - 40 && my_road[i].connected[j_mid[i]].left <= my_road[downPoint].connected[j_mid[downPoint]].left - 8) {
                break;
            }
        }
        /*start = yMin;
        while (start <= yMin + 20 && my_road[start].connected[j_mid[start]].left == xMin) {
            start++;
        }
        yMin = (start + yMin) / 2;
        xMin = my_road[yMin].connected[j_mid[yMin]].left;*/
        int dis = 0;
        double k = calculate_slope_struct(80, 100, j_mid, RIGHT);
        if (fabs(calculate_slope_struct(80, 100, j_mid, RIGHT)) < 0.2 && downPoint <= 110 && yMin < downPoint - 3) {
            dis = (int)((double)(downPoint - yMin)/(sqrt(1-k*k)));
            if (midDownDistance == 0) {
                if (1) {
                    midDownDistance += dis;
                    midTimes++;
                }
            }
            else {
                if (abs(midDownDistance - dis) <= 15) {
                    midDownDistance = (midDownDistance * midTimes + dis) / (midTimes + 1);
                    midTimes++;
                }
            }
        }

//        ////////printf("mD=%d,midTimes=%d,downPoint=%d,ymin=%d\n", midDownDistance, midTimes, downPoint, yMin);

    }


}

////////////////////////////////////////////
//功能：进T字路口或者环岛补线
//输入：
//输出：
//备注：
///////////////////////////////////////////
void design_T_island_in() {
    if (TIslandWhere == RIGHT) {

        int leftRoad[CAMERA_H];
        uint8_t j_mid[CAMERA_H];
        for (int i = NEAR_LINE; i >= 2; i--) {
            j_mid[i] = j_continue[i];
            for (int j = 1; j <= my_road[i].white_num; j++) {
                if (abs(my_road[i].connected[j].left - my_road[i + 1].connected[j_mid[i + 1]].left) < abs(my_road[i].connected[j_mid[i]].left - my_road[i + 1].connected[j_mid[i + 1]].left)
                    && my_road[i].connected[j].width > 15) {
                    j_mid[i] = j;
                    //  break;
                }

            }
            leftRoad[i] = my_road[i].connected[j_mid[i]].left;
        }
        uint8_t xMin = my_road[110].connected[j_mid[110]].right, yMin = 110;
        for (int i = 110; i > 2; i--) {
            if (xMin >= my_road[i].connected[j_mid[i]].right) {
                yMin = i;
                xMin = my_road[i].connected[j_mid[i]].right;
            }
        }

        double k = calculate_slope(80, 100, leftRoad);

        for (int i = 110; i >= 50; i--) {

            right_line[i] = leftRoad[i] + 26;//xMin - leftRoad[yMin] - 20;
            left_line[i] = leftRoad[i];
        }
    }
    else if (TIslandWhere == LEFT) {
        uint8_t j_mid[CAMERA_H];
        int rightRoad[CAMERA_H];
        for (int i = NEAR_LINE; i >= 2; i--) {
            j_mid[i] = j_continue[i];
            for (int j = 1; j <= my_road[i].white_num; j++) {
                if (abs(my_road[i].connected[j].right - my_road[i + 1].connected[j_mid[i + 1]].right) < abs(my_road[i].connected[j_mid[i]].right - my_road[i + 1].connected[j_mid[i + 1]].right)
                    && my_road[i].connected[j].width > 10) {
                    j_mid[i] = j;
                    //  break;
                }
            }
            rightRoad[i] = my_road[i].connected[j_mid[i]].right;
        }

        uint8_t xMin = my_road[110].connected[j_mid[110]].left, yMin = 110;
        for (int i = 110; i > 2; i--) {
            if (xMin <= my_road[i].connected[j_mid[i]].left) {
                yMin = i;
                xMin = my_road[i].connected[j_mid[i]].left;
            }
            if (my_road[i - 1].white_num == 0) {
                break;
            }
        }

        double k = calculate_slope(80, 100, rightRoad);

        for (int i = 110; i >= 50; i--) {
            left_line[i] = rightRoad[i] - 26;//+ xMin - rightRoad[yMin] ;
            right_line[i] = rightRoad[i];
        }
    }
}


//////////////////////////////////////////////
////功能：进T字路口或者环岛
////输入：
////输出：
////备注：
/////////////////////////////////////////////
//void T_or_island() {
//
//    int sumD = 0;
//    int sumU = 0;
//    for (int i = NEAR_LINE; i >= 103; i--) {
//        if (right_line[i] - left_line[i] > 32 && (left_line[i] <= left_side[i] + 2 || right_line[i] >= right_side[i] - 2)) {
//            sumD++;
//        }
//    }
//    for (int i = 98; i >= 83; i--) {
//        if (right_line[i] - left_line[i] < 42) {
//            sumU++;
//        }
//    }
//
//    if (sumD > 5 && sumU > 5) {
//        //如果上方没有赛道，我们认为是十字回环
//        if (my_road[35].white_num == 0) {
//            state = stateTIn;
//            TWhere = TIslandWhere;
//        }
//        else {
//            if (TIslandWhere == RIGHT) {
//                int dside[CAMERA_H];
//                uint8_t j_mid[CAMERA_H];
//                for (int i = NEAR_LINE; i >= 2; i--) {
//                    j_mid[i] = j_continue[i];
//                    for (int j = 1; j <= my_road[i].white_num; j++) {
//                        if (abs(my_road[i].connected[j].left - my_road[i + 1].connected[j_mid[i + 1]].left) < abs(my_road[i].connected[j_mid[i]].left - my_road[i + 1].connected[j_mid[i + 1]].left)
//                            && my_road[i].connected[j].width > 15) {
//                            j_mid[i] = j;
//
//                        }
//
//                    }
//                    dside[i] = my_road[i].connected[j_mid[i]].right - my_road[i].connected[j_mid[i]].left;
//                }
//
//                double kl1 = calculate_slope_struct(30, 45, j_mid, LEFT);
//                double kl2 = calculate_slope_struct(60, 75, j_mid, LEFT);
//                double kl3 = calculate_slope_struct(85, 100, j_mid, LEFT);
//
//                if (fabs(kl1 - kl2) < 0.2 && fabs(kl1 - kl3) < 0.2 && fabs(kl2 - kl3) < 0.2) {
//                    int upPoint = 119;
//                    if (calculate_slope_struct(70, 90, j_mid, LEFT) >= 0) {
//                        for (int i = NEAR_LINE - 2; i >= 50; i--) {
//                            if (my_road[i].connected[j_mid[i]].right - my_road[i + 1].connected[j_mid[i + 1]].right < -4
//                                && my_road[i].connected[j_mid[i]].right - my_road[i + 2].connected[j_mid[i + 2]].right < -4
//                                && abs(my_road[i].connected[j_mid[i]].right - my_road[i - 2].connected[j_mid[i - 2]].right) <= 2
//                                && abs(my_road[i].connected[j_mid[i]].right - my_road[i - 1].connected[j_mid[i - 1]].right) <= 2
//                                && my_road[i].connected[j_mid[i]].width < 32) {
//
//                                upPoint = i;
//                                break;
//
//                            }
//                        }
//
//                    }
//                    else {
//                        int start = NEAR_LINE - 2;
//                        if (my_road[start].connected[j_mid[start]].right >= right_side[start] - 2) {
//                            while (start > 40 && my_road[start].connected[j_mid[start]].right >= right_side[start] - 2) {
//                                start--;
//                            }
//                        }
//                        upPoint = 110;
//                        while (start > 30 && my_road[start].connected[j_mid[start]].right < right_side[start] - 2) {
//                            if (my_road[start].connected[j_mid[start]].right <= my_road[upPoint].connected[j_mid[upPoint]].right
//                                && abs(my_road[start].connected[j_mid[start]].right - my_road[start + 1].connected[j_mid[start + 1]].right) <= 1
//                                && abs(my_road[start].connected[j_mid[start]].right - my_road[start - 1].connected[j_mid[start - 1]].right) <= 1) {
//                                upPoint = start;
//                            }
//                            start--;
//                        }
//
//                    }
//                    if (upPoint < 110 && 50 <= upPoint) {
//                        if (variance(upPoint - 13, upPoint - 1, dside) < 1) {
//                            state = stateTIn;
//                            TWhere = TIslandWhere;
//                            TIslandWhere = 0;
//                        }
//                        else {
//                            state = stateIslandIng;
//                            islandWhere = TIslandWhere;
//                            TIslandWhere = 0;
//                        }
//                    }
//                    else {
//                        state = stateIslandIng;
//                        islandWhere = TIslandWhere;
//                        TIslandWhere = 0;
//                    }
//                }
//                else {
//                    state = stateTIn;
//                    TWhere = TIslandWhere;
//                    TIslandWhere = 0;
//                }
//            }
//            else if (TIslandWhere == LEFT) {
//                uint8_t j_mid[CAMERA_H];
//                int dside[CAMERA_H];
//                int left[CAMERA_H];
//                for (int i = NEAR_LINE; i >= 2; i--) {
//                    j_mid[i] = j_continue[i];
//                    for (int j = 1; j <= my_road[i].white_num; j++) {
//                        if (abs(my_road[i].connected[j].right - my_road[i + 1].connected[j_mid[i + 1]].right) < abs(my_road[i].connected[j_mid[i]].right - my_road[i + 1].connected[j_mid[i + 1]].right)
//                            && my_road[i].connected[j].width > 15) {
//                            j_mid[i] = j;
//
//                        }
//
//                    }
//                    dside[i] = my_road[i].connected[j_mid[i]].right - my_road[i].connected[j_mid[i]].left;
//                    left[i] = my_road[i].connected[j_mid[i]].left;
//                }
//
//                //////////printf("d=%f\n", variance(60, 80, dside));
//                //////////printf("l=%f,l=%f,r=%f\n", linear_judgement(45, 75, leftside),correlation_coefficient(45,75,left),calculate_radius(45,75,leftside));
//                double kl1 = calculate_slope_struct(35, 50, j_mid, RIGHT);
//                double kl2 = calculate_slope_struct(65, 80, j_mid, RIGHT);
//                double kl3 = calculate_slope_struct(90, 105, j_mid, RIGHT);
//
//                // ////////printf("dk1=%f,dk2=%f,dk3=%f\n", fabs(kl1 - kl2), fabs(kl1 - kl3), fabs(kl2 - kl3));
//                if (fabs(kl1 - kl2) < 0.2 && fabs(kl1 - kl3) < 0.2 && fabs(kl2 - kl3) < 0.2) {
//                    int upPoint = 119;
//                    if (calculate_slope_struct(70, 90, j_mid, RIGHT) <= 0) {
//                        for (int i = NEAR_LINE - 2; i >= 50; i--) {
//                            if (my_road[i].connected[j_mid[i]].left - my_road[i + 1].connected[j_mid[i + 1]].left > 4
//                                && my_road[i].connected[j_mid[i]].left - my_road[i + 2].connected[j_mid[i + 2]].left > 4
//                                && abs(my_road[i].connected[j_mid[i]].left - my_road[i - 2].connected[j_mid[i - 2]].left) <= 2
//                                && abs(my_road[i].connected[j_mid[i]].left - my_road[i - 1].connected[j_mid[i - 1]].left) <= 2
//                                && my_road[i].connected[j_mid[i]].width < 32) {
//
//                                upPoint = i;
//                                break;
//
//                            }
//                        }
//
//                    }
//                    else {
//                        int start = NEAR_LINE - 2;
//                        if (my_road[start].connected[j_mid[start]].left <= left_side[start] + 2) {
//                            while (start > 40 && my_road[start].connected[j_mid[start]].left <= left_side[start] + 2) {
//                                start--;
//                            }
//                        }
//                        upPoint = 110;
//                        while (start > 30 && my_road[start].connected[j_mid[start]].left > left_side[start] + 2) {
//                            if (my_road[start].connected[j_mid[start]].left >= my_road[upPoint].connected[j_mid[upPoint]].left
//                                && abs(my_road[start].connected[j_mid[start]].left - my_road[start + 1].connected[j_mid[start + 1]].left) <= 1
//                                && abs(my_road[start].connected[j_mid[start]].left - my_road[start - 1].connected[j_mid[start - 1]].left) <= 1) {
//                                upPoint = start;
//                            }
//                            start--;
//                        }
//
//                    }
//                    if (upPoint < 110 && 50 <= upPoint) {
//                        if (variance(upPoint - 13, upPoint - 1, dside) < 1) {
//                            state = stateTIn;
//                            TWhere = TIslandWhere;
//                            TIslandWhere = 0;
//                        }
//                        else {
//                            state = stateIslandIng;
//                            islandWhere = TIslandWhere;
//                            TIslandWhere = 0;
//                        }
//                    }
//                    else {
//                        state = stateIslandIng;
//                        islandWhere = TIslandWhere;
//                        TIslandWhere = 0;
//                    }
//
//                }
//                else {
//                    state = stateTIn;
//                    TWhere = TIslandWhere;
//                    TIslandWhere = 0;
//                }
//            }
//        }
//    }
//}

////////////////////////////////////////////
//功能：进T字路口或者环岛
//输入：
//输出：
//备注：
///////////////////////////////////////////
void T_or_island() {

    int sumD = 0;
    int sumU = 0;
    for (int i = NEAR_LINE; i >= 90; i--) {
    //  //////printf("%d=%d", i, right_line[i] - left_line[i]);
        if (right_line[i] - left_line[i] <= 35) {
        //  //////printf(",%d", i);
            sumD++;
        }
    //  //////printf("\n");
    }

    int sumL = 0;
    for (int i = NEAR_LINE - 1; i >= NEAR_LINE - 3; i--) {
        if(TIslandWhere == RIGHT){
            if ((right_line[i] - left_line[i] > 35) || (left_line[i] > left_side[i] + 1 && right_line[i] >= right_side[i] - 1)) {
                sumL++;
            }
        }else if(TIslandWhere == LEFT){
            if ((right_line[i] - left_line[i] > 35) || (left_line[i] <= left_side[i] + 1 && right_line[i] < right_side[i] - 1)) {
                sumL++;
            }
        }

    }

    if (sumD > 4 && sumL>=2) {
        //如果上方没有赛道，我们认为是十字回环
        if (my_road[35].white_num == 0 && wayIT == -1) {
            state = stateTIn;
            TWhere = TIslandWhere;
            TIslandWhere = 0;
            wayIT = wayIT * -1;
        }
        else {
            if (TIslandWhere == RIGHT) {
                int dside[CAMERA_H];
                uint8_t j_mid[CAMERA_H];
                for (int i = NEAR_LINE; i >= 2; i--) {
                    j_mid[i] = j_continue[i];
                    for (int j = 1; j <= my_road[i].white_num; j++) {
                        if (abs(my_road[i].connected[j].left - my_road[i + 1].connected[j_mid[i + 1]].left) < abs(my_road[i].connected[j_mid[i]].left - my_road[i + 1].connected[j_mid[i + 1]].left)
                            && my_road[i].connected[j].width > 15) {
                            j_mid[i] = j;

                        }

                    }
                    dside[i] = my_road[i].connected[j_mid[i]].right - my_road[i].connected[j_mid[i]].left;
                }

                double kl1 = calculate_slope_struct(30, 45, j_mid, LEFT);
                double kl2 = calculate_slope_struct(60, 75, j_mid, LEFT);
                double kl3 = calculate_slope_struct(85, 100, j_mid, LEFT);

                if (fabs(kl1 - kl2) < 0.2 && fabs(kl1 - kl3) < 0.2 && fabs(kl2 - kl3) < 0.2 && wayIT == 1) {
                    //state = stateSTIsland;
                    state = stateIslandIng;
                    islandWhere = TIslandWhere;
                    TIslandWhere = 0;
                    wayIT = wayIT * -1;
                }
                else {
                    if (wayIT == -1) {
                        state = stateTIn;
                        TWhere = TIslandWhere;
                        TIslandWhere = 0;
                        wayIT = wayIT * -1;
                    }
                }
            }
            else if (TIslandWhere == LEFT) {
                uint8_t j_mid[CAMERA_H];
                int dside[CAMERA_H];
                int left[CAMERA_H];
                for (int i = NEAR_LINE; i >= 2; i--) {
                    j_mid[i] = j_continue[i];
                    for (int j = 1; j <= my_road[i].white_num; j++) {
                        if (abs(my_road[i].connected[j].right - my_road[i + 1].connected[j_mid[i + 1]].right) < abs(my_road[i].connected[j_mid[i]].right - my_road[i + 1].connected[j_mid[i + 1]].right)
                            && my_road[i].connected[j].width > 15) {
                            j_mid[i] = j;

                        }

                    }
                    dside[i] = my_road[i].connected[j_mid[i]].right - my_road[i].connected[j_mid[i]].left;
                    left[i] = my_road[i].connected[j_mid[i]].left;
                }

                ////////printf("d=%f\n", variance(60, 80, dside));
                ////////printf("l=%f,l=%f,r=%f\n", linear_judgement(45, 75, leftside),correlation_coefficient(45,75,left),calculate_radius(45,75,leftside));
                double kl1 = calculate_slope_struct(35, 50, j_mid, RIGHT);
                double kl2 = calculate_slope_struct(65, 80, j_mid, RIGHT);
                double kl3 = calculate_slope_struct(90, 105, j_mid, RIGHT);

                // //////printf("dk1=%f,dk2=%f,dk3=%f\n", fabs(kl1 - kl2), fabs(kl1 - kl3), fabs(kl2 - kl3));
                //外边不直是回环
                if (fabs(kl1 - kl2) < 0.2 && fabs(kl1 - kl3) < 0.2 && fabs(kl2 - kl3) < 0.2 && wayIT == 1) {
                    //state = stateSTIsland;
                    state = stateIslandIng;
                    islandWhere = TIslandWhere;
                    TIslandWhere = 0;
                    wayIT = wayIT * -1;
                }
                else {
                    if (wayIT == -1) {
                        state = stateTIn;
                        TWhere = TIslandWhere;
                        TIslandWhere = 0;
                        wayIT = wayIT * -1;
                    }
                }
            }
        }
    }
}

////////////////////////////////////////////
//功能：环岛直线补线
//输入：
//输出：
//备注：
///////////////////////////////////////////
void straightT_or_island() {

    if (1) {
        if (my_road[40].white_num == 0) {
            state = stateTIn;
            TWhere = TIslandWhere;
            TIslandWhere = 0;
        }
        else {
            int sumD = 0;
            for (int i = NEAR_LINE; i >= 103; i--) {
                ////////printf("%d=%d\n", i, right_line[i] - left_line[i]);
                if (right_line[i] - left_line[i] < 35) {
                    sumD++;
                }
            }
            if (sumD >= 5) {
                if (TIslandWhere == LEFT) {
                    int sumL = 0;
                    for (int i = NEAR_LINE - 1; i >= 105; i--) {
                        if (left_line[i] - left_side[i] > 1) {
                            sumL++;
                        }
                    }
                    ////////printf("flag1=%d\n", sumL);
                    if (sumL > 5 && right_line[NEAR_LINE - 1] - left_line[NEAR_LINE - 1] < 30) {
                        uint8_t j_mid1[CAMERA_H];
                        uint8_t j_mid2[CAMERA_H];
                        j_mid1[NEAR_LINE] = j_continue[NEAR_LINE];
                        j_mid2[NEAR_LINE] = j_continue[NEAR_LINE];
                        uint8_t dside[CAMERA_H];
                        for (int i = NEAR_LINE - 1; i >= 2; i--) {
                            j_mid1[i] = j_continue[i];
                            for (int j = 1; j <= my_road[i].white_num; j++) {
                                if (abs(my_road[i].connected[j].right - my_road[i + 1].connected[j_mid1[i + 1]].right) < abs(my_road[i].connected[j_mid1[i]].right - my_road[i + 1].connected[j_mid1[i + 1]].right)
                                    && my_road[i].connected[j].width > 15) {
                                    j_mid1[i] = j;

                                }

                            }
                            j_mid2[i] = j_continue[i];
                            for (int j = 1; j <= my_road[i].white_num; j++) {
                                if (abs(my_road[i].connected[j].left - my_road[i + 1].connected[j_mid1[i + 1]].left) < abs(my_road[i].connected[j_mid1[i]].left - my_road[i + 1].connected[j_mid1[i + 1]].left)
                                    && my_road[i].connected[j].width > 15) {
                                    j_mid2[i] = j;

                                }
                                //  ////////printf("rl=%d,lr=%d\n", my_road[i].connected[j_mid1[i]].left,my_road[i].connected[j_mid2[i]].right);

                            }
                            dside[i] = my_road[i].connected[j_mid1[i]].right - my_road[i].connected[j_mid2[i]].left;
                        }
                        //先确定是不是长直边
                        double kR1 = calculate_slope_struct(40, 65, j_mid1, RIGHT);
                        double kR2 = calculate_slope_struct(70, 85, j_mid1, RIGHT);
                        double kR3 = calculate_slope_struct(90, 105, j_mid1, RIGHT);
                        double kL1 = calculate_slope_struct(40, 65, j_mid2, RIGHT);
                        double kL2 = calculate_slope_struct(70, 85, j_mid2, RIGHT);
                        double kL3 = calculate_slope_struct(90, 105, j_mid2, RIGHT);
                        if (fabs(kR1 - kR2) < 0.2 && fabs(kR1 - kR3) < 0.2 && fabs(kR2 - kR3) < 0.2) {
                            //找到环岛的突变点
                            //利用宽度变化
                            //环岛第二个匝口
                            int top = 119;
                            ////////printf("%f,%f\n", calculate_slope_struct(44 - 13, 44 - 1, j_mid1, LEFT), calculate_slope_struct(44 - 13, 44 - 1, j_mid1, RIGHT));
                            for (int i = 90; i >= 10; i--) {
                                if (my_road[i].connected[j_mid1[i]].left - my_road[i + 1].connected[j_mid1[i + 1]].left > 4
                                    && my_road[i].connected[j_mid1[i]].width < 30
                                    && fabs(calculate_slope_struct(i - 13, i - 1, j_mid1, LEFT) - calculate_slope_struct(i - 13, i - 1, j_mid1, RIGHT)) < 0.25
                                    && abs(my_road[i].connected[j_mid1[i]].left - my_road[i].connected[j_mid1[i - 1]].left) <= 2
                                    && abs(my_road[i].connected[j_mid1[i]].left - my_road[i].connected[j_mid1[i - 2]].left) <= 2
                                    ) {
                                    top = i;
                                    break;
                                }
                            }
                            ////////printf("top=%d\n", top);
                            int end = 50;
                            if (IslandRadius < 70) {
                                end = 40;
                            }
                            else if (IslandRadius >= 70) {
                                end = 18;
                            }
                            if (top != 119) {
                                int width[CAMERA_H];
                                for (int i = top - 5; i <= top + 20; i++) {
                                    width[i] = my_road[i].connected[j_mid2[i]].width;
                                }
                                //  ////////printf("wv=%f\n", variance(top - 5, top + 20, width));
                            }

                            if (top >= end && top < 119) {
                                int sumW = 0;
                                for (int i = top + 1; i <= top + 30; i++) {
                                    if (my_road[i].connected[j_mid1[i]].width > 35) {
                                        sumW++;
                                    }
                                }
                                if (sumW >= 6) {
                                    state = stateIslandIng;
                                    islandWhere = TIslandWhere;
                                    TIslandWhere = 0;
                                }

                            }

                            //////////printf("top=%d\n", top);

                        }
                        else {
                            ////////printf("402");
                            //侧边不是直道，是回环
                            state = stateTIn;
                            TWhere = TIslandWhere;
                            TIslandWhere = 0;
                        }
                    }
                }
                else if (TIslandWhere == RIGHT) {
                    int sumL = 0;
                    for (int i = NEAR_LINE - 1; i >= 105; i--) {
                        if (right_line[i] - right_side[i] < -1) {
                            sumL++;
                        }
                    }
//                    test_varible[4] = right_line[NEAR_LINE - 1];
//                    test_varible[5] = left_line[NEAR_LINE - 1];
                    ////////printf("flag1=%d\n", sumL);
                    if (sumL > 5 && right_line[NEAR_LINE - 1] - left_line[NEAR_LINE - 1] < 30) {

                        uint8_t j_mid1[CAMERA_H];
                        uint8_t j_mid2[CAMERA_H];
                        j_mid1[NEAR_LINE] = j_continue[NEAR_LINE];
                        j_mid2[NEAR_LINE] = j_continue[NEAR_LINE];
                        uint8_t dside[CAMERA_H];
                        for (int i = NEAR_LINE - 1; i >= 2; i--) {
                            j_mid1[i] = j_continue[i];
                            for (int j = 1; j <= my_road[i].white_num; j++) {
                                if (abs(my_road[i].connected[j].left - my_road[i + 1].connected[j_mid1[i + 1]].left) < abs(my_road[i].connected[j_mid1[i]].left - my_road[i + 1].connected[j_mid1[i + 1]].left)
                                    && my_road[i].connected[j].width > 15) {
                                    j_mid1[i] = j;

                                }

                            }
                            j_mid2[i] = j_continue[i];
                            for (int j = 1; j <= my_road[i].white_num; j++) {
                                if (abs(my_road[i].connected[j].right - my_road[i + 1].connected[j_mid1[i + 1]].right) < abs(my_road[i].connected[j_mid1[i]].right - my_road[i + 1].connected[j_mid1[i + 1]].right)
                                    && my_road[i].connected[j].width > 15) {
                                    j_mid2[i] = j;

                                }
                                //  ////////printf("rl=%d,lr=%d\n", my_road[i].connected[j_mid1[i]].left,my_road[i].connected[j_mid2[i]].right);

                            }
                            dside[i] = my_road[i].connected[j_mid1[i]].right - my_road[i].connected[j_mid2[i]].left;
                        }
                        //先确定是不是长直边
                        double kR1 = calculate_slope_struct(40, 65, j_mid1, LEFT);
                        double kR2 = calculate_slope_struct(70, 85, j_mid1, LEFT);
                        double kR3 = calculate_slope_struct(90, 105, j_mid1, LEFT);
                        double kL1 = calculate_slope_struct(40, 65, j_mid2, RIGHT);
                        double kL2 = calculate_slope_struct(70, 85, j_mid2, RIGHT);
                        double kL3 = calculate_slope_struct(90, 105, j_mid2, RIGHT);
                        if (fabs(kR1 - kR2) < 0.2 && fabs(kR1 - kR3) < 0.2 && fabs(kR2 - kR3) < 0.2) {
                            //找到环岛的突变点
                            //利用宽度变化
                            //环岛第二个匝口
                            int top = 119;
                            ////////printf("%f,%f\n", calculate_slope_struct(44 - 13, 44 - 1, j_mid1, LEFT), calculate_slope_struct(44 - 13, 44 - 1, j_mid1, RIGHT));
                            for (int i = 90; i >= 10; i--) {
                                if (my_road[i].connected[j_mid1[i]].right - my_road[i + 1].connected[j_mid1[i + 1]].right < -6
                                    && my_road[i].connected[j_mid1[i]].width < 30
                                    && fabs(calculate_slope_struct(i - 13, i - 1, j_mid1, LEFT) - calculate_slope_struct(i - 13, i - 1, j_mid1, RIGHT)) < 0.25
                                    && abs(my_road[i].connected[j_mid1[i]].left - my_road[i].connected[j_mid1[i - 1]].left) <= 2
                                    && abs(my_road[i].connected[j_mid1[i]].left - my_road[i].connected[j_mid1[i - 2]].left) <= 2
                                    ) {
                                    top = i;
                                    break;
                                }
                            }
                            ////////printf("top=%d\n", top);
                            int end = 50;
                            if (IslandRadius < 70) {
                                end = 40;
                            }
                            else if (IslandRadius >= 70) {
                                end = 18;
                            }
                            if (top != 119) {
                                int width[CAMERA_H];
                                for (int i = top - 5; i <= top + 20; i++) {
                                    width[i] = my_road[i].connected[j_mid2[i]].width;
                                }
                                //  ////////printf("wv=%f\n", variance(top - 5, top + 20, width));
                            }

                            if (top >= end && top < 119) {
                                int sumW = 0;
                                for (int i = top + 1; i <= top + 30; i++) {
                                    if (my_road[i].connected[j_mid1[i]].width > 35) {
                                        sumW++;
                                    }
                                }
                                if (sumW >= 6) {
                                    state = stateIslandIng;
                                    islandWhere = TIslandWhere;
                                    TIslandWhere = 0;
                                }

                            }

                            //////////printf("top=%d\n", top);

                        }
                        else {
                           // ////////printf("402");
                            //侧边不是直道，是回环
                            state = stateTIn;
                            TWhere = TIslandWhere;
                            TIslandWhere = 0;
                        }
                    }
                }
            }
        }

    }

}

////////////////////////////////////////////
//功能：环岛直线补线
//输入：
//输出：
//备注：
///////////////////////////////////////////
void design_island_ing() {
    if (islandWhere == RIGHT) {

            int leftRoad[CAMERA_H];
            uint8_t j_mid[CAMERA_H];
            for (int i = NEAR_LINE; i >= 2; i--) {
                j_mid[i] = j_continue[i];
                for (int j = 1; j <= my_road[i].white_num; j++) {
                    if (abs(my_road[i].connected[j].left - my_road[i + 1].connected[j_mid[i + 1]].left) < abs(my_road[i].connected[j_mid[i]].left - my_road[i + 1].connected[j_mid[i + 1]].left)
                        && my_road[i].connected[j].width > 15) {
                        j_mid[i] = j;
                        //  break;
                    }

                }
                leftRoad[i] = my_road[i].connected[j_mid[i]].left;
            }
            uint8_t xMin = my_road[110].connected[j_mid[110]].right, yMin = 110;
            for (int i = 110; i > 40; i--) {
                if (xMin >= my_road[i].connected[j_mid[i]].right) {
                    yMin = i;
                    xMin = my_road[i].connected[j_mid[i]].right;
                }
            }

            double k = calculate_slope(80, 100, leftRoad);

            for (int i = 110; i >= 50; i--) {

                right_line[i] = leftRoad[i] + 24;//xMin - leftRoad[yMin] - 20;
                left_line[i] = leftRoad[i];
            }
        }
        else if (islandWhere == LEFT) {
            uint8_t j_mid[CAMERA_H];
            int rightRoad[CAMERA_H];
            for (int i = NEAR_LINE; i >= 2; i--) {
                j_mid[i] = j_continue[i];
                for (int j = 1; j <= my_road[i].white_num; j++) {
                    if (abs(my_road[i].connected[j].right - my_road[i + 1].connected[j_mid[i + 1]].right) < abs(my_road[i].connected[j_mid[i]].right - my_road[i + 1].connected[j_mid[i + 1]].right)
                        && my_road[i].connected[j].width > 10) {
                        j_mid[i] = j;
                        //  break;
                    }
                }
                rightRoad[i] = my_road[i].connected[j_mid[i]].right;
            }

            uint8_t xMin = my_road[110].connected[j_mid[110]].left, yMin = 110;
            for (int i = 110; i > 40; i--) {
                if (xMin <= my_road[i].connected[j_mid[i]].left) {
                    yMin = i;
                    xMin = my_road[i].connected[j_mid[i]].left;
                }
                if (my_road[i - 1].white_num == 0) {
                    break;
                }
            }

            double k = calculate_slope(80, 100, rightRoad);

            for (int i = 110; i >= 50; i--) {
                left_line[i] = rightRoad[i] - 24;//+ xMin - rightRoad[yMin] ;
                right_line[i] = rightRoad[i];
            }
        }
    }

////////////////////////////////////////////
//功能：环岛拐弯
//输入：
//输出：
//备注：
///////////////////////////////////////////
void island_turn() {
    int D = islandout_up.intVal;
    int flag=1;
    if(right_line[NEAR_LINE - 1] - left_line[NEAR_LINE - 1] > 35 || left_line[NEAR_LINE - 1] <= left_side[NEAR_LINE - 1] || right_line[NEAR_LINE - 1] >= right_side[NEAR_LINE - 1]) flag=0;
    if (islandWhere == RIGHT && flag == 1) {
        uint8_t j_mid[CAMERA_H];
        for (int i = NEAR_LINE; i >= 2; i--) {
            j_mid[i] = j_continue[i];
            for (int j = 1; j <= my_road[i].white_num; j++) {
                if (abs(my_road[i].connected[j].left - my_road[i + 1].connected[j_mid[i + 1]].left) < abs(my_road[i].connected[j_mid[i]].left - my_road[i + 1].connected[j_mid[i + 1]].left)
                    && my_road[i].connected[j].width > 15) {
                    j_mid[i] = j;

                }

            }
        }
        if (1) {
            int upPoint = 119;
            for (int i = 90; i >= 30; i--) {
                if (my_road[i].connected[j_mid[i]].width < 35 && my_road[i + 2].connected[j_mid[i + 2]].width >= 32
                    && my_road[i - 1].connected[j_mid[i - 1]].width < 40 && my_road[i + 3].connected[j_mid[i + 3]].width >= 32
                    && my_road[i].connected[j_mid[i]].right - my_road[i + 1].connected[j_mid[i + 1]].right < -6
                    && abs(my_road[i].connected[j_mid[i]].right - my_road[i - 1].connected[j_mid[i - 1]].right) <= 2
                    //&& fabs(calculate_slope_struct(i - 15, i - 1, j_mid, RIGHT) - calculate_slope_struct(i - 10, i + 3, j_mid, LEFT)) < 0.25
                    ) {
                    upPoint = i;
                    break;
                }
            }
//            test_varible[2] = upPoint;
//            test_varible[3]=my_road[upPoint].connected[j_mid[upPoint]].right;
            if (1) {
                int up = 60;
                if(IslandRadius == 70){
                up = 62;
            }
            else if(IslandRadius == 50)
            {
                up = 63;
            }
            else if(IslandRadius == 100)
            {
                up = 62;
            }
                if (up + D <= upPoint && upPoint <= 110 && my_road[upPoint].connected[j_mid[upPoint]].right < 115) {
                    state = stateIslandTurn;
                }
            }


        }


    }
    else if (islandWhere == LEFT && flag == 1) {
        uint8_t j_mid[CAMERA_H];
        j_mid[NEAR_LINE]=j_continue[NEAR_LINE];
        for (int i = NEAR_LINE-1; i >= 2; i--) {
            j_mid[i] = j_continue[i];
            for (int j = 1; j <= my_road[i].white_num; j++) {
                if (abs(my_road[i].connected[j].right - my_road[i + 1].connected[j_mid[i + 1]].right) < abs(my_road[i].connected[j_mid[i]].right - my_road[i + 1].connected[j_mid[i + 1]].right)
                    && my_road[i].connected[j].width > 10) {
                    j_mid[i] = j;

                }

            }
        }

        if (my_road[35].connected[j_mid[35]].width < 35) {
            int upPoint = 119;
            for (int i = 100; i >= 30; i--) {
                if (my_road[i].connected[j_mid[i]].width < 35 && my_road[i + 2].connected[j_mid[i + 2]].width >= 35
                    && my_road[i - 1].connected[j_mid[i - 1]].width < 35 && my_road[i + 3].connected[j_mid[i + 3]].width >= 35
                    && my_road[i].connected[j_mid[i]].left - my_road[i + 1].connected[j_mid[i + 1]].left > 6
                    && abs(my_road[i].connected[j_mid[i]].left - my_road[i - 1].connected[j_mid[i - 1]].left) <= 2

                    //&& fabs(calculate_slope_struct(i - 15,i - 1,j_mid,LEFT)- calculate_slope_struct(i - 10, i + 3, j_mid, RIGHT)) < 0.35
                    ) {
                    upPoint = i;
                    break;
                }
            }

//            test_varible[2] = upPoint;
//            test_varible[2] = upPoint;

            if (1) {
                int up = 60;
                if(IslandRadius == 70){
                up = 61;
                }
                else if(IslandRadius == 50)
                {
                    up = 63;
                }
                else if(IslandRadius == 100)
                {
                    up = 62;
                }
                if (up + D <= upPoint && upPoint < 100 && my_road[upPoint].connected[j_mid[upPoint]].left > 70) {
                    state = stateIslandTurn;
                }
            }

        }


    }

}

////////////////////////////////////////////
//功能：环岛拐弯补线
//输入：
//输出：
//备注：
///////////////////////////////////////////
void design_island_turn() {
    double dk = 0.3;
    double dkRight = islandParam1.floatVal, dkLeft = design_island_k.floatVal;
    if (islandWhere == RIGHT) {
        uint8_t j_mid[CAMERA_H];
        uint8_t j_mid2[CAMERA_H];
        for (int i = NEAR_LINE - 1; i >= 2; i--) {
            j_mid[i] = j_continue[i];
            j_mid2[i] = j_continue[i];
            for (int j = 1; j <= my_road[i].white_num; j++) {
                if (abs(my_road[i].connected[j].left - my_road[i + 1].connected[j_mid[i + 1]].left) < abs(my_road[i].connected[j_mid[i]].left - my_road[i + 1].connected[j_mid[i + 1]].left)
                    && my_road[i].connected[j].width > 10) {
                    j_mid[i] = j;

                }
                if (abs(my_road[i].connected[j].right - my_road[i + 1].connected[j_mid2[i + 1]].right) < abs(my_road[i].connected[j_mid2[i]].right - my_road[i + 1].connected[j_mid2[i + 1]].right)
                    && my_road[i].connected[j].width > 10) {
                    j_mid2[i] = j;

                }
            }
        }
        int way = 2;


        if (way == 1) {
            //固定打角
            double k = (double)(10 - ((NEAR_LINE - 5))) / (right_side[10] - left_line[(NEAR_LINE - 5)]) - dk;

            for (int i = (NEAR_LINE - 5); i >= 2; i--) {
                left_line[i] = k * (i - ((NEAR_LINE - 5))) + left_line[(NEAR_LINE - 5)];
                right_line[i] = right_side[i];
            }
        }
        else if (way == 2) {
            //连接顶点
            int upPoint = 119;
            for (int i = 110; i >= 50; i--) {
                if (my_road[i].connected[j_mid[i]].width < 35 && my_road[i + 2].connected[j_mid[i + 2]].width >= 35
                    && my_road[i - 1].connected[j_mid[i - 1]].width < 40 && my_road[i + 3].connected[j_mid[i + 3]].width >= 35
                    && my_road[i].connected[j_mid[i]].right - my_road[i + 1].connected[j_mid[i + 1]].right < -6
                    && my_road[i].connected[j_mid[i]].right - my_road[i + 2].connected[j_mid[i + 2]].right < -6
                    && abs(my_road[i].connected[j_mid[i]].right - my_road[i - 1].connected[j_mid[i - 1]].right) <= 4
                    && abs(my_road[i].connected[j_mid[i]].right - my_road[i - 2].connected[j_mid[i - 2]].right) <= 4
                    && (my_road[i].connected[j_mid[i]].left != my_road[i].connected[j_mid2[i]].left || left_line[45] != MISS)
                    ) {
                    upPoint = i;
                    break;
                }
            }


            //            test_varible[3] = upPoint;
            //            if (lastUpPoint == 0) {
            //                lastUpPoint = upPoint;
            //            }
            //            else {
            //                ////////printf("up1=%d\n", upPoint);
            //                if (upPoint < lastUpPoint - 10) {
            //
            //                    upPoint = lastUpPoint;
            //
            //                }else{
            //                    lastUpPoint = upPoint;
            //                }
            //            //  //////printf("up2=%d\n", upPoint);
            //            }

            if (upPoint <= 95 && upPoint > 60) {
                double k = (double)(my_road[upPoint].connected[j_mid[upPoint]].right - my_road[107].connected[j_mid[107]].left) / (upPoint - 107);
                if (IslandRadius == 50)
                {
                    k = k - 0.5;
                }
                else if (IslandRadius >= 60 && IslandRadius <= 70)
                {
                    k = k - 0.2;
                }
                else if (IslandRadius > 70)
                {
                    k = k - 0.2;
                }
                for (int i = 107; i >= 2; i--) {
                    left_line[i] = (k - dkRight) * (i - (107)) + my_road[107].connected[j_mid[107]].left;
                    right_line[i] = my_road[i].connected[j_mid2[i]].right;
                }
                for (int i = upPoint + 4; i >= 2; i--)
                {
                    if (right_line[i] <= right_line[i + 1] &&
                        right_line[i] <= right_line[i + 2] &&
                        right_line[i + 1] - right_line[i] >= 1 &&
                        right_line[i + 2] - right_line[i] >= 1)
                    {
                        for (int j = i; j >= 2; j--)
                        {
                            right_line[j] = right_line[i + 1];
                        }
                    }
                }
            }
            else if (upPoint >= 95 && upPoint <= NEAR_LINE) {
                /*
                double k = (double)(right_side[10] - left_line[(NEAR_LINE - 5)]) / (10 - ((NEAR_LINE - 5))) + 0.2;

                for (int i = (NEAR_LINE - 5); i >= 2; i--) {
                    left_line[i] = k * (i - ((NEAR_LINE - 5))) + left_line[(NEAR_LINE - 5)];
                    right_line[i] = my_road[i].connected[j_mid2[i]].right;
                }*/
                uint8_t k1 = 2;
                for (int i = upPoint; i >= 2; i--)
                {
                    if (abs(my_road[i + 1].connected[j_mid2[i + 1]].left - my_road[i].connected[j_mid2[i]].left) > 20) {
                        k1 = i + 1;
                        break;
                    }
                }


                if (k1 < upPoint - 10) k1 = upPoint - 10;
                double k = calculate_slope_uint(k1, upPoint, left_line);
                if (IslandRadius == 50)
                {
                    k = k - 0.5;
                }
                else if (IslandRadius >= 60 && IslandRadius <= 70)
                {
                    k = k - 0.2;
                }
                else if (IslandRadius > 70)
                {
                    k = k - 0.2;
                }
                //if (k > -0.5) k = -1.5;

                for (int i = (NEAR_LINE - 5); i >= 2; i--) {

                    if (k < -0.2)left_line[i] = (k - dkRight) * (i - (upPoint)) + my_road[upPoint].connected[j_mid[upPoint]].right;
                    else left_line[i] = my_road[i].connected[j_mid2[i]].right - 20;
                    right_line[i] = my_road[i].connected[j_mid2[i]].right;
                }
                for (int i = upPoint + 4; i >= 2; i--)
                {
                    if (right_line[i] <= right_line[i + 1] &&
                        right_line[i] <= right_line[i + 2] &&
                        right_line[i + 1] - right_line[i] >= 1 &&
                        right_line[i + 2] - right_line[i] >= 1)
                    {
                        for (int j = i; j >= 2; j--)
                        {
                            right_line[j] = right_line[i + 1];
                        }
                    }
                }
            }
        }


    }
    else if (islandWhere == LEFT) {
        uint8_t j_mid[CAMERA_H];
        uint8_t j_mid2[CAMERA_H];
        for (int i = NEAR_LINE - 1; i >= 2; i--) {
            j_mid[i] = j_continue[i];
            j_mid2[i] = j_continue[i];
            for (int j = 1; j <= my_road[i].white_num; j++) {

                if (abs(my_road[i].connected[j].right - my_road[i + 1].connected[j_mid[i + 1]].right) < abs(my_road[i].connected[j_mid[i]].right - my_road[i + 1].connected[j_mid[i + 1]].right)
                    && my_road[i].connected[j].width > 10) {
                    j_mid[i] = j;

                }
                if (abs(my_road[i].connected[j].left - my_road[i + 1].connected[j_mid2[i + 1]].left) < abs(my_road[i].connected[j_mid2[i]].left - my_road[i + 1].connected[j_mid2[i + 1]].left)
                    && my_road[i].connected[j].width > 10) {
                    j_mid2[i] = j;

                }
            }
        }
        int way = 2;
        if (way == 1) {
            //固定打角
            double k = (double)(10 - (NEAR_LINE - 5)) / (left_side[10] - right_line[(NEAR_LINE - 5)]) + dk;

            for (int i = (NEAR_LINE - 5); i >= 2; i--) {
                right_line[i] = k * (i - (NEAR_LINE - 5)) + right_line[(NEAR_LINE - 5)];
                left_line[i] = left_side[i];
            }
        }
        else if (way == 2) {
            //连接顶点
            int upPoint = 119;
            for (int i = 109; i >= 50; i--) {
                if (my_road[i].connected[j_mid[i]].width < 35 && my_road[i + 2].connected[j_mid[i + 2]].width >= 35
                    && my_road[i - 1].connected[j_mid[i - 1]].width < 35 && my_road[i + 3].connected[j_mid[i + 3]].width >= 35
                    && my_road[i].connected[j_mid[i]].left - my_road[i + 1].connected[j_mid[i + 1]].left > 4
                    && my_road[i].connected[j_mid[i]].left - my_road[i + 2].connected[j_mid[i + 2]].left > 4
                    && abs(my_road[i].connected[j_mid[i]].left - my_road[i - 1].connected[j_mid[i - 1]].left) <= 4
                    && abs(my_road[i].connected[j_mid[i]].left - my_road[i - 2].connected[j_mid[i - 2]].left) <= 4
                    && (my_road[i].connected[j_mid[i]].left!= my_road[i].connected[j_mid2[i]].left || left_line[45] != 0)
                    ) {
                    upPoint = i;
                    break;
                }
            }
//            //printf("up=%d\n", upPoint);
            if (upPoint <= 95 && upPoint > 60 )  {
                double k = (double)(my_road[upPoint].connected[j_mid[upPoint]].left - my_road[107].connected[j_mid[107]].right) / (upPoint - 107);
                if (IslandRadius == 50)
                {
                    k = k + 0.5;
                }
                else if (IslandRadius >= 60 && IslandRadius <= 70)
                {
                    k = k + 0.2;
                }
                else if (IslandRadius > 70)
                {
                    k = k + 0.2;
                }
                for (int i = 107; i >= 2; i--) {
                    right_line[i] = (k + dkLeft) * (i - (107)) + my_road[107].connected[j_mid[107]].right;
                    left_line[i] = my_road[i].connected[j_mid2[i]].left;
                }
                //pxy
                for (int i = upPoint + 4; i >= 2; i--)
                {
                    if (left_line[i] >= left_line[i + 1] &&
                        left_line[i] >= left_line[i + 2] &&
                        left_line[i] - left_line[i + 1] >= 1 &&
                        left_line[i] - left_line[i + 2] >= 1)
                    {
                        for (int j = i; j >= 2; j--)
                        {
                            left_line[j] = left_line[i + 1];
                        }
                    }
                }
                //pxy

            }
            else if (upPoint >= 95 && upPoint != 119) {

                uint8_t k1 = 2;
                for (int i = upPoint; i >= 2; i--)
                {
                    if (abs(my_road[i - 1].connected[j_mid2[i - 1]].right - my_road[i].connected[j_mid2[i]].right) > 10) {
                        k1 = i;
                        break;
                    }
                    right_line[i] = my_road[i].connected[j_mid2[i]].right;
                    ////////printf("%d\n", right_line[i]);
                }
                if (k1 >= upPoint - 5) {
                    for (int i = (NEAR_LINE - 5); i >= 50; i--)
                    {
                        left_line[i] = left_side[i];
                        right_line[i] = left_side[i] + my_road[upPoint].connected[j_mid[upPoint]].left - left_side[upPoint];
                    }
                }
                else {
                    if (k1 < upPoint - 10) k1 = upPoint - 10;
                    double k = calculate_slope_uint(k1, upPoint, right_line);
                    if (IslandRadius == 50)
                    {
                        k = k + 0.5;
                    }
                    else if (IslandRadius >= 60 && IslandRadius <= 70)
                    {
                        k = k + 0.2;
                    }
                    else if (IslandRadius > 70)
                    {
                        k = k + 0.2;
                    }
                    if (k > 0.2)
                    {
                        for (int i = (NEAR_LINE - 5); i >= 2; i--) {
                            right_line[i] = (k + dkLeft) * (i - (upPoint)) + my_road[upPoint].connected[j_mid[upPoint]].left;
                            left_line[i] = my_road[i].connected[j_mid2[i]].left;
                        }
                    }
                    else {
                        for (int i = (NEAR_LINE - 5); i >= 2; i--) {
                            left_line[i] = left_side[i];
                            right_line[i] = left_side[i] + my_road[upPoint].connected[j_mid[upPoint]].left - left_side[upPoint];
                        }
                    }

                    for (int i = upPoint + 4; i >= 2; i--)
                    {
                        if (left_line[i] >= left_line[i + 1] &&
                            left_line[i] >= left_line[i + 2] &&
                            left_line[i] - left_line[i + 1] >= 1 &&
                            left_line[i] - left_line[i + 2] >= 1)
                        {
                            for (int j = i; j >= 2; j--)
                            {
                                left_line[j] = left_line[i + 1];
                            }
                        }
                    }
                    //pxy
                }
            }
        }
    }

}
//////////////////////////////////////////////
////功能：大角度弯道修正
////输入：
////输出：
////备注：
/////////////////////////////////////////////
void roof(void)
{
    uint8_t i, i_start, i_end;
    uint8_t my_roof = MISS, Ldir = 0, Rdir = 0;
    uint8_t max_width = 0, max_width_num = 0;
    uint8_t roof_line = 1;

    //寻找第一个非miss行
    for (i = 1; i <= 90; i++)
    {
        if (left_line[i] != MISS || right_line[i] != MISS)
        {
            roof_line = i;
            break;
        }
    }
    if (roof_line <= 60)
    {
        return;
    }

    //printf("roof line:%d\n", roof_line);
    uint8_t left_min = 255, left_min_line = 119;
    uint8_t right_min = 255, right_min_line = 119;
    if (state == stateIslandCircle || state == stateTIn) {
        for (int i = roof_line; i <= roof_line + 20; i++) {
            if (right_line[i] - left_line[i] > 23) {
                left_min_line = i;
                break;
            }
        }
        for (int i = roof_line; i <= left_min_line; i++) {
            left_line[i] = MISS;
        }

    }

    //printf("圆弧顶修正: 左%d %d  右%d %d\n", left_min, left_min_line, right_min, right_min_line);
}
////////////////////////////////////////////
//功能：环岛弯道
//输入：
//输出：
//备注：
///////////////////////////////////////////
void island_circle() {
    if (islandWhere == RIGHT) {
        uint8_t j_mid[CAMERA_H];
        for (int i = NEAR_LINE; i >= 2; i--) {
            j_mid[i] = j_continue[i];
            for (int j = 1; j <= my_road[i].white_num; j++) {
                if (abs(my_road[i].connected[j].left - my_road[i + 1].connected[j_mid[i + 1]].left) < abs(my_road[i].connected[j_mid[i]].left - my_road[i + 1].connected[j_mid[i + 1]].left)
                    && my_road[i].connected[j].width > 15) {
                    j_mid[i] = j;

                }

            }
        }
        if (my_road[35].connected[j_mid[35]].width < 35) {
            int upPoint = 119;
            for (int i = 110; i >= 50; i++) {
                if (my_road[i].connected[j_mid[i]].width < 35 && my_road[i + 2].connected[j_mid[i + 2]].width >= 35
                    && my_road[i - 1].connected[j_mid[i - 1]].width < 40 && my_road[i + 3].connected[j_mid[i + 3]].width >= 35
                    && my_road[i].connected[j_mid[i]].right - my_road[i + 1].connected[j_mid[i + 1]].right < -2) {
                    upPoint = i;
                    break;
                }
            }

            if (100 <= upPoint && upPoint <= NEAR_LINE && my_road[upPoint].connected[j_mid[upPoint]].right < 94) {
                state = stateIslandCircle;

            }

        }


    }
    else if (islandWhere == LEFT) {
        uint8_t j_mid[CAMERA_H];
        for (int i = NEAR_LINE; i >= 2; i--) {
            j_mid[i] = j_continue[i];
            for (int j = 1; j <= my_road[i].white_num; j++) {
                if (abs(my_road[i].connected[j].right - my_road[i + 1].connected[j_mid[i + 1]].right) < abs(my_road[i].connected[j_mid[i]].right - my_road[i + 1].connected[j_mid[i + 1]].right)
                    && my_road[i].connected[j].width > 15) {
                    j_mid[i] = j;

                }

            }
        }

        if (1) {
            int upPoint = 119;
            for (int i = 110; i >= 50; i--) {
                if (my_road[i].connected[j_mid[i]].width < 35 && my_road[i + 2].connected[j_mid[i + 2]].width >= 35
                    && my_road[i - 1].connected[j_mid[i - 1]].width < 35 && my_road[i + 3].connected[j_mid[i + 3]].width >= 35
                    && my_road[i].connected[j_mid[i]].left - my_road[i + 1].connected[j_mid[i + 1]].left > 2) {
                    upPoint = i;
                    break;
                }
            }

            if (100 <= upPoint && upPoint <= NEAR_LINE && my_road[upPoint].connected[j_mid[upPoint]].left > 94) {
                state = stateIslandCircle;
            }

        }


    }
    if (my_road[68].white_num == 0 ) {
        state = stateIslandCircle;
    }

}
////////////////////////////////////////////
//功能：环岛弯道
//输入：
//输出：
//备注：
///////////////////////////////////////////
void design_island_circle(){
    if(islandWhere == LEFT){
        uint8_t j_mid[CAMERA_H];
            j_mid[NEAR_LINE] = j_continue[NEAR_LINE];
            for (int i = NEAR_LINE - 1; i >= 2; i--) {
                j_mid[i] = j_continue[i];
                for (int j = 1; j <= my_road[i].white_num; j++) {
                    if (abs(my_road[i].connected[j].left - my_road[i + 1].connected[j_mid[i + 1]].left) < abs(my_road[i].connected[j_mid[i]].left - my_road[i + 1].connected[j_mid[i + 1]].left)
                            && my_road[i].connected[j].width > 15) {
                        j_mid[i] = j;
                        //  break;
                    }

                }
                left_line[i] = my_road[i].connected[j_mid[i]].left;
                right_line[i] = my_road[i].connected[j_mid[i]].right;
            }
    }else if(islandWhere == RIGHT){
        uint8_t j_mid[CAMERA_H];
        j_mid[NEAR_LINE] = j_continue[NEAR_LINE];
        for (int i = NEAR_LINE - 1; i >= 2; i--) {
            j_mid[i] = j_continue[i];
            for (int j = 1; j <= my_road[i].white_num; j++) {
                if (abs(my_road[i].connected[j].right - my_road[i + 1].connected[j_mid[i + 1]].right) < abs(my_road[i].connected[j_mid[i]].right - my_road[i + 1].connected[j_mid[i + 1]].right)
                        && my_road[i].connected[j].width > 15) {
                    j_mid[i] = j;

                }
            }
            left_line[i] = my_road[i].connected[j_mid[i]].left;
            right_line[i] = my_road[i].connected[j_mid[i]].right;
        }
    }

    int i=NEAR_LINE;
    int distance = 0;
    int dis = 30;
    if(IslandRadius == 70){
        dis = 28;
    }
    else if(IslandRadius == 50)
    {
        dis = 30;
    }
    else if(IslandRadius == 100)
    {
        dis = 27;
    }
    int a;
    while(i>=1 && left_line[i] != MISS){
        if(islandWhere == LEFT){
            a = (int)right_line[i] - dis - distance;
          if(a<0){
              left_line[i]=0;
          }else{
              left_line[i]=a;
          }

            //  right_line[i] = left_line[i] + 30;
        }else if(islandWhere == RIGHT){
           a= (int)left_line[i] + dis + distance;
           if(a>188){
               right_line[i]=188;
           }else{
               right_line[i]=a;
           }
          // left_line[i] = right_line[i] - 30;
        }

        i--;
    }

}


////////////////////////////////////////////
//功能：出环岛拐弯
//输入：
//输出：
//备注：
///////////////////////////////////////////
void island_out() {
    int dxRight = islandParam4.intVal, dxLeft = islandParam3.intVal;
    if (my_road[65].white_num!=0 && left_line[65] != MISS) {
        if (islandWhere == RIGHT) {

            int xMax = 0;
            int yMax = NEAR_LINE;
            int start = NEAR_LINE;
            while (start >= 50 && left_line[start] >= left_line[NEAR_LINE] - 10) {
                if (my_road[start - 1].white_num != 0) {
                    if (left_line[start] >= xMax - 1) {
                        xMax = left_line[start];
                        yMax = start;
                    }
                }
                else {
                    break;
                }
                start--;
            }

             int xmax = 100;
             if(IslandRadius == 70){
               xmax = 108;
           }
           else if(IslandRadius == 50)
           {
               xmax = 98;
           }
           else if(IslandRadius == 100)
           {
               xmax = 96;
           }
        //   //////printf("y=%d,x=%d\n", yMax, xMax);
            // //////printf("xMax=%d,y=%d\n", xMax,yMax);d
            if (left_line[yMax - 15] != MISS && (calculate_slope_uint(yMax - 18, yMax - 1, left_line) * calculate_slope_uint(yMax + 2, yMax + 18, left_line) < 0 || left_line[yMax] - left_line[yMax - 3] > 6)) {
                if ((xMax < xmax - dxRight && yMax >= 40 && yMax <= 100) || (xMax < xmax - dxRight - 5 && yMax >= 100 && yMax <= 110)) {
                state = stateIslandOut;
                }
            }

        }
        else if (islandWhere == LEFT) {
            int xMin = 188;
            int yMin = 100;
            int start = NEAR_LINE;
            while (start >= 50 && right_line[start] <= right_line[NEAR_LINE] + 10) {
                if (my_road[start - 1].white_num != 0) {
                    if (right_line[start] <= xMin + 1) {
                        xMin = right_line[start];
                        yMin = start;
                    }
                }
                else {
                    break;
                }
                start--;
            }
        //  //////printf("yMin=%d,xMin=%d\n", yMin, xMin);
            /*for (int i = NEAR_LINE; i >= 20; i--) {
                if (my_road[i - 1].white_num != 0) {
                    if (right_line[i] <= xMin) {
                        xMin = right_line[i];
                        yMin = i;
                    }
                }
                else {
                    break;
                }
            }*/

            int xmin = 100;
             if(IslandRadius == 70){
                xmin = 90;
            }
            else if(IslandRadius == 50)
            {
                xmin = 94;
            }
            else if(IslandRadius == 100)
            {
                xmin = 95;
            }
        //  //////printf("y=%d\n", yMin);
            if (left_line[yMin - 15]!=MISS && (calculate_slope_uint(yMin - 18, yMin - 1, right_line) * calculate_slope_uint(yMin + 2, yMin + 18, right_line) < 0 || right_line[yMin] - right_line[yMin - 3] < -6)) {
                if ((xMin > xmin + dxLeft && yMin >= 40 && yMin <= 100 )|| (xMin > xmin + dxLeft + 5 && yMin >= 100 && yMin <= 110)) {
                    state = stateIslandOut;
                }
            }
        }
    }
}


////////////////////////////////////////////
//功能：出环岛补线
//输入：
//输出：
//备注：
///////////////////////////////////////////
void design_island_out() {
    double dk = islandParam5.floatVal;
//    dk = islandParam5.floatVal;
    if (islandWhere == RIGHT) {
        int up = 10;
        if(IslandRadius == 70){
            up = 5;
        }
        else if(IslandRadius == 50)
        {
            up = 8;
        }
        else if(IslandRadius == 100)
        {
            up = 3;
        }


        int xMax = 0;
        int yMax = NEAR_LINE;
        int start = NEAR_LINE;
        if (left_line[NEAR_LINE] != left_side[NEAR_LINE]) {

            while (start >= 50 && left_line[start] >= left_line[NEAR_LINE] - 10) {
                if (my_road[start - 1].white_num != 0) {
                    if (left_line[start] >= xMax) {
                        xMax = left_line[start];
                        yMax = start;
                    }
                }
                else {
                    break;
                }
                start--;
            }
        }

        if (yMax <= 105) {
            double k = (double)(right_side[up] - left_line[yMax]) / (up - yMax);
//            if(IslandRadius == 70){
//                k = k + 0.6;
//            }
//            else if(IslandRadius == 50)
//            {
//                k = k + 0.6;
//            }
//            else if(IslandRadius == 100)
//            {
//                k = k + 0.2;
//            }
            for (int i = NEAR_LINE - 1; i >= 2; i--) {
                if (i <= yMax) {
                    left_line[i] = (k - dk) * (i - NEAR_LINE) + left_line[NEAR_LINE];
                }
                if (right_line[i + 1] == right_side[i + 1]) {
                    right_line[i] = right_side[i];
                }
                //right_line[i] = right_side[i];
            }
        }
        else {
            double k = (double)(right_side[up] - left_line[NEAR_LINE]) / (up - NEAR_LINE);
//            if(IslandRadius == 70){
//                k = k + 0.2;
//            }
//            else if(IslandRadius == 50)
//            {
//                k = k + 0.4;
//            }
//            else if(IslandRadius == 100)
//            {
//                k = k + 0.2;
//            }
            for (int i = NEAR_LINE - 1; i >= 2; i--) {
                left_line[i] = (k - dk) * (i - NEAR_LINE) + left_line[NEAR_LINE];

                if (right_line[i + 1] == right_side[i + 1]) {
                    right_line[i] = right_side[i];
                }
                else {
                    if (right_line[i] < right_line[i + 1]) {
                        right_line[i] = right_line[i + 1];
                    }
                }
                        //right_line[i] = right_side[i];
            }
        }



    }
    else if (islandWhere == LEFT) {
        int up = 10;
        if(IslandRadius == 70){
            up = 5;
        }
        else if(IslandRadius == 50)
        {
            up = 8;
        }
        else if(IslandRadius == 100)
        {
            up = 3;
        }


        int xMin = 188;
        int yMin = 110;
        int start = 110;
        if (right_line[NEAR_LINE] != right_side[NEAR_LINE]) {
            while (start >= 50 && right_line[start] <= right_line[NEAR_LINE] + 10) {
                if (my_road[start - 1].white_num != 0) {
                    if (right_line[start] <= xMin) {
                        xMin = right_line[start];
                        yMin = start;
                    }
                }
                else {
                    break;
                }
                start--;
            }
        }

//                    ////////printf("ym=%d\n", yMin);
        if (yMin <= 105) {
            double k = (double)(left_side[up] - right_line[yMin]) / (up - yMin);
//            if(IslandRadius == 70){
//                k = k - 0.3;
//            }
//            else if(IslandRadius == 50)
//            {
//                k = k - 0.2;
//            }
//            else if(IslandRadius == 100)
//            {
//                k = k - 0.1;
//            }
            for (int i = NEAR_LINE - 1; i >= 2; i--) {
                if (i <= yMin) {
                    right_line[i] = (k + dk) * (i - yMin) + right_line[yMin];
                }
                //left_line[i] = left_side[i];
                if (left_line[i + 1] == left_side[i + 1]) {
                    left_line[i] = left_side[i];
                }
            }
        }
        else {
            double k = (double)(left_side[up] - right_line[NEAR_LINE]) / (up - NEAR_LINE);
//            if(IslandRadius == 70){
//                k = k - 0.3;
//            }
//            else if(IslandRadius == 50)
//            {
//                k = k - 0.2;
//            }
//            else if(IslandRadius == 100)
//            {
//                k = k - 0.1;
//            }
            for (int i = NEAR_LINE - 1; i >= 2; i--) {
                right_line[i] = (k + dk) * (i - NEAR_LINE) + right_line[NEAR_LINE];
                //left_line[i] = left_side[i];
                if (left_line[i + 1] == left_side[i + 1]) {
                    left_line[i] = left_side[i];
                }
                else {
                    if (left_line[i] > left_line[i + 1]) {
                        left_line[i] = left_line[i + 1];
                    }
                }
            }
        }

    }


}


////////////////////////////////////////////
//功能：出环岛直线
//输入：
//输出：
//备注：
///////////////////////////////////////////
void island_straight() {
    int flag = 0;
    if (my_road[40].white_num != 0) {
        if (islandWhere == RIGHT) {
            ////printf("jl=%f\n", linear_judgement(70, 90, left_line));
//            test_varible[14] = calculate_slope_uint(50, 70, left_line);
//            test_varible[15] = calculate_slope_uint(80, 100, left_line);
//            test_varible[4] = calculate_slope_uint(50, 70, left_line);
//            test_varible[5] = calculate_slope_uint(80, 100, left_line);
//
//            test_varible[6] = linear_judgement(70, 90, left_line);
            if (calculate_slope_uint(50, 70, left_line) > -1 && calculate_slope_uint(80, 100, left_line) > -1
                && calculate_slope_uint(50, 70, left_line) <= 0 && calculate_slope_uint(80, 100, left_line) <= 0
                && linear_judgement(70, 90, left_line) < 100 ) {
                flag = 1;
            }

            if (fabs(calculate_slope_uint(50, 70, left_line) - calculate_slope_uint(80, 100, left_line)) > 0.2
                ) {
                flag = 0;
            }

        }
        else if (islandWhere == LEFT) {


            if (calculate_slope_uint(50, 70, right_line) < 1 && calculate_slope_uint(80, 100, right_line) < 1
                && calculate_slope_uint(50, 70, right_line) >= 0 && calculate_slope_uint(80, 100, right_line) >= 0
                && linear_judgement(70, 90, right_line) < 100) {
                flag = 1;
            }
            if (fabs(calculate_slope_uint(50, 70, right_line) - calculate_slope_uint(80, 100, right_line)) > 0.2
                ) {
                flag = 0;
            }
        }
    }


    if (flag == 1) {
        state = stateIslandFinal;
        islandFinalTimes += 1;
    }
}




////////////////////////////////////////////
//功能：出环岛直线补线
//输入：
//输出：
//备注：
///////////////////////////////////////////
void design_island_straight() {
    if (islandWhere == RIGHT) {

        int leftRoad[CAMERA_H];
        uint8_t j_mid[CAMERA_H];
        for (int i = NEAR_LINE; i >= 2; i--) {
            j_mid[i] = j_continue[i];
            for (int j = 1; j <= my_road[i].white_num; j++) {
                if (abs(my_road[i].connected[j].left - my_road[i + 1].connected[j_mid[i + 1]].left) < abs(my_road[i].connected[j_mid[i]].left - my_road[i + 1].connected[j_mid[i + 1]].left)
                    && my_road[i].connected[j].width > 15) {
                    j_mid[i] = j;
                    //  break;
                }

            }
            leftRoad[i] = my_road[i].connected[j_mid[i]].left;
        }
        uint8_t xMin = right_line[110], yMin = 110;
        for (int i = 105; i > 50; i--) {
            if (xMin >= right_line[i]) {
                yMin = i;
                xMin = my_road[i].connected[j_mid[i]].right;
            }
        }

        double k = calculate_slope(80, 100, leftRoad);

        for (int i = 110; i >= 50; i--) {

            right_line[i] = leftRoad[i] + 26;
            left_line[i] = leftRoad[i];
        }
    }
    else if (islandWhere == LEFT) {
        uint8_t j_mid[CAMERA_H];
        int rightRoad[CAMERA_H];
        for (int i = NEAR_LINE; i >= 2; i--) {
            j_mid[i] = j_continue[i];
            for (int j = 1; j <= my_road[i].white_num; j++) {
                if (abs(my_road[i].connected[j].right - my_road[i + 1].connected[j_mid[i + 1]].right) < abs(my_road[i].connected[j_mid[i]].right - my_road[i + 1].connected[j_mid[i + 1]].right)
                    && my_road[i].connected[j].width > 15) {
                    j_mid[i] = j;
                    //  break;
                }
            }
            rightRoad[i] = my_road[i].connected[j_mid[i]].right;
        }

        uint8_t xMin = left_line[105], yMin = 105;
        for (int i = 105; i > 50; i--) {
            if (xMin <= left_line[i]) {
                yMin = i;

                xMin = my_road[i].connected[j_mid[i]].left;
            }
            if (my_road[i - 1].white_num == 0) {
                break;
            }
        }

        double k = calculate_slope(80, 100, rightRoad);

        for (int i = 110; i >= 50; i--) {
            left_line[i] = rightRoad[i] - 26;
            right_line[i] = rightRoad[i];
        }
    }
}

////////////////////////////////////////////
//功能：结束环岛
//输入：
//输出：
//备注：
///////////////////////////////////////////
void island_final() {

    int sumD = 0;
    for (int i = NEAR_LINE; i >= 100; i--) {
        if (right_line[i] - left_line[i] > 31) {
            sumD++;
        }
    }
    int sumU = 0;
    for (int i = 105; i >= 90; i--) {
        if (right_line[i] - left_line[i] < 35) {
            sumU++;
        }
    }
    if (sumD > 4 && sumU > 6) {
        if (islandWhere == RIGHT) {
            if (fabs(calculate_slope_uint(80, 100, left_line) - calculate_slope_uint(80, 100, right_line)) < 0.25
                    && calculate_slope_uint(85, 105, left_line) > -0.7) {
                flagIT = islandWhere * state;
                state = stateStart;
                islandWhere = 0;
                if(islandTimesCNT < 2)
                {
                    islandTimesCNT += 1; //110结束 彻底出环岛后次数加一 与islandTimes不一样
                }
            }
        }
        else if (islandWhere == LEFT) {
            if (fabs(calculate_slope_uint(85, 100, left_line) - calculate_slope_uint(85, 100, right_line)) < 0.25
                    && calculate_slope_uint(85, 105, right_line) < 0.7) {
                flagIT = islandWhere * state;
                state = stateStart;
                islandWhere = 0;
                if(islandTimesCNT < 2)
                {
                    islandTimesCNT += 1;
                }
            }
        }
    }
}

////////////////////////////////////////////
//功能：入T字口结束
//输入：
//输出：
//备注：
///////////////////////////////////////////
void cross_T_in_over() {

    //猜想，如果顶端没有白条，是不是可以认为已经路过路口？跑车考证这个想法
    if (my_road[20].white_num == 0) {
        state = stateStart;
        TFlag = 1;
    }
    else if (my_road[10].white_num != 0) {
        if (TWhere == RIGHT) {
            uint8_t j_mid[CAMERA_H];
            for (int i = NEAR_LINE; i >= 2; i--) {
                j_mid[i] = j_continue[i];
                for (int j = 1; j <= my_road[i].white_num; j++) {
                    if (abs(my_road[i].connected[j].left - my_road[i + 1].connected[j_mid[i + 1]].left) < abs(my_road[i].connected[j_mid[i]].left - my_road[i + 1].connected[j_mid[i + 1]].left)
                        && my_road[i].connected[j].width > 15) {
                        j_mid[i] = j;
                        //  break;
                    }

                }
            }

            if (my_road[70].connected[j_mid[70]].width < 35) {
                //寻找拐点
                int upPoint = 119;
                if (calculate_slope_struct(90, 105, j_mid, LEFT) < 0) {
                    int num = 70;
                    upPoint = num;
                    while (num <= 110 && my_road[num].connected[j_mid[num]].right <= right_side[num] - 1) {
                        if (my_road[num].connected[j_mid[num]].right <= my_road[upPoint].connected[j_mid[upPoint]].right + 1
                            ) {
                            upPoint = num;
                        }
                        num++;
                    }


                }
                else {
                    int start = 70;

                    for (int i = start; i <= 110; i++) {
                        if (my_road[i + 1].connected[j_mid[i + 1]].right - my_road[i].connected[j_mid[i]].right > 4
                            && abs(my_road[i - 1].connected[j_mid[i - 1]].right - my_road[i].connected[j_mid[i]].right) <= 2
                            && my_road[i].connected[j_mid[i]].width < 35
                            && my_road[i - 1].connected[j_mid[i - 1]].width < 35
                            ) {
                            upPoint = i;
                            break;
                        }
                    }
                }

                if (80 <= upPoint && upPoint <= 110 && my_road[upPoint + 2].connected[j_mid[upPoint + 2]].width > 36
                    ) {
                    state = stateStart;
                   // TFlag = 1;
                }
            }

        }
        else if (TWhere == LEFT) {
            uint8_t j_mid[CAMERA_H];
            for (int i = NEAR_LINE; i >= 2; i--) {
                j_mid[i] = j_continue[i];
                for (int j = 1; j <= my_road[i].white_num; j++) {
                    if (abs(my_road[i].connected[j].right - my_road[i + 1].connected[j_mid[i + 1]].right) < abs(my_road[i].connected[j_mid[i]].right - my_road[i + 1].connected[j_mid[i + 1]].right)
                        && my_road[i].connected[j].width > 15) {
                        j_mid[i] = j;

                    }
                }
            }

            if (my_road[70].connected[j_mid[70]].width < 35) {

                int upPoint = 119;
                if (calculate_slope_struct(90, 105, j_mid, RIGHT) >= 0) {
                    int num = 70;
                    upPoint = num;
                    while (num <= 110 && my_road[num].connected[j_mid[num]].left >= left_side[num] + 1) {
                        if (my_road[num].connected[j_mid[num]].left >= my_road[upPoint].connected[j_mid[upPoint]].left - 1
                            ) {
                            upPoint = num;
                        }
                        num++;
                    }

                }
                else {
                    int start = 70;
                    for (int i = start; i <= 110; i++) {
                        if (my_road[i + 1].connected[j_mid[i + 1]].left - my_road[i].connected[j_mid[i]].left < -4
                            && abs(my_road[i - 1].connected[j_mid[i - 1]].right - my_road[i].connected[j_mid[i]].right) <= 2
                            && my_road[i].connected[j_mid[i]].width < 35
                            && my_road[i - 1].connected[j_mid[i - 1]].width < 35
                            ) {
                            upPoint = i;
                            break;
                        }
                    }
                }
                if (80 <= upPoint && upPoint <= 110 && my_road[upPoint + 2].connected[j_mid[upPoint + 2]].width > 36
                    ) {
                    state = stateStart;
                  //  TFlag = 1;
                }
            }

        }


    }

}

////////////////////////////////////////////
//功能：出T字口开始
//输入：
//输出：
//备注：
///////////////////////////////////////////
void cross_T_out_start() {

    if (TWhere == RIGHT) {
        int xMax = 0;
        int yMax = 100;
        double k = calculate_slope_uint(90, 105, left_line);
        //////////printf("k=%f\n", k);
        if (fabs(k) < 0.12) {
            if (my_road[70].white_num != 0) {
                int leftDownPoint = 119;
                int rightDownPoint = 119;
                for (int i = NEAR_LINE - 1; i >= 60; i--) {
                    if (my_road[i - 2].white_num != 0) {

                        if (left_line[i - 1] - left_line[i] < -4 && left_line[i - 2] - left_line[i] < -4
                            && abs(left_line[i + 1] - left_line[i]) <= 2 && abs(left_line[i + 2] - left_line[i]) <= 2
                            && right_line[i - 4] - left_line[i - 4] > right_line[i] - left_line[i] + 5
                            && left_line[i] - left_side[i] > 2
                            ) {
                            leftDownPoint = i;
                            break;
                        }

                    }
                    else {
                        break;
                    }
                }
                for (int i = NEAR_LINE - 1; i >= 60; i--) {
                    if (my_road[i - 2].white_num != 0) {
                        if (right_line[i - 1] - right_line[i] > 4 && right_line[i - 2] - right_line[i] > 4
                            && abs(right_line[i + 1] - right_line[i]) <= 2 && abs(right_line[i + 2] - right_line[i]) <= 2
                            && right_line[i - 4] - left_line[i - 4] > right_line[i] - left_line[i] + 5
                            && right_line[i] - right_side[i] < -2
                            ) {
                            rightDownPoint = i;
                            break;
                        }

                    }
                    else {
                        break;
                    }
                }

                if (abs(leftDownPoint - rightDownPoint) <= 6
                    && fabs(calculate_slope_uint(leftDownPoint + 1, leftDownPoint + 14, left_line) - calculate_slope_uint(rightDownPoint + 1, rightDownPoint + 14, right_line)) < 0.2
                    && fabs(calculate_slope_uint(leftDownPoint + 1, leftDownPoint + 14, left_line) - k) < 0.2
                    && fabs(calculate_slope_uint(rightDownPoint + 1, rightDownPoint + 14, right_line) - k) < 0.2
                    ) {
                    yMax = leftDownPoint;
                    xMax = left_line[leftDownPoint];

                    if (yMax < 100 && yMax >= 50) {
                        state = stateTOut;
                    }
                }
            }
        }
        else {
            if (my_road[60].white_num != 0) {

                for (int i = NEAR_LINE; i >= 50; i--) {
                    if (my_road[i - 1].white_num != 0) {
                        if (left_line[i] >= xMax && abs(left_line[i - 1] - left_line[i]) < 4 && abs(left_line[i + 1] - left_line[i]) < 4
                            && right_line[i] - left_line[i] > 40
                            ) {
                            xMax = left_line[i];
                            yMax = i;
                        }
                    }
                    else {
                        break;
                    }
                }
                int flag = 1;
                for (int i = yMax; i >= yMax - 18; i--) {
                    if (my_road[i].white_num == 0) {
                        flag = 0;
                    }
                }
                if (flag == 1) {
                    int change = 119;
                    for (int i = 110; i > yMax; i--) {
                        if (right_line[i - 2] - right_line[i] > 4 && abs(right_line[i] - right_line[i + 1]) <= 2 && abs(right_line[i] - right_line[i + 2]) <= 2
                            ) {
                            change = i;
                        }
                    }

                    if (calculate_slope_uint(yMax - 18, yMax - 1, left_line) * calculate_slope_uint(yMax + 2, yMax + 18, left_line) < 0) {
                        if (xMax < 94 - cross_circle_param2.intVal && yMax >= 80 && yMax <= 110
                            && change >= yMax && right_line[change - 2] - left_line[change - 2] > 25) {
                            state = stateTOut;
                        }
                    }
                }

            }
        }


    }
    else if (TWhere == LEFT) {
        int xMin = 188;
        int yMin = 100;

        double k = calculate_slope_uint(90, 105, right_line);
        if (fabs(k) < 0.12) {
            if (my_road[70].white_num != 0) {
                int leftDownPoint = 119;
                int rightDownPoint = 119;
                for (int i = NEAR_LINE - 1; i >= 60; i--) {
                    if (my_road[i - 2].white_num != 0) {

                        if (left_line[i - 1] - left_line[i] < -4 && left_line[i - 2] - left_line[i] < -4
                            && abs(left_line[i + 1] - left_line[i]) <= 2 && abs(left_line[i + 2] - left_line[i]) <= 2
                            && right_line[i - 4] - left_line[i - 4] > right_line[i] - left_line[i] + 5
                            && left_line[i] - left_side[i] > 2
                            ) {
                            leftDownPoint = i;
                            break;
                        }

                    }
                    else {
                        break;
                    }
                }
                for (int i = NEAR_LINE - 1; i >= 60; i--) {
                    if (my_road[i - 2].white_num != 0) {
                        if (right_line[i - 1] - right_line[i] > 4 && right_line[i - 2] - right_line[i] < -4
                            && abs(right_line[i + 1] - right_line[i]) <= 2 && abs(right_line[i + 2] - right_line[i]) <= 2
                            && right_line[i - 4] - left_line[i - 4] > right_line[i] - left_line[i] + 5
                            && right_line[i] - right_side[i] < -2
                            ) {
                            rightDownPoint = i;
                            break;
                        }

                    }
                    else {
                        break;
                    }
                }

                if (abs(leftDownPoint - rightDownPoint) <= 4
                    && fabs(calculate_slope_uint(leftDownPoint + 1, leftDownPoint + 14, left_line) - calculate_slope_uint(rightDownPoint + 1, rightDownPoint + 14, right_line)) < 0.2
                    && fabs(calculate_slope_uint(leftDownPoint + 1, leftDownPoint + 14, left_line) - k) < 0.2
                    && fabs(calculate_slope_uint(rightDownPoint + 1, rightDownPoint + 14, right_line) - k) < 0.2
                    ) {
                    yMin = rightDownPoint;
                    xMin = right_line[leftDownPoint];

                    if (yMin < 100 && yMin >= 50) {
                        state = stateTOut;
                    }
                }
            }
        }
        else {
            for (int i = NEAR_LINE; i >= 20; i--) {
                if (my_road[i - 1].white_num != 0) {
                    if (right_line[i] <= xMin) {
                        xMin = right_line[i];
                        yMin = i;
                    }
                }
                else {
                    break;
                }
            }
            int flag = 1;
            for (int i = yMin; i >= yMin - 18; i--) {
                if (my_road[i].white_num == 0) {
                    flag = 0;
                }
            }
            if (flag == 1) {
                int change = 119;
                for (int i = 110; i > yMin; i--) {
                    if (left_line[i - 2] - left_line[i] < -4 && abs(left_line[i] - left_line[i + 1]) <= 2 && abs(left_line[i] - left_line[i + 2]) <= 2
                        ) {
                        change = i;
                    }
                }
                //  ////////printf("x=%d,y=%d\n", xMin, yMin);
                if (calculate_slope_uint(yMin - 18, yMin - 1, right_line) * calculate_slope_uint(yMin + 2, yMin + 18, right_line) < 0) {
                    if (xMin >= 96 + cross_circle_param3.intVal && yMin >= 70 && yMin <= 110
                        && right_line[change - 2] - left_line[change - 2] > 25) {
                        state = stateTOut;
                    }
                }
            }

        }
    }

    //if (my_road[60].white_num != 0) {
    //  if (TWhere == RIGHT) {

    //      int xMax = 0;
    //      int yMax = 100;

    //      for (int i = NEAR_LINE; i >= 50; i--) {
    //          if (my_road[i - 1].white_num != 0) {
    //              if (left_line[i] >= xMax && abs(left_line[i - 1] - left_line[i]) < 4 && abs(left_line[i + 1] - left_line[i]) < 4
    //                  && right_line[i] - left_line[i] > 40
    //                  ) {
    //                  xMax = left_line[i];
    //                  yMax = i;
    //              }
    //          }
    //          else {
    //              break;
    //          }
    //      }
    //      int change = 119;
    //      for (int i = 110; i > yMax; i--) {
    //          if (right_line[i - 2] - right_line[i] > 4 && abs(right_line[i] - right_line[i + 1]) <= 2 && abs(right_line[i] - right_line[i + 2]) <= 2
    //              ) {
    //              change = i;
    //          }
    //      }

    //      if (calculate_slope_uint(yMax - 18, yMax - 1, left_line) * calculate_slope_uint(yMax + 2, yMax + 18, left_line) < 0) {
    //          if (xMax < 94 && yMax >= 80 && yMax <= 110
    //              && change >= yMax && right_line[change - 2] - left_line[change - 2] > 25) {
    //              state = stateTOut;
    //          }
    //      }

    //  }
    //  else if (TWhere == LEFT) {
    //      int xMin = 188;
    //      int yMin = 100;

    //      for (int i = NEAR_LINE; i >= 20; i--) {
    //          if (my_road[i - 1].white_num != 0) {
    //              if (right_line[i] <= xMin) {
    //                  xMin = right_line[i];
    //                  yMin = i;
    //              }
    //          }
    //          else {
    //              break;
    //          }
    //      }
    //      int change = 119;
    //      for (int i = 110; i > yMin; i--) {
    //          if (left_line[i - 2] - left_line[i] < -4 && abs(left_line[i] - left_line[i + 1]) <= 2 && abs(left_line[i] - left_line[i + 2]) <= 2
    //              ) {
    //              change = i;
    //          }
    //      }
    //  //  ////////printf("x=%d,y=%d\n", xMin, yMin);
    //      if (calculate_slope_uint(yMin - 18, yMin - 1, right_line) * calculate_slope_uint(yMin + 2, yMin + 18, right_line) < 0) {
    //          if (xMin >= 94 && yMin >= 80 && yMin <= 110
    //              && right_line[change - 2] - left_line[change - 2] > 25) {
    //              state = stateTOut;
    //          }
    //      }
    //  }
    //}
}


////////////////////////////////////////////
//功能：出T字口补线
//输入：
//输出：
//备注：
///////////////////////////////////////////
void design_cross_T_out() {
    double dk = 0;
    int lookahead_line = 85;
    if (TWhere == RIGHT) {
        int leftPoint = 119;
        int rightPoint = 119;
        int mid[CAMERA_H];
        for (int i = NEAR_LINE; i >= 100; i--) {
            mid[i] = (left_line[i] + right_line[i]) / 2;
        }

        double kMid = calculate_slope(100, 113, mid);
        int direction;
        double kRange = 0.15;
        if (fabs(kMid) <= kRange) {
            direction = 0;
        }
        else if (kMid > kRange) {
            direction = LEFT;
        }
        else if (kMid < -1 * kRange) {
            direction = RIGHT;
        }

        for (int i = 99; i >= 1; i--) {
            mid[i] = kMid * (i - 100) + mid[100];
            if (mid[i] <= left_side[i]) {
                mid[i] = left_side[i];
            }
            if (mid[i] >= right_line[i]) {
                mid[i] = right_side[i];
            }
            //IMG[i][mid[i]] = purple;
        }



        uint8_t j_mid[CAMERA_H];

        for (int i = NEAR_LINE; i >= 1; i--) {
            j_mid[i] = j_continue[i];
            for (int j = 1; j <= my_road[i].white_num; j++) {
                if (abs((my_road[i].connected[j].left + my_road[i].connected[j].right) / 2 - mid[i]) < abs((my_road[i].connected[j_mid[i]].left + my_road[i].connected[j_mid[i]].right) / 2 - mid[i])
                    && my_road[i].connected[j].width > 20) {
                    j_mid[i] = j;
                }
            }

        }
        uint8_t jumpLine = 119;
        for (int i = 110; i >= 75; i--) {
            if (my_road[i - 2].connected[j_mid[i - 2]].width - my_road[i].connected[j_mid[i]].width >= 4
                && my_road[i - 1].connected[j_mid[i - 1]].width - my_road[i].connected[j_mid[i]].width >= 3
                && abs(my_road[i + 1].connected[j_mid[i + 1]].width - my_road[i].connected[j_mid[i]].width) <= 3
                && abs(my_road[i + 2].connected[j_mid[i + 2]].width - my_road[i].connected[j_mid[i]].width) <= 3
                && my_road[i].connected[j_mid[i]].width < 40
                && my_road[i].connected[j_mid[i]].right < right_side[i] - 2 && my_road[i].connected[j_mid[i]].left > left_side[i] + 2
                && my_road[i - 1].white_num != 0
                ) {
                jumpLine = i;
                break;
            }
            if (my_road[i].connected[j_mid[i]].left == left_side[i] || my_road[i].connected[j_mid[i]].right == right_side[i]) {
                break;
            }
        }
    //  //printf("jl=%d\n", jumpLine);
        if (75 <= jumpLine) {
            if (direction == 0) {
                int dy = 10;
                if (1){
                    leftPoint = jumpLine;
                    rightPoint = jumpLine;
                }
            }
            else if (direction == LEFT) {
                leftPoint = jumpLine;
                int i = jumpLine;
                if (jumpLine >= 110) {
                    i = 110;
                }
                rightPoint = i;
                while (i >= jumpLine - 30 && my_road[i].connected[j_mid[i]].right <= right_side[i] - 1 && my_road[i].connected[j_mid[i]].right <= my_road[NEAR_LINE].connected[j_mid[NEAR_LINE]].right + 15) {
                    if (my_road[i].connected[j_mid[i]].right <= my_road[rightPoint].connected[j_mid[rightPoint]].right) {
                        rightPoint = i;
                    }

                    i--;
                }

            }
            else if (direction == RIGHT) {
                rightPoint = jumpLine;
                int i = jumpLine;
                if (i >= 110) {
                    i = 110;
                }
                leftPoint = i;
                while (i >= jumpLine - 30 && my_road[i].connected[j_mid[i]].left >= left_side[i] + 1 && my_road[i].connected[j_mid[i]].left > my_road[NEAR_LINE].connected[j_mid[NEAR_LINE]].left - 15) {
                    if (my_road[i].connected[j_mid[i]].left >= my_road[leftPoint].connected[j_mid[leftPoint]].left) {
                        leftPoint = i;
                    }

                    i--;
                }
            }
        }
        ////printf("ld=%d,rd=%d\n", leftPoint, rightPoint);
//        test_varible[6]=direction;
        if (leftPoint >= 110) {
            leftPoint = 110;
        }
        else if (leftPoint < 65) {
            leftPoint = 65;
        }
        if (rightPoint >= 110) {
            rightPoint = 110;
        }
        else if (rightPoint < 65) {
            rightPoint = 65;
        }
        uint8_t yupL = leftPoint;
        uint8_t yupR = leftPoint;
        uint8_t xup = left_line[leftPoint];

        int yMin = 110;
        if (leftPoint <= rightPoint) {
            yMin = leftPoint;
        }
        else {
            yMin = rightPoint;
        }

        for (int i = yMin; i >= yMin - 60; i--) {
            if (my_road[i].white_num != 0) {
                if (left_line[i] <= xup && left_line[i - 1] > xup && i < yupL) {
                    yupL = i;
                }

            }
            else {
                break;
            }

        }
        for (int i = yMin; i >= yMin - 60; i--) {
            if (my_road[i].white_num != 0) {
                if (right_line[i] >= xup && right_line[i - 1] < xup && i < yupR) {
                    yupR = i;
                }
            }
            else {
                break;
            }
        }

        uint8_t yup = leftPoint;
        if (yupL < yupR) {
            yup = yupL;
        }
        else {
            yup = yupR;
        }


        ////printf("y=%d,x=%d\n", yup, xup);
        double k = (double)(xup - right_line[rightPoint]) / (yup - rightPoint);
        if (left_line[leftPoint] > 90 && (rightPoint > leftPoint + 20 || leftPoint <= lookahead_line)) {
            k = 0;
        }

        if (k == 0)//直走
        {
            tCrossStatus = 0;
        }

        else if (k != 0)
        {
            tCrossStatus = 1;
        }
        for (int i = rightPoint; i >= 2; i--) {
            right_line[i] = (k + dk) * (i - rightPoint) + right_line[rightPoint];
            if ((left_line[i] > left_line[i + 1] || left_line[i] == MISS) && i <= leftPoint) {
                left_line[i] = left_line[i + 1];
            }
        }

    }





    else if (TWhere == LEFT) {
        int leftPoint = 119;
        int rightPoint = 119;
        int mid[CAMERA_H];
        for (int i = NEAR_LINE; i >= 100; i--) {
            mid[i] = (left_line[i] + right_line[i]) / 2;
        }

        double kMid = calculate_slope(100, 113, mid);
        int direction;
        double kRange = 0.15;
        if (fabs(kMid) <= kRange) {
            direction = 0;
        }
        else if (kMid > kRange) {
            direction = LEFT;
        }
        else if (kMid < -1 * kRange) {
            direction = RIGHT;
        }

        for (int i = 99; i >= 1; i--) {
            mid[i] = kMid * (i - 100) + mid[100];
            if (mid[i] <= left_side[i]) {
                mid[i] = left_side[i];
            }
            if (mid[i] >= right_line[i]) {
                mid[i] = right_side[i];
            }
            //IMG[i][mid[i]] = purple;
        }



        uint8_t j_mid[CAMERA_H];

        for (int i = NEAR_LINE; i >= 1; i--) {
            j_mid[i] = j_continue[i];
            for (int j = 1; j <= my_road[i].white_num; j++) {
                if (abs((my_road[i].connected[j].left + my_road[i].connected[j].right) / 2 - mid[i]) < abs((my_road[i].connected[j_mid[i]].left + my_road[i].connected[j_mid[i]].right) / 2 - mid[i])
                    && my_road[i].connected[j].width > 20) {
                    j_mid[i] = j;
                }
            }

        }
        uint8_t jumpLine = 119;
        for (int i = 110; i >= 75; i--) {
            if (my_road[i - 2].connected[j_mid[i - 2]].width - my_road[i].connected[j_mid[i]].width >= 4
                && my_road[i - 1].connected[j_mid[i - 1]].width - my_road[i].connected[j_mid[i]].width >= 3
                && abs(my_road[i + 1].connected[j_mid[i + 1]].width - my_road[i].connected[j_mid[i]].width) <= 3
                && abs(my_road[i + 2].connected[j_mid[i + 2]].width - my_road[i].connected[j_mid[i]].width) <= 3
                && my_road[i].connected[j_mid[i]].width < 40
                && my_road[i].connected[j_mid[i]].right < right_side[i] - 2 && my_road[i].connected[j_mid[i]].left > left_side[i] + 2
                && my_road[i - 1].white_num != 0
                ) {
                jumpLine = i;
                break;
            }
            if (my_road[i].connected[j_mid[i]].left == left_side[i] || my_road[i].connected[j_mid[i]].right == right_side[i]) {
                break;
            }
        }
        ////printf("jl=%d", jumpLine);
        if (75 <= jumpLine) {
            if (direction == 0) {
                int dy = 10;
                if (1) {
                    leftPoint = jumpLine;
                    rightPoint = jumpLine;
                }
            }
            else if (direction == LEFT) {
                leftPoint = jumpLine;
                int i = jumpLine;
                if (jumpLine >= 110) {
                    i = 110;
                }
                rightPoint = i;
                while (i >= jumpLine - 30 && my_road[i].connected[j_mid[i]].right <= right_side[i] - 1 && my_road[i].connected[j_mid[i]].right <= my_road[NEAR_LINE].connected[j_mid[NEAR_LINE]].right + 15) {
                    if (my_road[i].connected[j_mid[i]].right <= my_road[rightPoint].connected[j_mid[rightPoint]].right) {
                        rightPoint = i;
                    }

                    i--;
                }

            }
            else if (direction == RIGHT) {
                rightPoint = jumpLine;
                int i = jumpLine;
                if (i >= 110) {
                    i = 110;
                }
                leftPoint = i;
                while (i >= jumpLine - 30 && my_road[i].connected[j_mid[i]].left >= left_side[i] + 1 && my_road[i].connected[j_mid[i]].left > my_road[NEAR_LINE].connected[j_mid[NEAR_LINE]].left - 15) {
                    if (my_road[i].connected[j_mid[i]].left >= my_road[leftPoint].connected[j_mid[leftPoint]].left) {
                        leftPoint = i;
                    }

                    i--;
                }
            }
        }
    //  //printf("ld=%d,rd=%d\n", leftPoint, rightPoint);

        if (leftPoint >= 110) {
            leftPoint = 110;
        }
        else if (leftPoint < 65) {
            leftPoint = 65;
        }
        if (rightPoint >= 110) {
            rightPoint = 110;
        }
        else if (leftPoint < 65) {
            rightPoint = 65;
        }
        uint8_t yupL = rightPoint;
        uint8_t yupR = rightPoint;
        uint8_t xup = right_line[rightPoint];
        int yMin = 110;
        if (leftPoint <= rightPoint) {
            yMin = leftPoint;
        }
        else {
            yMin = rightPoint;
        }
        for (int i = yMin; i >= yMin - 60; i--) {
            if (my_road[i].white_num != 0) {
                if (left_line[i] <= xup && left_line[i - 1] > xup && i < yupL) {
                    yupL = i;
                }

            }
            else {
                break;
            }

        }
        for (int i = yMin; i >= yMin - 60; i--){
            if (my_road[i].white_num != 0) {
                if (right_line[i] >= xup && right_line[i - 1] < xup && i < yupR) {
                    yupR = i;
                }
            }
            else {
                break;
            }
        }

        uint8_t yup = rightPoint;
        if (yupL < yupR) {
            yup = yupL;
        }
        else {
            yup = yupR;
        }

        double k = (double)(xup - left_line[leftPoint]) / (yup - leftPoint);
        if (right_line[rightPoint] < 100 && (rightPoint + 20 < leftPoint || rightPoint <= lookahead_line)) {
            //            test_varible[8]=1;
            k = 0;
        }
        if (k == 0)//直走
        {
            tCrossStatus = 0;
        }

        else if (k != 0)
        {
            tCrossStatus = 1;
        }

        for (int i = leftPoint; i >= 2; i--) {
            left_line[i] = (k - dk) * (i - leftPoint) + left_line[leftPoint];
            if ((right_line[i] < right_line[i + 1] || right_line[i] == MISS) && i <= rightPoint) {
                right_line[i] = right_line[i + 1];
            }
        }



    }

//    test_varible[14] = tCrossStatus;
}
////////////////////////////////////////////
//功能：出T字口结束
//输入：
//输出：
//备注：
///////////////////////////////////////////
void cross_T_out_over() {
    int flag = 0;
    int sumM = 0;
    for (int i = 105; i >= 85; i--) {
        if (my_road[i].white_num != 0) {
            if (right_line[i] - left_line[i] > 50) {
            //  printf(">=%d\n", i);
                sumM++;
            }
        }
        else {
            break;
        }
    }
    if (sumM > 4) {
        flag = 1;
    }
    //printf("flag=%d\n", flag);
    if (flag == 0) {

        if (TWhere == LEFT) {
            int flag2 = 0;
            int ymin = NEAR_LINE;
            for (int i = NEAR_LINE; i >= 90; i--) {
                if (left_line[i] <= left_line[ymin]) {
                    ymin = i;
                }

            }


        //  printf("ym=%d\n", ymin);
            if (ymin >= 105) {
                int start = ymin;
                int sumC = 0;
                for (int i = start; i >= start - 15; i--) {
                    if (left_line[i] < left_line[i + 1] - 1 || left_line[i] > left_line[i + 1] + 5) {
                        sumC++;

                    }
                }
                if (sumC >= 3) {
                    flag2 = 1;
                }
                //printf("%f,%f,%f,%f,%f\n", calculate_slope_uint(start - 15, start - 7, left_line), calculate_slope_uint(start - 7, start - 1, left_line), calculate_slope_uint(start - 13, start, left_line), calculate_slope_uint(start - 10, start - 1, right_line), calculate_slope_uint(start - 11, start - 1, left_line));
                if (fabs(calculate_slope_uint(start - 20, start - 5, left_line) - calculate_slope_uint(start - 13, start - 1, left_line)) < 0.25
                    && calculate_slope_uint(start - 13, start, left_line) > -2.5 && calculate_slope_uint(start - 13, start, left_line) <= 0
                    && flag2 == 0) {
                    if (fabs(calculate_slope_uint(start - 11, start - 1, right_line) - calculate_slope_uint(start - 11, start - 1, left_line)) < 0.25) {
                        flagIT = state * TWhere;
                        state = 0;
                        TWhere = 0;

                    }
                    else {
                        //出来内直道过短，看到的是边界
                        int sumR = 0;
                        for (int i = NEAR_LINE; i >= 85; i--) {
                            if (my_road[i].white_num != 0) {
                                if (right_line[i] >= right_side[i] - 1) {
                                    sumR++;
                                }
                            }
                            else {
                                break;
                            }
                        }
                        //printf("lk=%f\n", calculate_slope_uint(start - 13, start, left_line));
                        if (sumR >= 15 && calculate_slope_uint(start - 13, start, left_line) < -1 && calculate_slope_uint(start - 13, start, left_line) > -2.3) {
                            flagIT = state * TWhere;
                            state = 0;
                            TWhere = 0;

                        }

                    }

                }
            }

        }
        else if (TWhere == RIGHT) {

            int flag2 = 0;

            int ymax = NEAR_LINE;
            for (int i = NEAR_LINE; i >= 80; i--) {
                if (right_line[i] >= right_line[ymax]) {
                    ymax = i;
                }

            }

            if (ymax >= 105){

                int start = ymax;
                //printf("st=%d\n", start);
                int sumC = 0;
                for (int i = start; i >= start - 20; i--) {
                    if (right_line[i] > right_line[i + 1] + 1 || right_line[i] < right_line[i + 1] - 5) {
                        sumC++;

                    }
                }
                if (sumC >= 2) {
                    flag2 = 1;
                }

                if (fabs(calculate_slope_uint(start - 20, start - 5, right_line) - calculate_slope_uint(start - 12, start - 1, right_line)) < 0.25
                    && calculate_slope_uint(start - 13, start, right_line) < 2.5
                    && calculate_slope_uint(start - 13, start, right_line) >= 0
                    && flag2 == 0) {
                    //printf("dv=%f\n", fabs(calculate_slope_uint(start - 7, start + 5, left_line) - calculate_slope_uint(start - 11, start - 1, right_line)));
                    if (fabs(calculate_slope_uint(start - 7, start + 5, left_line) - calculate_slope_uint(start - 11, start - 1, right_line)) < 0.35) {
                        //printf("1");
                        flagIT = state * TWhere;
                        state = 30;
                        TWhere = 0;
                        TIslandWhere = LEFT;

                    }
                    else {
                        //出来内直道过短，看到的是边界
                        int sumR = 0;
                        for (int i = NEAR_LINE; i >= 85; i--) {
                            if (my_road[i].white_num != 0) {
                                if (left_line[i] <= left_side[i] + 1) {
                                    sumR++;
                                }
                            }
                            else {
                                break;
                            }
                        }
                        //printf("sumR=%d\n", sumR);
                        //printf("lk=%f\n", calculate_slope_uint(start - 13, start, right_line));
                        if (sumR >= 10 && calculate_slope_uint(start - 13, start, right_line) > 0.5 && calculate_slope_uint(start - 13, start, right_line) < 3) {
                            //printf("2");
                            flagIT = state * TWhere;
                            state = 30;
                            TWhere = 0;
                            TIslandWhere = LEFT;

                        }

                    }

                }
            }



        }
    }



}


////////////////////////////////////////////
//功能：出T字口开始
//输入：
//输出：
//备注：
///////////////////////////////////////////
void design_cross_T_circle() {

    if(tInCount <= 5){
        tInCount += 1;
    }

    if (TWhere == RIGHT) {

        uint8_t j_mid[CAMERA_H];
        j_mid[NEAR_LINE] = j_continue[NEAR_LINE];
        for (int i = NEAR_LINE - 1; i >= 2; i--) {
            j_mid[i] = j_continue[i];
            for (int j = 1; j <= my_road[i].white_num; j++) {
                if (abs(my_road[i].connected[j].left - my_road[i + 1].connected[j_mid[i + 1]].left) < abs(my_road[i].connected[j_mid[i]].left - my_road[i + 1].connected[j_mid[i + 1]].left)
                    && my_road[i].connected[j].width > 15) {
                    j_mid[i] = j;
                    //  break;
                }

            }
            left_line[i] = my_road[i].connected[j_mid[i]].left;
            right_line[i] = my_road[i].connected[j_mid[i]].right;
        }
        //////printf("dv=%f\n", linear_judgement(80, 100, left_line));
        double dv = linear_judgement(80, 100, left_line);
        if (dv < 10 && tInCount <= 4) {
            for (int i = 80; i <= 100; i++) {
                right_line[i] = left_line[i] + 26;
            }
        }

    }
    else if (TWhere == LEFT) {

        uint8_t j_mid[CAMERA_H];
        j_mid[NEAR_LINE] = j_continue[NEAR_LINE];
        for (int i = NEAR_LINE - 1; i >= 2; i--) {
            j_mid[i] = j_continue[i];
            for (int j = 1; j <= my_road[i].white_num; j++) {
                if (abs(my_road[i].connected[j].right - my_road[i + 1].connected[j_mid[i + 1]].right) < abs(my_road[i].connected[j_mid[i]].right - my_road[i + 1].connected[j_mid[i + 1]].right)
                    && my_road[i].connected[j].width > 15) {
                    j_mid[i] = j;

                }
            }
            left_line[i] = my_road[i].connected[j_mid[i]].left;
            right_line[i] = my_road[i].connected[j_mid[i]].right;
        }
        //////printf("dv=%f\n", linear_judgement(80, 100, right_line));
        double dv = linear_judgement(80, 100, right_line);
//        test_varible[15] = dv;

        if (dv < 10 && tInCount <= 4) {
            for (int i = 80; i <= 100; i++) {
                 left_line[i] = right_line[i] - 26;
            }
        }
    }


}


///////////////////////////////////////////
//功能：进三叉
//输入：
//输出：
//备注：
///////////////////////////////////////////
void folk_road_in() {

    uint8_t j_left[CAMERA_H];
    uint8_t j_right[CAMERA_H];
    double k_delta = 0.2;

    j_left[NEAR_LINE] = j_continue[NEAR_LINE];
    j_right[NEAR_LINE] = j_continue[NEAR_LINE];
    uint8_t leftroad[CAMERA_H];
    uint8_t rightroad[CAMERA_H];
    for (int i = NEAR_LINE - 1; i >= FAR_LINE; i--) {
        j_left[i] = j_continue[i];
        j_right[i] = j_continue[i];
        for (int j = 1; j <= my_road[i].white_num; j++) {
            if (abs(my_road[i].connected[j].left - my_road[i + 1].connected[j_left[i + 1]].left) <= abs(my_road[i].connected[j_left[i]].left - my_road[i + 1].connected[j_left[i + 1]].left)
                && my_road[i].connected[j].width > 15) {
                j_left[i] = j;
            }
            if (abs(my_road[i].connected[j].right - my_road[i + 1].connected[j_right[i + 1]].right) <= abs(my_road[i].connected[j_right[i]].right - my_road[i + 1].connected[j_right[i + 1]].right)
                && my_road[i].connected[j].width > 15) {
                j_right[i] = j;
            }
            leftroad[i] = my_road[i].connected[j_left[i]].left;
            rightroad[i] = my_road[i].connected[j_right[i]].right;
        }
        //printf("%d:%d,%d\n", i, my_road[i].connected[j_left[i]].right, my_road[i].connected[j_right[i]].left);

    }

    double kl1 = calculate_slope_struct(55, 70, j_left, LEFT);
    double kl2 = calculate_slope_struct(70, 85, j_left, LEFT);
    double kl3 = calculate_slope_struct(85, 100, j_left, LEFT);

    double kr1 = calculate_slope_struct(55, 70, j_right, RIGHT);
    double kr2 = calculate_slope_struct(70, 85, j_right, RIGHT);
    double kr3 = calculate_slope_struct(85, 100, j_right, RIGHT);

    if ((linear_judgement_struct(50,100,j_left,LEFT) < 100 )
        || (linear_judgement_struct(50, 100, j_right, RIGHT) < 100 )
        ) {
        //防止出现环岛或者回环

    }
    else {

        uint8_t mid[CAMERA_H];
        for (int i = NEAR_LINE; i >= 90; i--) {
            mid[i] = (left_line[i] + right_line[i]) / 2;
        }
        //printf("km=%f\n", calculate_slope_uint(95, 110, mid));

        //寻找顶点
        uint8_t top = 119;


        for (int i = 30; i <= 95; i++) {
            if (my_road[i - 1].connected[j_right[i - 1]].left - my_road[i - 1].connected[j_left[i - 1]].right < 20 && my_road[i - 1].connected[j_right[i - 1]].left - my_road[i - 1].connected[j_left[i - 1]].right >= 2
                && my_road[i].connected[j_right[i]].left - my_road[i].connected[j_left[i]].right < 20 && my_road[i].connected[j_right[i]].left - my_road[i].connected[j_left[i]].right >= 1
                && my_road[i + 1].connected[j_right[i + 1]].left - my_road[i + 1].connected[j_left[i + 1]].right < 0
                && my_road[i + 2].connected[j_right[i + 2]].left - my_road[i + 2].connected[j_left[i + 2]].right < 0
                && my_road[i - 1].connected[j_right[i - 1]].left - my_road[i - 1].connected[j_left[i - 1]].right > 0
                && my_road[i - 2].connected[j_right[i - 2]].left - my_road[i - 2].connected[j_left[i - 2]].right > 0
                && my_road[i - 7].connected[j_left[i - 7]].right < my_road[i - 7].connected[j_right[i - 7]].left
                && fabs(my_road[i].connected[j_right[i]].width - my_road[i].connected[j_left[i]].width) < 20) {
                top = i;
                break;
            }

        }
        if (top != 119) {

            int dSumL = 0;
            double dAverL = 0;
            int dSumR = 0;
            double dAverR = 0;
            for (int i = NEAR_LINE - 5; i >= top + 10; i--) {

                dSumL += my_road[i].connected[j_left[i]].left - my_road[i + 1].connected[j_left[i + 1]].left;
                dAverL = (double)dSumL / (NEAR_LINE - 1 - i);

                dSumR += my_road[i].connected[j_right[i]].right - my_road[i + 1].connected[j_right[i + 1]].right;
                dAverR = (double)dSumR / (NEAR_LINE - 1 - i);
                // printf("%d:L:d=%d,da=%f, d-da=%f   R:d=%d,da=%f,d-da=%f \n", i, my_road[i - 1].connected[j_left[i - 1]].left - my_road[i].connected[j_left[i]].left, dAverL, my_road[i - 1].connected[j_left[i - 1]].left - my_road[i].connected[j_left[i]].left - dAverL, my_road[i - 1].connected[j_right[i - 1]].right - my_road[i].connected[j_right[i]].right, dAverR, my_road[i - 1].connected[j_right[i - 1]].right - my_road[i].connected[j_right[i]].right - dAverR);

            }

            uint8_t minR = 119;
            uint8_t minL = 119;
            double cosMinR;
            double cosMinL;
            //cosMinR = -1;

            if (top != 119) {

                for (int i = NEAR_LINE - 5; i >= top + 7; i--) {
                    //printf("%d:l=%f,r=%f\n", i, linear_judgement(i, NEAR_LINE - 5, leftroad), linear_judgement(i, NEAR_LINE - 5, rightroad));
                    if (linear_judgement(i, NEAR_LINE - 5, leftroad) > 20) {
                        minL = i + 4;
                        break;
                    }
                    /*if (cos_angle(i - 5, i, i + 5, my_road[i - 5].connected[j_right[i - 5]].right, my_road[i].connected[j_right[i]].right, my_road[i + 5].connected[j_right[i + 5]].right) <= -0.4
                        && cos_angle(i - 5, i, i + 5, my_road[i - 5].connected[j_right[i - 5]].right, my_road[i].connected[j_right[i]].right, my_road[i + 5].connected[j_right[i + 5]].right) > -0.85) {
                        if (cos_angle(i - 5, i, i + 5, my_road[i - 5].connected[j_right[i - 5]].right, my_road[i].connected[j_right[i]].right, my_road[i + 5].connected[j_right[i + 5]].right) > cosMinR) {
                            cosMinR = cos_angle(i - 5, i, i + 5, my_road[i - 5].connected[j_right[i - 5]].right, my_road[i].connected[j_right[i]].right, my_road[i + 5].connected[j_right[i + 5]].right);
                            minR = i;
                        }
                    }
                    if (right_line[i - 5] >= right_side[i - 5] - 3) {
                        break;
                    }*/
                    //  printf("R:cos%d=%f\n", i, cos_angle(i - 5, i, i + 5, my_road[i - 5].connected[j_right[i - 5]].right, my_road[i].connected[j_right[i]].right, my_road[i + 5].connected[j_right[i + 5]].right));
                }
            }

            //cosMinL = -1;
            if (top != 119) {

                for (int i = NEAR_LINE - 5; i >= top + 7; i--) {
                    if (linear_judgement(i, NEAR_LINE - 5, rightroad) > 20) {
                        minR = i + 4;
                        break;
                    }
                    //      if (cos_angle(i - 5, i, i + 5, my_road[i - 5].connected[j_left[i - 5]].left, my_road[i].connected[j_left[i]].left, my_road[i + 5].connected[j_left[i + 5]].left) <= -0.4
                    //          && cos_angle(i - 5, i, i + 5, my_road[i - 5].connected[j_left[i - 5]].left, my_road[i].connected[j_left[i]].left, my_road[i + 5].connected[j_left[i + 5]].left) > -0.85) {
                    //          if (cos_angle(i - 5, i, i + 5, my_road[i - 5].connected[j_left[i - 5]].left, my_road[i].connected[j_left[i]].left, my_road[i + 5].connected[j_left[i + 5]].left) > cosMinL) {
                    //              cosMinL = cos_angle(i - 5, i, i + 5, my_road[i - 5].connected[j_left[i - 5]].left, my_road[i].connected[j_left[i]].left, my_road[i + 5].connected[j_left[i + 5]].left);
                    //              minL = i;
                    //          }
                    //      }
                    //      if (left_line[i - 5] <= left_side[i - 5] + 3) {
                    //          break;
                    //      }
                    ////        printf("L:cos%d=%f\n", i, cos_angle(i - 5, i, i + 5, my_road[i - 5].connected[j_left[i - 5]].left, my_road[i].connected[j_left[i]].left, my_road[i + 5].connected[j_left[i + 5]].left));
                }
            }


            if (minL < NEAR_LINE - 2 && minR < NEAR_LINE - 2) {

                //先保证两个角找的是准的
                if (fabs(calculate_slope_struct(minL + 1, minL + 15, j_left, LEFT) - calculate_slope_struct(minR + 1, minR + 15, j_right, RIGHT)) < 0.3
                    && calculate_slope_struct(minL - 13, minL - 1, j_left, LEFT) * calculate_slope_struct(minR - 13, minR - 1, j_right, RIGHT) < 0
                    && calculate_slope_struct(top - 10, top - 1, j_left, RIGHT) * calculate_slope_struct(top - 10, top - 1, j_right, LEFT) < 0) {

                    //区分十字
                    int flag1 = 0;
                    if (1) {
                        for (int i = 0; i <= 13; i++) {
                            if (my_road[top - i].connected[j_left[top - i]].right == my_road[top - i].connected[j_right[top - i]].right) {
                                flag1 = -1;
                                break;
                            }
                        }

                        //  printf("k1=%f,k2=%f,k3=%f,k4=%f\n", calculate_slope_struct(top - 13, top - 2, j_left, RIGHT), calculate_slope_struct(top - 13, top - 2, j_right, LEFT) ,calculate_slope_struct(minR + 1, minR + 13, j_right, RIGHT), calculate_slope_struct(minL + 1, minL + 13, j_left, LEFT));
                        if ((fabs(calculate_slope_struct(top - 13, top - 2, j_left, RIGHT) - calculate_slope_struct(minR + 1, minR + 13, j_right, RIGHT)) > 0.6
                            || fabs(calculate_slope_struct(top - 13, top - 2, j_right, LEFT) - calculate_slope_struct(minL + 1, minL + 13, j_left, LEFT)) > 0.6)
                            && (fabs(calculate_slope_struct(top - 13, top - 2, j_right, LEFT) - calculate_slope_struct(minR + 1, minR + 13, j_right, RIGHT)) > 0.6
                            || fabs(calculate_slope_struct(top - 13, top - 2, j_left, RIGHT) - calculate_slope_struct(minL + 1, minL + 13, j_left, LEFT)) > 0.6)
                            //  && fabs(calculate_slope_struct(top - 17, top - 2, j_left, RIGHT) - calculate_slope_struct(minL - 13, minL - 1, j_left, LEFT)) <0.25
                            && calculate_slope_struct(top - 13, top - 2, j_left, RIGHT) * calculate_slope_struct(top - 13, top - 2, j_right, LEFT) < 0
                            && flag1 == 0
                            ) {
                            flag1 = 1;
                            //printf("top=%f,%f\n", calculate_slope_struct(top - 15, top - 2, j_left, RIGHT), calculate_slope_struct(minR + 1, minR + 15, j_right, RIGHT));
                        }
                    }
                    else {
                        //printf("k1=%f,k2=%f\n", calculate_slope_struct(top - 17, top - 2, j_right, LEFT), calculate_slope_struct(minL + 1, minL + 15, j_left, LEFT));
                        if (fabs(calculate_slope_struct(top - 15, top - 2, j_right, LEFT) - calculate_slope_struct(minL + 1, minL + 15, j_left, LEFT)) > 0.6
                            && fabs(calculate_slope_struct(top - 15, top - 2, j_left, RIGHT) - calculate_slope_struct(minR + 1, minR + 15, j_right, RIGHT)) > 0.6
                            //  && fabs(calculate_slope_struct(top - 17, top - 2, j_right, LEFT) - calculate_slope_struct(minR - 13, minR - 1, j_right, RIGHT)) < 0.25
                            && calculate_slope_struct(top - 10, top - 2, j_left, RIGHT) * calculate_slope_struct(top - 10, top - 2, j_right, LEFT) < 0
                            ) {
                            flag1 = 1;
                        }
                    }
                    //  printf("flag=%d", flag1);
                    if (flag1 == 1 && top >= 45 && minR >= 70 && minL >= 70
                        ) {

                        int leftRoad[CAMERA_H];
                        int rightRoad[CAMERA_H];
                        int mid[CAMERA_H];
                        int min = minL;
                        if (minL > minR) {
                            min = minR;
                        }
                        for (int i = NEAR_LINE; i >= min + 1; i--) {
                            mid[i] = (left_line[i] + right_line[i]) / 2;
                        }
                        double k = calculate_slope(min + 2, NEAR_LINE - 1, mid);

                        for (int i = minL; i >= 10; i--) {
                            leftRoad[i] = k * (i - minL) + left_line[minL];
                            //  IMG[i][leftRoad[i]] = purple;
                        }
                        for (int i = minR; i >= 10; i--) {
                            rightRoad[i] = k * (i - minR) + right_line[minR];
                            // IMG[i][rightRoad[i]] = purple;
                        }

                        //两直线内几乎没有赛道

                        int sumN = 0;
                        for (int i = top - 5; i >= 20; i--) {
                            int sumB = 0;
                            for (int j = leftRoad[i] + 1; j < rightRoad[i]; j++) {
                                if (IMG[i][j] == white) {
                                    sumB++;
                                }
                            }
                            if (sumB <= 4) {
                                sumN++;
                            }
                        }
                        if (sumN >= 15) {
                            //printf("11\n");
                            if(folkCNT - folkTimes == 1) //folkCNT为需要满足的条件，folkTimes为次数，例如cnt=3代表可以开始识别第三个三叉，此时times=2
                            {
                                state = stateFolkRoadIn;
                                folkTimes += 1;
                            }

                        }


                    }


                }
            }

        }
        else {
            int direction = 0;
            uint8_t jumpLine = 119;
            for (int i = NEAR_LINE; i >= 60; i--) {
                if (left_line[i] - left_line[i - 2] >= 6
                    && abs(left_line[i] - left_line[i + 1]) <= 3
                    && abs(right_line[i] - right_line[i - 1]) <= 2
                    ) {
                    direction = LEFT;
                    jumpLine = i;
                    break;
                }
                else if (right_line[i] - right_line[i - 2] <= -6
                    && abs(right_line[i] - right_line[i + 1]) <= 3
                    && abs(left_line[i] - left_line[i - 1]) <= 3
                    ) {
                    direction = RIGHT;
                    jumpLine = i;
                    break;
                }
            }
        //  printf("d=%d\n", direction);
            uint8_t minL = 119, minR = 119;
            if (direction == LEFT) {
                minL = jumpLine;
                for (int i = jumpLine - 50; i <= jumpLine; i++) {
                    if (my_road[i].connected[j_right[i]].left - my_road[i + 1].connected[j_right[i + 1]].left >= 6
                        && abs(my_road[i].connected[j_right[i]].left - my_road[i - 1].connected[j_right[i - 1]].left) <= 4
                        && my_road[i].connected[j_right[i]].left - my_road[i + 2].connected[j_right[i + 2]].left >= 6
                        && my_road[i].connected[j_right[i ]].left - my_road[i + 3].connected[j_right[i + 3]].left >= 6
                        && abs(my_road[i].connected[j_right[i]].left - my_road[i - 2].connected[j_right[i - 2]].left) <= 4
                        && abs(my_road[i].connected[j_right[i]].left - my_road[i - 4].connected[j_right[i - 4]].left) <= 5
                        && my_road[i].connected[j_right[i]].width < 40
                        ) {
                        top = i;
                        break;
                    }

                }
                uint8_t max = minL;
                for (int i = minL; i >= top; i--) {
                    if (my_road[i].connected[j_right[i]].right < my_road[max].connected[j_right[max]].right) {
                        max = i;
                    }
                }
                minR = max;

                int sumLD = 0;
                for (int i = minL; i <= minL + 25 && i <= NEAR_LINE; i++) {
                    if (my_road[i].connected[j_left[i]].left <= left_side[i] + 2) {
                        sumLD++;
                    }
                }
                if (calculate_slope_struct(minR + 1, minR + 14, j_right, RIGHT) >= 0 && calculate_slope_struct(minR - 16, minR - 3, j_right, RIGHT) <= 0
                    && fabs(calculate_slope_struct(minR - 16, minR - 3, j_right, RIGHT) - calculate_slope_struct(top - 16, top - 3, j_right, LEFT)) < 0.3
                    && fabs(calculate_slope_struct(minR + 1, minR + 14, j_right, RIGHT) - calculate_slope_struct(top - 16, top - 3, j_right, LEFT)) > 0.6
                    && 0>= calculate_slope_struct(top - 14, top - 1, j_right, LEFT) && calculate_slope_struct(top - 16, top - 3, j_right, LEFT) >= -1.2
                    && top >= 30 && minL >=60 && minR >= 50
                    && top < minR && minR <= minL
                    && (sumLD <= 7)
                    ) {

                    double k = calculate_slope_struct(minR + 2, minR + 15, j_right, RIGHT);

                    uint8_t rightRoad[CAMERA_H];
                    uint8_t leftRoad[CAMERA_H];

                    for (int i = minL; i >= top - 40; i--) {
                        leftRoad[i] = k * (i - minL) + left_line[minL];
                        //  IMG[i][leftRoad[i]] = purple;
                    }
                    for (int i = minR; i >= top - 40; i--) {
                        rightRoad[i] = k * (i - minR) + right_line[minR];
                        // IMG[i][rightRoad[i]] = purple;
                    }
                    int sumN = 0;
                    for (int i = top - 5; i >= top - 40; i--) {
                        int sumB = 0;
                        for (int j = leftRoad[i] + 1; j < rightRoad[i]; j++) {
                            if (IMG[i][j] == white) {
                                for (int m = 1; m <= my_road[i].white_num; m++) {
                                    if (my_road[i].connected[m].left <= j && j <= my_road[i].connected[m].right) {
                                        sumB++;
                                    }
                                }
                            }
                        }
                        if (sumB <= 4) {
                            sumN++;
                        }
                    }
                    if (sumN >= 15) {
                        if(folkCNT - folkTimes == 1)
                        {
                            state = stateFolkRoadIn;
                            folkTimes += 1;
                        }
                    }

                }

            }
            else if (direction == RIGHT) {
                minR = jumpLine;
                for (int i = jumpLine; i >= jumpLine - 50; i--) {
                    if (my_road[i].connected[j_left[i]].right - my_road[i + 1].connected[j_left[i + 1]].right < -6
                        && abs(my_road[i].connected[j_left[i]].right - my_road[i - 1].connected[j_left[i - 1]].right) <= 3
                        && my_road[i].connected[j_left[i]].right - my_road[i + 2].connected[j_left[i + 2]].right < -6
                        && my_road[i].connected[j_left[i]].right - my_road[i + 3].connected[j_left[i + 3]].right < -6
                        && abs(my_road[i].connected[j_left[i]].right - my_road[i - 2].connected[j_left[i - 2]].right) <= 3
                        && my_road[i].connected[j_left[i]].width < 40
                        ) {
                        top = i;
                        break;
                    }

                }
                //printf("top=%d\n", top);
                uint8_t max = minL;
                for (int i = minR; i >= top; i--) {
                    if (my_road[i].connected[j_left[i]].left > my_road[max].connected[j_left[max]].left) {
                        max = i;
                    }
                }
                minL = max;
                int sumRD = 0;
                for (int i = minL; i <= minL + 25 && i<=NEAR_LINE; i++) {
                    if (my_road[i].connected[j_right[i]].right >= right_side[i] - 2) {
                        sumRD++;
                    }
                }
                if (calculate_slope_struct(minL + 1, minL + 14, j_left, LEFT) <= 0 && calculate_slope_struct(minL - 16, minL - 3, j_left, LEFT)>= 0
                    && fabs(calculate_slope_struct(minL - 16, minL - 3, j_left, LEFT) - calculate_slope_struct(top - 16, top - 3, j_left, RIGHT)) < 0.25
                    && fabs(calculate_slope_struct(minL + 1, minL + 14, j_left, LEFT) - calculate_slope_struct(top - 16, top - 3, j_left, RIGHT)) > 0.6
                    && 0 <= calculate_slope_struct(top - 16, top - 3, j_left, RIGHT) && calculate_slope_struct(top - 16, top - 3, j_left, RIGHT) <= 0.9
                    && top >= 30 && minR >= 60 && minL >= 50
                    && top < minL && minL <= minR
                    && sumRD <= 7
                    ) {

                    double k = calculate_slope_struct(minL + 2, minL + 15, j_right, RIGHT);

                    uint8_t rightRoad[CAMERA_H];
                    uint8_t leftRoad[CAMERA_H];

                    for (int i = minL; i >= top - 40; i--) {
                        leftRoad[i] = k * (i - minL) + left_line[minL];
                        //  IMG[i][leftRoad[i]] = purple;
                    }
                    for (int i = minR; i >= top - 40; i--) {
                        rightRoad[i] = k * (i - minR) + right_line[minR];
                        // IMG[i][rightRoad[i]] = purple;
                    }
                    int sumN = 0;
                    for (int i = top - 5; i >= top - 40; i--) {
                        int sumB = 0;
                        for (int j = leftRoad[i] + 1; j < rightRoad[i]; j++) {
                            if (IMG[i][j] == white) {
                                for (int m = 1; m <= my_road[i].white_num; m++) {
                                    if (my_road[i].connected[m].left <= j && j <= my_road[i].connected[m].right) {
                                        sumB++;
                                    }
                                }
                            }
                        }
                        if (sumB <= 4) {
                            sumN++;
                        }
                    }
                    if (sumN >= 15) {
                        if(folkCNT - folkTimes == 1)
                        {
                            state = stateFolkRoadIn;
                            folkTimes += 1;
                        }
                    }

                }
            }


        }
    }

}


void design_folk_road() {
    uint8_t j_left[CAMERA_H];
    uint8_t j_right[CAMERA_H];
    double k_delta = folkParam2.floatVal;
    int width = folkParam1.intVal;
    j_left[NEAR_LINE] = j_continue[NEAR_LINE];
    j_right[NEAR_LINE] = j_continue[NEAR_LINE];
    for (int i = NEAR_LINE - 1; i >= FAR_LINE; i--) {
        j_left[NEAR_LINE] = j_continue[NEAR_LINE];
        j_right[NEAR_LINE] = j_continue[NEAR_LINE];
        for (int j = 1; j <= my_road[i].white_num; j++) {
            if (abs(my_road[i].connected[j].left - my_road[i + 1].connected[j_left[i + 1]].left) <= abs(my_road[i].connected[j_left[i]].left - my_road[i + 1].connected[j_left[i + 1]].left)
                && my_road[i].connected[j].width > 15) {
                j_left[i] = j;
            }
            if (abs(my_road[i].connected[j].right - my_road[i + 1].connected[j_right[i + 1]].right) <= abs(my_road[i].connected[j_right[i]].right - my_road[i + 1].connected[j_right[i + 1]].right)
                && my_road[i].connected[j].width > 15) {
                j_right[i] = j;
            }
        }

    }
//
//    for (int i = NEAR_LINE - 1; i >= FAR_LINE; i--)
//    {
//        if (my_road[i].white_num >= 2 && my_road[i - 1].white_num >= 2)
//        {
//            int flag = 0;
//            for (int j = 1; j <= my_road[i].white_num; j++)
//            {
//                //if(my_road[i].connected[j].width > 10&& my_road[i-1].connected[j].width > 10)
//            }
//        }
//    }
    int a;
    if (FolkRoadWhere == RIGHT) {
        for (int i = NEAR_LINE - 1; i >= 20; i--) {
            right_line[i] = my_road[i].connected[j_right[i]].right;
            a = (int)right_line[i] - width - k_delta * (i - NEAR_LINE);
            if(a<0){
                left_line[i]=0;
            }else{
                left_line[i]=a;
            }
            if (left_line[i] < left_line[i + 1]) {
                left_line[i] = left_line[i + 1];
            }
        }
//        for (int i = NEAR_LINE; i >= 20; i--) {
//            if (right_line[i] - right_line[i - 1] > 5 && right_line[i] - right_line[i - 2] > 5)
//            {
//                right_line[i] = right_side[i];
//                right_line[i - 1] = right_side[i - 1];
//                left_line[i] = right_line[i] - width;
//                left_line[i - 1] = right_line[i - 1] - width;
//            }
//        }
    }
    else if (FolkRoadWhere == LEFT) {
        for (int i = NEAR_LINE; i >= 20; i--) {
            left_line[i] = my_road[i].connected[j_left[i]].left;
            a= left_line[i] + width + k_delta * (i - NEAR_LINE);
            if(a>188){
                right_line[i]=188;
            }else{
                right_line[i]=a;
            }
            if (right_line[i] > right_line[i + 1]) {
                right_line[i] = right_line[i + 1];
            }
        }
//        for (int i = NEAR_LINE; i >= 20; i--) {
//            if (left_line[i - 1] - left_line[i] > 5 && left_line[i - 2] - left_line[i] > 5)
//            {
//                left_line[i] = left_side[i];
//                left_line[i - 1] = left_side[i - 1];
//                right_line[i] = left_line[i] + width;
//                right_line[i - 1] = left_line[i - 1] + width;
//            }
//        }

    }

}
////////////////////////////////////////////
//功能：出三叉
//输入：
//输出：
//备注：
///////////////////////////////////////////
void folk_road_out() {
    //printf("出三叉判据：\k1=%f,k2=%f\n",  calculate_slope_uint(85, 100, left_line), calculate_slope_uint(95, 110, right_line));
    //printf("dv=%f,dv=%f\n", linear_judgement(85, 100, left_line), linear_judgement(96, 110, right_line));
    if (1) {
        if (FolkRoadWhere == RIGHT) {
            if (fabs(calculate_slope_uint(85, 100, left_line) - calculate_slope_uint(95, 110, right_line)) < 0.3
                && calculate_slope_uint(85, 100, left_line) > -1.2 && calculate_slope_uint(95, 110, right_line) > -1.2
                && linear_judgement(85, 100, left_line) < 100 && linear_judgement(96, 110, right_line) < 100
                && (right_line[NEAR_LINE - 2] - left_line[NEAR_LINE - 2] > 32 || (left_line[NEAR_LINE - 2] - left_side[NEAR_LINE - 2] <= 2 && right_line[NEAR_LINE - 2] -right_side[NEAR_LINE - 2] < -2))
                ) {
                state = 0;
                folkOutTimes += 1;
            }
        }
        else if (FolkRoadWhere == LEFT) {
            if (fabs(calculate_slope_uint(85, 100, right_line) - calculate_slope_uint(95, 110, left_line)) < 0.3
                && calculate_slope_uint(85, 100, right_line) < 1.2 && calculate_slope_uint(95, 110, left_line) < 1.2
                && linear_judgement(85, 100, right_line) < 100 && linear_judgement(96, 110, left_line) < 100
                && (right_line[NEAR_LINE - 2] - left_line[NEAR_LINE - 2] > 32|| (left_line[NEAR_LINE - 2] - left_side[NEAR_LINE - 2] > 2 && right_line[NEAR_LINE - 2] -right_side[NEAR_LINE - 2] >= -2))
                ) {
                state = 0;
                folkOutTimes += 1;
            }
        }

    }
}
void protection() {
    int count1 = 0;
    uint8_t* pmap;
    pmap = fullBuffer + 75 * 188;
    for (int i = 0; i < 10; i++)
    {
        pmap = pmap + 40;
        for (int j = 40; j < 148; j++)
        {
            if (*(pmap) < presentTHRE.intVal)
            {
                count1++;
            }
            pmap++;
            ////////////////////////printf("%d  ", *(pmap));
        }
        pmap = pmap + 40;
    }

    if(count1 > 8 *108) stopCount += 1;

    if(stopCount > 1) stopFlag = 1;



}


void carpark_in()
{
    // rightPark = 1, leftPark = 0;
    uint8_t j_left[CAMERA_H], j_right[CAMERA_H];
    j_right[NEAR_LINE] = j_continue[NEAR_LINE];
    j_left[NEAR_LINE] = j_continue[NEAR_LINE];
    for (int i = NEAR_LINE - 1; i >= 2; i--) {
        j_right[i] = my_road[i].white_num;
        j_left[i] = 1;
        for (int j = my_road[i].white_num; j >= 1; j--) {
            if (abs(my_road[i].connected[j].right - my_road[i + 1].connected[j_right[i + 1]].right) < abs(my_road[i].connected[j_right[i]].right - my_road[i + 1].connected[j_right[i + 1]].right)) {
                j_right[i] = j;
            }
            if (abs(my_road[i].connected[j].left - my_road[i + 1].connected[j_left[i + 1]].left) <= abs(my_road[i].connected[j_left[i]].left - my_road[i + 1].connected[j_left[i + 1]].left)) {
                j_left[i] = j;
            }
        }
        ////printf("%d,r=%d,l=%d\n", i, my_road[i].connected[j_right[i]].right, my_road[i].connected[j_left[i]].left);
    }
    if (rightPark == 1 && leftPark == 0) {
        //找到车库
        int downPoint = 119;
        int upPoint = 119;
        int flag = 0;
        if (calculate_slope_struct(90, 105, j_left, LEFT) <= 0) {
            for (int i = 110; i > 60; i--) {
                if (right_line[i] - right_line[i - 1] < -4 && right_line[i] - right_line[i - 2] < -4
                    && abs(right_line[i] - right_line[i + 1]) <= 3 && abs(right_line[i] - right_line[i + 1]) <= 4) {
                    downPoint = i;
                    break;
                }
            }

            int start = downPoint - 50;
            upPoint = start;
            while (start <= downPoint - 5 && my_road[start].connected[j_right[start]].right < my_road[downPoint - 50].connected[j_right[downPoint - 50]].right + 10
                && my_road[start].connected[j_right[start]].right < right_side[start] - 1) {
                if (my_road[start].connected[j_right[start]].right <= my_road[upPoint].connected[j_right[upPoint]].right) {
                    upPoint = start;
                }
                start++;
            }

            if (downPoint < 110 && upPoint <= 110 && upPoint >= 60 && downPoint > 60
                && fabs(calculate_slope_struct(downPoint + 1, downPoint + 15, j_right, RIGHT) - calculate_slope_struct(upPoint - 15, upPoint - 1, j_right, RIGHT)) < 0.25
                && fabs(calculate_slope_struct(downPoint + 1, downPoint + 15, j_left, LEFT) - calculate_slope_struct(upPoint - 15, upPoint - 1, j_left, LEFT)) < 0.25
                ) {
                flag = 1;
            }
        }
        else {
            int start = 110;
            downPoint = 110;

            while (start >= 60 && my_road[start].connected[j_right[start]].right <= my_road[110].connected[j_right[110]].right + 10
                && my_road[start].connected[j_right[start]].right < right_side[start] - 1) {
                if (my_road[start].connected[j_right[start]].right <= my_road[downPoint].connected[j_right[downPoint]].right) {
                    downPoint = start;
                }
                start--;
            }

            for (int i = downPoint - 50; i < downPoint; i++) {
                if (my_road[i].connected[j_left[i]].right - my_road[i + 1].connected[j_left[i + 1]].right < -4 && my_road[i].connected[j_left[i]].right - my_road[i + 2].connected[j_left[i + 2]].right < -4
                    && abs(my_road[i].connected[j_left[i]].right - my_road[i - 1].connected[j_left[i - 1]].right) <= 3 && abs(my_road[i].connected[j_left[i]].right - my_road[i - 2].connected[j_left[i - 2]].right) <= 4) {
                    upPoint = i;
                    break;
                }
            }
            if (downPoint < 110 && upPoint <= 110 && upPoint >= 50 && downPoint > 60
                && fabs(calculate_slope_struct(downPoint + 1, downPoint + 15, j_right, RIGHT) - calculate_slope_struct(upPoint - 15, upPoint - 1, j_left, RIGHT)) < 0.25
                && fabs(calculate_slope_struct(downPoint + 1, downPoint + 15, j_left, LEFT) - calculate_slope_struct(upPoint - 15, upPoint - 1, j_left, LEFT)) < 0.25) {
                flag = 1;
            }
        }

        ////printf("down=%d,up=%d\n", downPoint, upPoint);
        ////printf("dl=%f,dr=%f", fabs(calculate_slope_struct(downPoint + 1, downPoint + 15, j_left, LEFT) - calculate_slope_struct(upPoint - 15, upPoint - 1, j_left, LEFT)), fabs(calculate_slope_struct(downPoint + 1, downPoint + 15, j_right, RIGHT) - calculate_slope_struct(upPoint - 15, upPoint - 1, j_right, RIGHT)));
        if (flag == 1
            ) {
            //寻找斑马线
            int flagBM = 0;
            int sumB = 0, sumB_max = 0;
            int sum_black = 0;
            uint8_t blackNum[CAMERA_H] = { 0 };
            double aveBlack = 0;
            double max_aveBlack = 0;
            for (int i = upPoint - 10; i <= downPoint + 10; i++) {
                for (int j = 1; j < my_road[i].white_num; j++) {
                    if (my_road[i].connected[j + 1].left - my_road[i].connected[j].right >= 1 && my_road[i].connected[j + 1].left - my_road[i].connected[j].right <= 5) {
                        blackNum[i]++;
                    }
                }

                if (blackNum[i] >= 2 && flagBM == 0) {
                    flagBM = 1;
                    sumB++;
                    sum_black += blackNum[i];
                }
                else if (flagBM == 1 && blackNum[i] >= 2) {
                    sumB++;
                    sum_black += blackNum[i];
                }
                else {
                    flagBM = 0;

                    if (sumB > sumB_max) {
                        sumB_max = sumB;
                        if (sumB != 0) {
                            aveBlack = (double)sum_black / sumB;
                        }
                    }
                    sum_black = 0;
                    sumB = 0;

                }


            }
            ////printf("park:%f,%d\n",aveBlack, sumB_max);
            if ((aveBlack >= 3 && sumB_max >= 2) || (aveBlack < 3 && aveBlack >= 2.5 && sumB_max >= 3) || (aveBlack >= 2 && aveBlack < 2.5 && sumB_max >= 4)) {
                state = stateParkIn;

                carParkDelay = 0;
                carParkTimes += 1;

                if (carParkTimes == 2)
                {
                    myParkLine = 60;
                }
            }

        }
    }
    else if (rightPark == 0 && leftPark == 1) {
        //找到车库
        int downPoint = 119;
        int upPoint = 119;
        int flag = 0;
        if (calculate_slope_struct(90, 105, j_right, RIGHT) >= 0) {
            for (int i = 110; i > 60; i--) {
                if (left_line[i] - left_line[i - 1] > 4 && left_line[i] - left_line[i - 2] > 4
                    && abs(left_line[i] - left_line[i + 1]) <= 3 && abs(left_line[i] - left_line[i + 1]) <= 4) {
                    downPoint = i;
                    break;
                }
            }

            int start = downPoint - 50;
            upPoint = start;
            while (start <= downPoint - 5 && my_road[start].connected[j_left[start]].left > my_road[downPoint - 50].connected[j_left[downPoint - 50]].left - 10
                && my_road[start].connected[j_left[start]].left > left_side[start] + 1) {
                if (my_road[start].connected[j_left[start]].left >= my_road[upPoint].connected[j_left[upPoint]].left) {
                    upPoint = start;
                }
                start++;
            }
            if (downPoint < 110 && upPoint <= 110 && upPoint >= 60 && downPoint > 60
                && fabs(calculate_slope_struct(downPoint + 1, downPoint + 15, j_right, RIGHT) - calculate_slope_struct(upPoint - 15, upPoint - 1, j_right, RIGHT)) < 0.25
                && fabs(calculate_slope_struct(downPoint + 1, downPoint + 15, j_left, LEFT) - calculate_slope_struct(upPoint - 15, upPoint - 1, j_left, LEFT)) < 0.25

                ) {
                flag = 1;
            }

        }
        else {
            int start = 110;
            downPoint = 110;
            while (start >= 60 && my_road[start].connected[j_left[start]].left >= my_road[110].connected[j_left[110]].left - 10
                && my_road[start].connected[j_left[start]].left > left_side[start] + 1) {
                if (my_road[start].connected[j_left[start]].left >= my_road[downPoint].connected[j_left[downPoint]].left) {
                    downPoint = start;
                }
                start--;
            }
            for (int i = downPoint - 50; i < downPoint; i++) {
                if (my_road[i].connected[j_right[i]].left - my_road[i + 1].connected[j_right[i + 1]].left > 4 && my_road[i].connected[j_right[i]].left - my_road[i + 2].connected[j_right[i + 2]].left > 4
                    && abs(my_road[i].connected[j_right[i]].left - my_road[i - 1].connected[j_right[i - 1]].left) <= 3 && abs(my_road[i].connected[j_right[i]].left - my_road[i - 2].connected[j_right[i - 2]].left) <= 4) {
                    upPoint = i;
                    break;
                }

            }
            if (downPoint < 110 && upPoint <= 110 && upPoint >= 50 && downPoint > 60
                && fabs(calculate_slope_struct(downPoint + 1, downPoint + 15, j_right, RIGHT) - calculate_slope_struct(upPoint - 15, upPoint - 1, j_right, RIGHT)) < 0.25
                && fabs(calculate_slope_struct(downPoint + 1, downPoint + 15, j_left, LEFT) - calculate_slope_struct(upPoint - 15, upPoint - 1, j_right, LEFT)) < 0.25
                ) {
                flag = 1;
            }

        }
        //        test_varible[7]=flag;
        //        test_varible[14]=fabs(calculate_slope_struct(downPoint + 1, downPoint + 15, j_right, RIGHT) - calculate_slope_struct(upPoint - 15, upPoint - 1, j_right, RIGHT));
        //        test_varible[15]=fabs(calculate_slope_struct(downPoint + 1, downPoint + 15, j_left, LEFT) - calculate_slope_struct(upPoint - 15, upPoint - 1, j_right, LEFT));
                ////printf("down=%d,up=%d\n", downPoint, upPoint);
        if (flag == 1) {
            //            test_varible[6]=2;
                        //寻找斑马线
            int flagBM = 0;
            int sumB = 0, sumB_max = 0;
            int sum_black = 0;
            uint8_t blackNum[CAMERA_H] = { 0 };
            double aveBlack = 0;
            double max_aveBlack = 0;
            for (int i = upPoint - 10; i <= downPoint + 10; i++) {
                for (int j = 1; j < my_road[i].white_num; j++) {
                    if (my_road[i].connected[j + 1].left - my_road[i].connected[j].right >= 1 && my_road[i].connected[j + 1].left - my_road[i].connected[j].right <= 5) {
                        blackNum[i]++;
                    }
                }

                if (blackNum[i] >= 2 && flagBM == 0) {
                    flagBM = 1;
                    sumB++;
                    sum_black += blackNum[i];
                }
                else if (flagBM == 1 && blackNum[i] >= 2) {
                    sumB++;
                    sum_black += blackNum[i];
                }
                else {
                    flagBM = 0;

                    if (sumB > sumB_max) {
                        sumB_max = sumB;
                        if (sumB != 0) {
                            aveBlack = (double)sum_black / sumB;
                        }
                    }
                    sum_black = 0;
                    sumB = 0;

                }


            }

            ////printf("park:%f,%d\n",aveBlack, sumB_max);
            if ((aveBlack >= 3 && sumB_max >= 2) || (aveBlack < 3 && aveBlack >= 2.5 && sumB_max >= 3) || (aveBlack >= 2 && aveBlack < 2.5 && sumB_max >= 4)) {
                state = stateParkIn;

                carParkDelay = 0;
                carParkTimes += 1;

                if (carParkTimes == 2)
                {
                    myParkLine = 60;
                }
            }

        }
    }



    //int flag = 0;
    //int gapNumber = 0, gapNumber1 = 0, gapNumber2 = 0, gapNumber3 = 0;
    //double leftK1 = 0, leftK2 = 0, rightK1 = 0, rightK2 = 0;
    //uint8_t i, j;
    //uint8_t upPoint = 1, downPoint = 1, averPoint, updownDelta = 0;
    //float lineCount = 0;
    //uint8_t whiteNumAdd = 0;
    //float lineNumAver = 0;
    //rightPark = 1;
    //for (carParkX = 60; carParkX < 100; carParkX++)
    //{

    //  int blackNum = 0;
    //  for (int j = 1; j < my_road[carParkX].white_num; j++) {
    //      if (my_road[carParkX].connected[j + 1].left - my_road[carParkX].connected[j].right >= 1 && my_road[carParkX].connected[j + 1].left - my_road[carParkX].connected[j].right <= 7) {
    //          blackNum++;
    //      }
    //  }

    //  if (my_road[carParkX + 1].white_num >= 3 && my_road[carParkX].white_num >= 3 && my_road[carParkX - 1].white_num >= 3)
    //  {

    //      lineCount = 0;
    //      whiteNumAdd = 0;
    //      for (int i = carParkX - 2; i <= carParkX + 4; i++)
    //      {

    //          if (my_road[i].white_num >= 3)
    //          {
    //              whiteNumAdd += my_road[i].white_num;
    //              lineCount += 1;
    //          }

    //      }
    //      lineNumAver = whiteNumAdd / lineCount;

    //      if (my_road[carParkX].connected[my_road[carParkX].white_num].width > 8 || my_road[carParkX].connected[1].width > 8 || lineNumAver >= 6)
    //      {
    //          gapNumber = 0;
    //          for (int gap = 1; gap <= my_road[carParkX].white_num; gap++)
    //          {
    //              if (my_road[carParkX].connected[gap].width <= 3)
    //              {
    //                  if (my_road[5].white_num != 0) {
    //                      gapNumber++;
    //                  }

    //              }
    //          }

    //          for (int gap2 = 1; gap2 <= my_road[carParkX - 1].white_num; gap2++)
    //          {
    //              if (my_road[carParkX - 1].connected[gap2].width <= 4)
    //              {
    //                  if (my_road[5].white_num != 0) {
    //                      gapNumber++;
    //                  }

    //              }
    //          }

    //          if (gapNumber >= 5 && carParkX >= 65)
    //          {
    //              if (rightPark == 1 && leftPark == 0)
    //              {
    //                  rightK1 = calculate_two_point_slope(carParkX + 15, my_road[carParkX + 15].connected[1].left, carParkX - 10, my_road[carParkX - 10].connected[1].left);
    //                  rightK2 = calculate_two_point_slope(carParkX + 10, my_road[carParkX + 10].connected[1].left, carParkX - 15, my_road[carParkX - 15].connected[1].left);
    //              //  test_varible[6] = rightK1;
    //              //  test_varible[7] = rightK2;
    //                  if (fabs(rightK1) < 0.6 && fabs(rightK2) < 0.6 && fabs(rightK1 - rightK2) < 0.08)
    //                  {
    //                      flag = 1;
    //                      //                                    test_varible[5] = carParkX;
    //                  }
    //              }

    //              else if (leftPark == 1 && rightPark == 0)
    //              {
    //                  leftK1 = calculate_two_point_slope(carParkX + 15, my_road[carParkX + 15].connected[my_road[carParkX + 15].white_num].right, carParkX - 10, my_road[carParkX - 10].connected[my_road[carParkX - 10].white_num].right);
    //                  leftK2 = calculate_two_point_slope(carParkX + 5, my_road[carParkX + 5].connected[my_road[carParkX + 5].white_num].right, carParkX - 10, my_road[carParkX - 10].connected[my_road[carParkX - 10].white_num].right);
    //                  //                            test_varible[6] = leftK1;
    //                  //                            test_varible[7] = leftK2;

    //                  if (fabs(leftK1) < 0.6 && fabs(leftK2) < 0.6 && fabs(leftK1 - leftK2) < 0.1)
    //                  {
    //                      flag = 1;
    //                      //                                    test_varible[5] = carParkX;
    //                  }
    //              }

    //              //flagStop = 1;


    //          }

    //          if (flag == 1)
    //          {
    //              //state = stateParkIn;
    //              break;
    //          }
    //      }
    //  }
    //}

    //if (flag == 1) {
      //state = stateParkIn;
      //carParkDelay = 0;
      //carParkTimes += 1;
      // leftPark = 1;
       //carParkTimes += 1;

    //}

}



void carpark_out()
{
    int flag = 0;
    uint8_t gapNumber = 0;
    for (int i = 55; i < 100; i++)
    {
        if (my_road[i + 1].white_num > 3 && my_road[i].white_num > 4 && my_road[i - 1].white_num > 3)
        {
            gapNumber = 0;
            for(int j = 1;j < my_road[i].white_num;j++)
            {
                if (my_road[i].connected[j].width < 6)
                {
                    gapNumber += 1;
                }
            }
            if (gapNumber > 3)
            {
                flag = 1;

            }

            if (flag == 1)
            {
                break;
            }

        }
    }

    for (int j = 75; j < 100; j++)
    {
        if (my_road[j].connected[j_continue[j]].width > 36)
        {
            flag = 1;
        }
    }
    //    }
    if (flag == 0) {
        state = 0;

        //carParkTimes += 1;

    }
}

////////////////////////////////////////////
//功能：车库补线
//输入：
//输出：
//备注：
///////////////////////////////////////////
void design_carpark()
{
    //int down_delta = 3, up_delta = 3;
    //int down_jump_point, up_jump_point;
    //float slope, k_left, k_right;
    //float kLeftUp, kRightUp;
    //int i, j;
    //int right_side[105];
    //int connected = 0;

    if(rightPark == 1 && leftPark == 0){
//        uint8_t j_mid[CAMERA_H];
//        for (int i = NEAR_LINE-2; i >= 2; i--) {
//            j_mid[i] = j_continue[i];
//            for (int j = 1; j <= my_road[i].white_num; j++) {
//                if (abs(my_road[i].connected[j].left - my_road[i + 1].connected[j_mid[i + 1]].left) < abs(my_road[i].connected[j_mid[i]].left - my_road[i + 1].connected[j_mid[i + 1]].left)
//                        ) {
//                    j_mid[i] = j;
//
//                }
//
//            }
//        }

        for(int i=105;i>=5;i--){
            left_line[i]=my_road[i].connected[1].left;
            right_line[i] = left_line[i] + 24;
        }

    }

    else if(leftPark == 1 && rightPark == 0){
//        uint8_t j_mid[CAMERA_H];
//        for (int i = NEAR_LINE - 2; i >= 2; i--) {
//            j_mid[i] = j_continue[i];
//            for (int j = 1; j <= my_road[i].white_num; j++) {
//                if (abs(my_road[i].connected[j].right - my_road[i + 1].connected[j_mid[i + 1]].right) <= abs(my_road[i].connected[j_mid[i]].right - my_road[i + 1].connected[j_mid[i + 1]].right)
//                        && my_road[i].connected[j].width > 1) {
//                    j_mid[i] = j;
//
//                }
//
//            }
//        }
        for(int i=105;i>=5;i--){
            right_line[i]=my_road[i].connected[my_road[i].white_num].right;
            left_line[i] = right_line[i] - 24;
        }

    }
//
//    for (int fixLine = 5; fixLine < 105; fixLine++)
//    {
//        if (rightPark == 1)
//        {
//            left_line[fixLine] = my_road[fixLine].connected[1].left;
//
//        }
//        else if (leftPark == 1)
//        {
//            right_line[fixLine] = my_road[fixLine].connected[j_mid[fixLine]].right;
//        }
//    }
//
//
//    for (int miss_x = 5; miss_x < 105; miss_x++)
//    {
//
//        if (rightPark == 1)
//        {
//            right_line[miss_x] = left_line[miss_x] + 28;
//
//
//        }
//        else if (leftPark == 1)
//        {
//            left_line[miss_x] = right_line[miss_x] - 28;
//
//        }
//
//    }
}

void searchParkLine()
{
    uint8_t i;
    uint8_t flag = 0;
    for(i = myParkLine; i < 105; i++)
    {
        if (my_road[i].white_num >= 2 && my_road[i + 1].white_num >= 2)
        {
            flag = 1;
            myParkLine = i;
            break;
        }
    }


//    test_varible[7] = myParkLine;
    if(i >= search_line.intVal && flag == 1)
    {
        flagStop = 1;
    }


//    else flagStop = 0;

//    test_varible[15] = i;
}


///////////////////////////////////////////
//功能：车库停车
//输入：
//输出：
//备注：
///////////////////////////////////////////
void carpark_stop() {

    int roof_line = NEAR_LINE;
    for (int i = NEAR_LINE; i >= 70; i--) {
        if (my_road[i - 1].white_num == 0 && my_road[i].white_num != 0) {
            roof_line = i;
            break;
        }
        if (i == 70) {
            return;
        }
    }
    test_varible[5] = roof_line;

    double ljl = linear_judgement(roof_line + 2, NEAR_LINE, left_line);
    double ljr= linear_judgement(roof_line + 2, NEAR_LINE, right_line);
    if (ljl < 10 && ljr < 10) {
        if (roof_line > stopLine.intVal) {
            car_stop = 1;
        }
    }
    else {
        if (roof_line > stopLine.intVal) {
            car_stop = 1;
        }
    }
}

///////////////////////////////////////////
//功能：开始入库的标志
//输入：
//输出：
//备注：
///////////////////////////////////////////
int sign_carPark_in() {
    //我们用扫线的方式来确定什么时候开始拐

    int flagBM = 0;
    int sumB = 0, sumB_max = 0;
    int sum_black = 0;
    uint8_t blackNum[CAMERA_H] = { 0 };
    double aveBlack = 0;
    double max_aveBlack = 0;
    int start_black = 119, end_black = 119;
    for (int i = NEAR_LINE; i >= 75; i--) {
        for (int j = 1; j < my_road[i].white_num; j++) {
            if (my_road[i].connected[j + 1].left - my_road[i].connected[j].right >= 1 && my_road[i].connected[j + 1].left - my_road[i].connected[j].right <= 5) {
                blackNum[i]++;
            }
        }

        if (blackNum[i] >= 2 && flagBM == 0) {
            flagBM = 1;
            sumB++;
            sum_black += blackNum[i];
            start_black = i;
        }
        else if (flagBM == 1 && blackNum[i] >= 2) {
            sumB++;
            sum_black += blackNum[i];
        }
        else {

            flagBM = 0;
            if (sumB > sumB_max) {
                sumB_max = sumB;
                if (sumB != 0) {
                    aveBlack = (double)sum_black / sumB;
                }
                end_black = i;
            }
            sum_black = 0;
            sumB = 0;

        }


    }
    return end_black;


}
////////////////////////////////////////////
//功能：开始入库的标志
//输入：
//输出：
//备注：
///////////////////////////////////////////
void design_carpark_turn() {

    int roof_black_line = sign_carPark_in();
    uint8_t searchLine = search_line.intVal;
    test_varible[4] = roof_black_line;
//    test_varible[5] = flagSee;
//    test_varible[6] = flagStop;
    if (roof_black_line >= searchLine && roof_black_line <= NEAR_LINE) {
        flagStop = 1;
        flagSee++;
        uint8_t j_mid[CAMERA_H];
        if (rightPark == 1 && leftPark == 0) {
            j_mid[NEAR_LINE] = 1;
            for (int i = NEAR_LINE - 1; i > 2; i--) {
                j_mid[i] = 1;
                for (int j = 1; j <= my_road[i].white_num; j++) {
                    if (abs(my_road[i].connected[j].left - my_road[i + 1].connected[j_mid[i + 1]].left) < abs(my_road[i].connected[j_mid[i]].left - my_road[i + 1].connected[j_mid[i + 1]].left)) {
                        j_mid[i] = j;
                    }
                }

            }
            double kd = calculate_slope_struct(80, 95, j_mid,LEFT);
            int upPoint = 119;
            int start = roof_black_line;
            while (start >= roof_black_line - 10 && my_road[start].connected[j_mid[start]].right < 94) start--;
            if (kd >= 0) {

                for (int i = start; i >= roof_black_line - 40; i--) {
                    if (my_road[i].connected[j_mid[i]].right - my_road[i + 1].connected[j_mid[i + 1]].right < -6
                        && my_road[i].connected[i].right - my_road[i + 2].connected[j_mid[i + 2]].right < -6
                        && abs(my_road[i].connected[j_mid[i]].right - my_road[i - 1].connected[j_mid[i - 1]].right) <= 3
                        && abs(my_road[i].connected[j_mid[i]].right - my_road[i - 2].connected[j_mid[i - 2]].right) <= 4
                        && my_road[i].connected[j_mid[i]].width < 40
                        ) {
                        upPoint = i;
                        break;
                    }
                }

            }
            else {
            }
            double k;
            if (upPoint < 105) {
                k = (double)(my_road[upPoint].connected[j_mid[upPoint]].right - my_road[NEAR_LINE].connected[j_mid[NEAR_LINE]].left) / (upPoint - NEAR_LINE);
            }
            else {
                k = calculate_slope_uint(70, 90, right_side);
            }
            if (my_road[80].white_num != 0) {
                for (int i = NEAR_LINE; i >= 50; i--) {
                    left_line[i] = k * (i - NEAR_LINE) + my_road[NEAR_LINE].connected[j_mid[NEAR_LINE]].left;
                    right_line[i] = right_side[i];
                }
            }



        }
        else if (rightPark == 0 && leftPark == 1) {
            j_mid[NEAR_LINE] = my_road[NEAR_LINE].white_num;
            for (int i = NEAR_LINE - 1; i > 2; i--) {
                j_mid[i] = my_road[i].white_num;
                for (int j = 1; j <= my_road[i].white_num; j++) {
                    if (abs(my_road[i].connected[j].right - my_road[i + 1].connected[j_mid[i + 1]].right) <= abs(my_road[i].connected[j_mid[i]].right - my_road[i + 1].connected[j_mid[i + 1]].right)) {
                        j_mid[i] = j;
                    }
                }

            }
            double kd = calculate_slope_struct(80, 95, j_mid, RIGHT);
            int upPoint = 119;
            int start = roof_black_line;
            while (start >= roof_black_line - 10 && my_road[start].connected[j_mid[start]].left > 94) start--;
            if (kd <= 0) {

                for (int i = start; i >= roof_black_line - 40; i--) {
                    if (my_road[i].connected[j_mid[i]].left - my_road[i + 1].connected[j_mid[i + 1]].left > 6
                        && my_road[i].connected[i].left - my_road[i + 2].connected[j_mid[i + 2]].left > 6
                        && abs(my_road[i].connected[j_mid[i]].left - my_road[i - 1].connected[j_mid[i - 1]].left) <= 3
                        && abs(my_road[i].connected[j_mid[i]].left - my_road[i - 2].connected[j_mid[i - 2]].left) <= 4
                        && my_road[i].connected[j_mid[i]].width < 40
                        ) {
                        upPoint = i;
                        break;
                    }
                }

            }
            else {
            }
            double k;
            if (upPoint < 105) {
                k = (double)(my_road[upPoint].connected[j_mid[upPoint]].left - my_road[NEAR_LINE].connected[j_mid[NEAR_LINE]].right) / (upPoint - NEAR_LINE);
            }
            else {
                k = calculate_slope_uint(70, 90, left_side);
            }
            if (my_road[80].white_num != 0) {
                for (int i = NEAR_LINE; i >= 50; i--) {
                    left_line[i] = left_side[i];
                    right_line[i] = k * (i - NEAR_LINE) + my_road[NEAR_LINE].connected[j_mid[NEAR_LINE]].right;
                }
            }

        }


    }
    else if (roof_black_line == 119 && flagSee >= 10) {
        if (rightPark == 1 && leftPark == 0) {
            uint8_t j_mid[CAMERA_H];
            j_mid[NEAR_LINE] = my_road[NEAR_LINE].white_num;
            for (int i = NEAR_LINE - 1; i > 2; i--) {
                j_mid[i] = my_road[NEAR_LINE].white_num;
                for (int j = 1; j <= my_road[i].white_num; j++) {
                    if (abs(my_road[i].connected[j].right - my_road[i + 1].connected[j_mid[i + 1]].right) < abs(my_road[i].connected[j_mid[i]].right - my_road[i + 1].connected[j_mid[i + 1]].right)) {
                        j_mid[i] = j;
                    }
                }

            }
            left_line[NEAR_LINE] = my_road[NEAR_LINE].connected[j_mid[NEAR_LINE]].left;
            right_line[NEAR_LINE] = my_road[NEAR_LINE].connected[j_mid[NEAR_LINE]].right;
            for (int i = NEAR_LINE - 1; i >= 50; i--) {
                left_line[i] = my_road[i].connected[j_mid[i]].left;
                right_line[i] = my_road[i].connected[j_mid[i]].right;
                if (right_line[i] < right_line[i + 1]) {
                    right_line[i] = right_line[i + 1];
                }
                if (left_line[i] < left_line[i + 1]) {
                    left_line[i] = left_line[i + 1];
                }
            }
        }
        else if (rightPark == 0 && leftPark == 1) {
            uint8_t j_mid[CAMERA_H];
            j_mid[NEAR_LINE] = 1;
            for (int i = NEAR_LINE - 1; i > 2; i--) {
                j_mid[i] = 1;
                for (int j = 1; j <= my_road[i].white_num; j++) {
                    if (abs(my_road[i].connected[j].left - my_road[i + 1].connected[j_mid[i + 1]].left) < abs(my_road[i].connected[j_mid[i]].left - my_road[i + 1].connected[j_mid[i + 1]].left)) {
                        j_mid[i] = j;
                    }
                }

            }
            left_line[NEAR_LINE] = my_road[NEAR_LINE].connected[j_mid[NEAR_LINE]].left;
            right_line[NEAR_LINE] = my_road[NEAR_LINE].connected[j_mid[NEAR_LINE]].right;
            for (int i = NEAR_LINE - 1; i >= 50; i--) {
                left_line[i] = my_road[i].connected[j_mid[i]].left;
                right_line[i] = my_road[i].connected[j_mid[i]].right;
                if (right_line[i] > right_line[i + 1]) {
                    right_line[i] = right_line[i + 1];
                }
                if (left_line[i] > left_line[i + 1]) {
                    left_line[i] = left_line[i + 1];
                }
            }
        }

    }

}

void carPark_main()
{
//    test_varible[14] = carParkTimes;
//    test_varible[15] = rightPark;
    if (state != stateParkIn)
    {
    //        test_varible[15] = leftPark;


        if(carParkTimes == 0)
        {
            if(file1.intVal == -1)
            {
                leftPark = 0;
                rightPark = 1;

                if(rampTimes >= 1)
                {
                    carpark_in();

                }
            }

            else if(file1.intVal == 0)
            {
                leftPark = 0;
                rightPark = 1;
                carpark_in();

            }

            else if(file1.intVal == 1)
            {
                leftPark = 1;
                rightPark = 0;
                if(tCrossTimes == 1)
                {
                    carpark_in();

                }
            }

        }

//        if(carParkTimes == 1 && parkJudgeCount > 200 && rampTimes >= 1)
//        {
//            carpark_in();
//    //            searchParkLine();
//
//        }


        if(carParkTimes == 1 && file1.intVal == 1)
        {
            if(parkJudgeCount <= 202)
            {
                parkJudgeCount += 1;

            }

            if(parkJudgeCount > 200 && rampTimes >= 1)
            {
                leftPark = 0;
                rightPark = 1;
                carpark_in();
            }

            else
            {
                leftPark = 1;
                rightPark = 0;
            }
    //            if(folkTimes < 4)
    //            {
    //                leftPark = 1;
    //                rightPark = 0;
    //            }
    //
    //            else if(folkTimes >= 4)
    //            {
    //                state = 0;
    //                leftPark = 0;
    //                rightPark = 1;
    //            }
        }

        else if(carParkTimes == 1 && file1.intVal == -1)
        {
            if(parkJudgeCount <= 22)
            {
                parkJudgeCount += 1;

            }

            if(parkJudgeCount > 20 && tCrossTimes >= 2)
            {
                leftPark = 1;
                rightPark = 0;
            }

            else
            {
                leftPark = 0;
                rightPark = 1;
            }
    //            if(tCrossTimes < 2)
    //            {
    //                leftPark = 0;
    //                rightPark = 1;
    //            }
    //
    //            else if(tCrossTimes >= 2)
    //            {
    //                state = 0;
    //                leftPark = 1;
    //                rightPark = 0;
    //            }


        }
        else if(carParkTimes == 1 && file1.intVal == 0)
        {
            if(parkJudgeCount <= 202)
            {
                parkJudgeCount += 1;

            }
            leftPark = 1;
            rightPark = 0;
        }


        else if(carParkTimes == 1 && file1.intVal == 2)
        {
            if(parkJudgeCount <= 202)
            {
                parkJudgeCount += 1;

            }
            leftPark = 0;
            rightPark = 1;
        }
        else if(carParkTimes == 1 && file1.intVal == -2)
        {
            if(parkJudgeCount <= 202)
            {
                parkJudgeCount += 1;

            }
            leftPark = 1;
            rightPark = 0;
        }


    }

    //    if(carParkTimes >= 1)
    //    {
    //        leftPark = 0;
    //        rightPark = 1;
    //        searchParkLine();
    //
    //    }
//    test_varible[6] = flagStop;
    //    test_varible[14] = carParkTimes;


    if (state == stateParkIn && carParkTimes < 2)
    {
//        CTRL_encoderCount();
        if(carParkDelay <= parkDelay.intVal)
        {
            carParkDelay += 1;
        }
        int direction = file1.intVal;
//        if(carParkDelay > parkDelay.intVal && carParkTimes < 2 && integerSpeedAver > 2000)
//        {
//            carpark_out();
//
//        }
        if(carParkDelay > parkDelay.intVal && direction == 1 && integerSpeedAver > 2000)
        {
            carpark_out();

        }
        else if(carParkDelay > parkDelay.intVal-3 && direction == -1 && integerSpeedAver > 100)
        {
            carpark_out();

        }
        else if(carParkDelay > parkDelay.intVal && direction == 0 && integerSpeedAver > 500)
        {
            carpark_out();

        }

        if(integerSpeedAver > 5000)
        {
            state = 0;
        }
        design_carpark();

    }

    if(carParkTimes == 2 && file1.intVal == 1)
    {
        if(flagStop == 1)
        {
            parkSlowDownCount += 1;

        }
        leftPark = 0;
        rightPark = 1;
//        searchParkLine();
        carpark_stop();
        design_carpark_turn();

    }
    else if(carParkTimes == 2 && file1.intVal == -1)
    {
        if(flagStop == 1)
        {
            parkSlowDownCount += 1;

        }
        leftPark = 1;
        rightPark = 0;
//        searchParkLine();
        design_carpark_turn();
    }
    else if(carParkTimes == 2 && file1.intVal == 0)
    {
        if(flagStop == 1)
        {
            parkSlowDownCount += 1;

        }
        leftPark = 1;
        rightPark = 0;
//        searchParkLine();
        design_carpark_turn();
    }
    else if(carParkTimes == 2 && file1.intVal == 2)
    {
        leftPark = 0;
        rightPark = 1;
        searchParkLine();

    }
    else if(carParkTimes == 2 && file1.intVal == -2)
    {
        leftPark = 1;
        rightPark = 0;
        searchParkLine();

    }
}

//void rampwayOn()
//{
//    int rampFlag1 = 0;
//    uint8_t mid_line[120];
//    double k_near_left, k_near_right, k_far_left, k_far_right;
//    k_near_left = calculate_two_point_slope(90, my_road[90].connected[j_continue[90]].left, 50, my_road[50].connected[j_continue[50]].left);
//    k_near_right = calculate_two_point_slope(90, my_road[90].connected[j_continue[90]].right, 50, my_road[50].connected[j_continue[50]].right);
//    k_far_left = calculate_two_point_slope(50, my_road[50].connected[j_continue[50]].left, 20, my_road[20].connected[j_continue[20]].left);
//    k_far_right = calculate_two_point_slope(90, my_road[50].connected[j_continue[50]].right, 20, my_road[20].connected[j_continue[20]].right);
//
//    for(int i=100;i>=10;i--){
//        if(left_line[i]!=MISS){
//            mid_line[i]=(left_line[i] + right_line[i]) / 2;
//        }
//    }
//    int width_max, width_min;
//
//    width_max = 0;
//    width_min =100;
//
//    for(int i=100;i>=10;i--){
//        if(my_road[i].connected[j_continue[i]].width>width_max){
//            width_max=my_road[i].connected[j_continue[i]].width;
//        }
//        if(my_road[i].connected[j_continue[i]].width<width_min){
//            width_min=my_road[i].connected[j_continue[i]].width;
//        }
//    }
//    if(my_road[5].white_num != 0)
//    {
//        if(TFMINI_Distance < rampDistance.intVal && straight_variance(90, 30, 16) == 2)
//        {
//            if(fabs(k_near_left) < 0.5 && fabs(k_near_right) < 0.5 && fabs(k_far_left) < 0.5 && fabs(k_far_right) < 0.5 && fabs(k_near_right - k_far_right) < 0.2 && fabs(k_near_left - k_far_left) < 0.2)
//            {
//                if(width_max - width_min >= rampMin.intVal && width_max - width_min <= rampMax.intVal)
//                {
//                    if(my_road[80].connected[j_continue[80]].width < my_road[40].connected[j_continue[40]].width && my_road[50].connected[j_continue[50]].width < my_road[20].connected[j_continue[20]].width)
//                    {
//                        rampFlag1 = 1;
//
//                    }
//
//                }
//            }
//
//
//        }
//
//    }
//
//    if(rampFlag1 == 1)
//    {
//            state = stateRampway;
////            rampTimes += 1;
//            rampJudgeCount = 0;
//
//    }
//}

void rampwayOn()
{
    int rampFlag = 0;
    if(TFMINI_Distance <= rampDistance.intVal && TFMINI_Distance != 0)
    {
//        for(int i = 80;i <= 100; i++)
//        {
//            if(mid_line[i] > 106 || mid_line[i] < 80)
//            {
                rampFlag = 1;
//            }

//        }

        if(rampFlag == 1)
        {
            state = stateRampway;
            rampTimes += 1;
        }
    }
}

void rampwayDown()
{
    CTRL_rampGyroUpdate();


    if(TFMINI_Distance > 150)
    {
        if(lastTwoState == 0)
        {
            lastTwoState = 1;
        }
    }

    if(TFMINI_Distance < rampDistance.intVal &&TFMINI_Distance != 0 && lastTwoState == 1 && inv_accl[2] < 9.45)
    {
        state = 0;

        rampJudgeCount = 0;

//        GPIO_Set(P22, 0, 0);
    }

}

int midMaxColumn(int istart, int iend, int param)
{

    int count1 = 0;
    int count2 = istart - iend - param;
    for(int i = istart; i > iend; i--)
    {
        if(right_line[i] - left_line[i] < 32 && mid_line[i] >= 88 && mid_line[i] <= 98)
        {
            count1 += 1;
        }

    }
    if(count1 > count2)
    {
        return 1;

    }
    else return 0;


}

int straight_variance(int istart, int iend, float varThreshold)
{
    float k, b;
    int output;
    int sumVar = 0, count = 0;
    float var = 0;
    k = (float)(mid_line[istart] - mid_line[iend]) / (istart - iend);
    for (int i = istart; i > iend; i--)
    {
        output = k * (i - istart) + mid_line[istart];
        output = output - mid_line[i];
        output *= output;
        sumVar += output;
        count += 1;
    }
    var = (float)(sumVar) / count;
//    test_varible[15] = var;

    if (var > varThreshold)
    {
        return 1;
    }
    else if(var <= varThreshold)
    {
        return 2;

    }

    else return 0;
}

void straight_define()
{
//    for(int i = presentVision.intVal;i>60;i--)
//    {
//
//    }

    /*省赛赛道先不用*/
    int vision = present_vision;
    if(straightFlag == 0)
    {
        if(tCrossTimes == 1 && (state == stateStart || state == stateParkIn) && speedUpPhase == 0)
        {
            if(state != stateTOut && integerSpeedAver >= 500)
            {
                straightFlag = 0;
                speedUpPhase = 1;

            }

        }

        else if(folkOutTimes == 1 && speedUpPhase == 1)
        {
            straightFlag = 1;
            speedUpPhase = 2;
        }

        else if(islandFinalTimes == 1 && straight_variance(92, 70, 10) == 2 && speedUpPhase == 2)
        {
            straightFlag = 0;
            speedUpPhase = 3;
        }

    }



    else if(straightFlag == 1)
    {
        if(speedUpPhase == 1)
        {
            if(integerSpeedAver >= 8000 && midMaxColumn(95, 75, 4) == 0)
            {
                straightFlag = 0;
            }
        }

        else if(speedUpPhase == 2)
        {
            if(folkTimes == 2)
            {
                straightFlag = 0;
            }
        }

        else if(speedUpPhase == 3)
        {
            if(state == stateTIn)
            {
                straightFlag = 0;
            }
        }
//        if(straight_variance(95, 60, 8) == 2 && midMaxColumn(95, 60, 2) == 1)
//        {
//            straightFlag = 1;
//        }
//
//        else
//        {
//            straightFlag = 0;
//        }
    }

//    /*省赛记忆加速*/
//    if(tCross == 1 && (state == stateStart || state == stateParkIn))
//    {
//        if(straight_variance(95, 60, 8) ==  2 && )
//    }

//    if(state == 120 && carParkTimes < 2)
//    {
//        straightFlag = 1;
//
//    }
//
//    if(straightFlag == 0 && calculate_two_point_slope(100, mid_line[100], 80, mid_line[80]) < 0.6 && ((straight_variance(vision+5, 60, 8) == 2 && midMaxColumn(vision, 40, 2) == 1) || straight_variance(vision+5, 40, 8) == 2))
//    {
//        if(state == 10)
//        {
//            if(my_road[20].white_num != 0)
//            {
//                straightFlag = 1;
//
//            }
//        }
//
//
//
//        if(state == 0)
//        {
//            if(my_road[20].white_num != 0)
//            {
//                straightFlag = 1;
//
//            }
//        }
//    }

//    else if(straightFlag == 1)
//    {
//
//        if(state == 130)
//        {
//            straightFlag = 0;
//        }
//
//        if(state == 120)
//        {
//            straightFlag = 1;
//        }
//
//        if(state == 10)
//        {
//            straightFlag = 1;
//
//        }
//        else if(state == 0)
//        {
//            if((straight_variance(vision+5, 60, 20) == 2 && midMaxColumn(vision, 60, 6) == 1) || midMaxColumn(vision, 60, 5) == 1)
//            {
//
//                straightFlag = 1;
//
//            }
//
//            else {
//
//                if(lastStraight==0){
//                    lastStraight=1;
//                }
//                else if(lastStraight == 1){
//                    straightFlag = 0;
//                    lastStraight = 0;
//                }
//            }
//        }
//        else straightFlag = 0;
//    }

//    test_varible[6] = straightFlag;
}


void roadMemory()
{
//    if(raceMemory.intVal == 1)
//    {
//        if(parkStart == 0 && memoryFlag == 0)
//        {
//            memoryState[0] = 1;
//            memoryFlag = 1;
//        }
//
//
//        if(state == memory2.intVal && memoryState[0] == 1)
//        {
//            memoryState[0] = 0;
//            memoryState[1] = 1;
//        }
//
//        if(state == memory3.intVal && memoryState[1] == 1)
//        {
//            memoryState[1] = 0;
//            memoryState[2] = 1;
//        }
//
//        if(state == memory4.intVal && memoryState[2] == 1)
//        {
//            memoryState[2] = 0;
//            memoryState[3] = 1;
//        }
//        if(state == memory5.intVal && memoryState[3] == 1)
//        {
//            memoryState[3] = 0;
//            memoryState[4] = 1;
//        }
//        if(state == memory6.intVal && memoryState[4] == 1)
//        {
//            memoryState[4] = 0;
//            memoryState[5] = 1;
//        }
//        if(state == memory7.intVal && memoryState[5] == 1)
//        {
//            memoryState[5] = 0;
//            memoryState[6] = 1;
//        }
//        if(state == memory8.intVal && memoryState[6] == 1)
//        {
//            memoryState[6] = 0;
//            memoryState[7] = 1;
//        }
//        if(state == memory9.intVal && memoryState[7] == 1)
//        {
//            memoryState[7] = 0;
//            memoryState[8] = 1;
//        }
//
//        if(state == memory10.intVal && memoryState[8] == 1)
//        {
//            memoryState[8] = 0;
//            memoryState[9] = 1;
//        }
//        if(state == memory11.intVal && memoryState[9] == 1)
//        {
//            memoryState[9] = 0;
//            memoryState[10] = 1;
//        }
//        if(state == memory12.intVal && memoryState[10] == 1)
//        {
//            memoryState[10] = 0;
//            memoryState[11] = 1;
//        }
//        if(state == memory13.intVal && memoryState[11] == 1)
//        {
//            memoryState[11] = 0;
//            memoryState[12] = 1;
//        }
//        if(state == memory14.intVal && memoryState[12] == 1)
//        {
//            memoryState[12] = 0;
//            memoryState[13] = 1;
//        }
//        if(state == memory15.intVal && memoryState[13] == 1)
//        {
//            memoryState[13] = 0;
//            memoryState[14] = 1;
//        }
//    }

}

void small_s_road()
{
    int i1, i2, i3;
    double k1 = 0, k2 = 0, k3 = 0;
    uint8_t aveMidLine;
    for (i1 = 105; i1 > 60; i1--)
    {
        if (mid_line[i1 + 2] == mid_line[i1 + 1] && mid_line[i1 + 1] == mid_line[i1] && mid_line[i1] == mid_line[i1 - 1] && mid_line[i1 - 1] == mid_line[i1 - 2])
        {
            k1 = calculate_two_point_slope(105, mid_line[105], i1, mid_line[i1]);
            break;
        }

    }
    for (i2 = 50; i2 < i1; i2++)
    {
        if (mid_line[i2 + 2] == mid_line[i2 + 1] && mid_line[i2 + 1] == mid_line[i2] && mid_line[i2] == mid_line[i2 - 1] && mid_line[i2 - 1] == mid_line[i2 - 2])
        {
            k2 = calculate_two_point_slope(i1, mid_line[i1], i2, mid_line[i2]);
            break;
        }
    }

    for (i3 = i2; i3 > 30; i3--)
    {
        if (mid_line[i3 + 2] == mid_line[i3 + 1] && mid_line[i3 + 1] == mid_line[i3] && mid_line[i3] == mid_line[i3 - 1] && mid_line[i3 - 1] == mid_line[i3 - 2])
        {

            //break;
        }
        k3 = calculate_two_point_slope(i2, mid_line[i2], 30, mid_line[30]);
    }

    if (fabs(k1) < 0.6 && fabs(k1) > 0.1 && fabs(k2) < 0.1 && fabs(k3) < 0.6 && fabs(k3) > 0.1 && (i1 - i2) > 15)
    {
        sRoadFlag = 1;

    }
}

void s_road_filter()
{
    for(int i = 100; i > 55; i--)
    {
        mid_line[i] = (uint8_t)((mid_line[i] + mid_line[i+1] + mid_line[i+2]) / 3);
    }
}

void mid_line_filter() {

    for (int i = NEAR_LINE - 4; i > 3; i--)
    {
        if (left_line[i] != MISS && my_road[i].white_num != 0) {
            if (abs(mid_line[i] - mid_line[i + 1]) > 20)
            {
                mid_line[i] = mid_line[i + 1];
            }
            else
            {
                mid_line[i] = (mid_line[i - 1] + mid_line[i] + mid_line[i + 1]) / 3;
            }
        }

    }
    mid_line[0] = mid_line[1] = mid_line[2] = mid_line[3] = mid_line[4];

}

void big_mid_line_filter() {

    for (int i = NEAR_LINE - 3; i > 4; i--)
    {
        if (left_line[i] != MISS && my_road[i].white_num != 0) {
            if (abs(mid_line[i] - mid_line[i + 1]) > 10)
            {
                mid_line[i] = mid_line[i + 1] - (mid_line[i + 1] - mid_line[i]) * 0.1;
            }
            else
            {
                mid_line[i] = (mid_line[i - 3] + mid_line[i - 2] + mid_line[i - 1] + mid_line[i] + mid_line[i + 1] + mid_line[i + 2] + mid_line[i + 3]) / 7;
            }
        }

    }
    mid_line[0] = mid_line[1] = mid_line[2] = mid_line[3] = mid_line[4];

}

uint8_t mid_aver() {
    uint8_t mid;
    uint8_t validRow;
    validRow = valid_row();
    //最平均的算法
    int way = 2;
    if (way == 1) {
        int sum = 0;
        for (int i = NEAR_LINE; i > 30; i--) {
            sum += mid_line[i];
        }
        mid = sum / (NEAR_LINE - 30);
    }
    else if (way == 2) {

        if(validRow < 30)
        {
            int sumU = 0, sumM = 0, sumD = 0;

            for (int i = 105; i > 75; i--) {
                sumD += mid_line[i];
            }
            for (int i = 75; i > 45; i--) {
                sumM += mid_line[i];
            }
            for (int i = 45; i > 25; i--) {
                sumU += mid_line[i];
            }

            mid = (sumU * 0.05) / (45 - 25) + (sumM * 0.2) / (75 - 45) + (sumD * 0.75) / (105 - 75);
        }

        else if(validRow >= 30 && validRow < 50)
        {
            int sumU = 0, sumM = 0, sumD = 0;

            for (int i = 105; i > 80; i--) {
                sumD += mid_line[i];
            }
            for (int i = 80; i > 55; i--) {
                sumM += mid_line[i];
            }
            for (int i = 55; i > validRow; i--) {
                sumU += mid_line[i];
            }

            mid = (sumU * 0.05) / (55 - validRow) + (sumM * 0.25) / (80 - 55) + (sumD * 0.7) / (105 - 80);
        }

        else if(validRow >= 50 && validRow < 70)
        {
            int sumU = 0, sumM = 0, sumD = 0;

            for (int i = 105; i > 90; i--) {
                sumD += mid_line[i];
            }
            for (int i = 90; i > 70; i--) {
                sumM += mid_line[i];
            }
            for (int i = 70; i > validRow; i--) {
                sumU += mid_line[i];
            }

            mid = (sumU * 0.1) / (70 - validRow) + (sumM * 0.5) / (90 - 70) + (sumD * 0.4) / (105 - 90);
        }

        else if(validRow >= 70)
        {
            int sumU = 0, sumM = 0, sumD = 0;

            for (int i = 105; i > 90; i--) {
                sumD += mid_line[i];
            }
            for (int i = 90; i > 70; i--) {
                sumM += mid_line[i];
            }


            mid = (sumM * 0.5) / (90 - 70) + (sumD * 0.5) / (105 - 90);
        }
    }

    return mid;
}


uint8_t valid_row()
{
    uint8_t row;
    for(row = NEAR_LINE-2; row >= 10; row--)
    {
        if(my_road[row].white_num != 0 && my_road[row-1].white_num == 0)
        {
            break;
        }

    }
    return row;

}

int8 valid_row_direction()
{
    uint8_t validRow;
    uint8_t leftRowCount = 0,rightRowCount = 0;
    uint8_t rowDelta;

    validRow = valid_row();
    rowDelta = NEAR_LINE - validRow - 2;

    for(int i = NEAR_LINE-2; i > validRow; i--)
    {
        if(mid_line[i] < 94)
        {
            leftRowCount += 1;

        }
        else if(mid_line[i] > 94)
        {
            rightRowCount += 1;
        }

    }
    if(rowDelta > 20)//有效行在92行之前
    {
        if((leftRowCount >= (rowDelta - 5) && rightRowCount <= 5) || leftRowCount - rightRowCount > (rowDelta / 2))//左
        {
            return 1;
        }

        else if((rightRowCount >= (rowDelta - 5) && leftRowCount <= 5) || rightRowCount - leftRowCount > (rowDelta / 2))
        {
            return 2;
        }
        else return 0;

    }

    else if(rowDelta <= 20 && rowDelta >= 2)
    {
        if((leftRowCount >= (rowDelta - 5) && rightRowCount <= 5) || leftRowCount - rightRowCount > (rowDelta / 2))//左
        {
            return 1;
        }

        else if((rightRowCount >= (rowDelta - 5) && leftRowCount <= 5) || rightRowCount - leftRowCount > (rowDelta / 2))
        {
            return 2;
        }
        else return 0;
    }

    else return 0;
}

void TcircleFix()
{
    int8 direction;
    uint8_t validRow;

    validRow = valid_row();

    if(state == stateTIn && validRow > 70)
    {
        direction = valid_row_direction();
        if(direction == 1)
        {
            if(validRow >= cross_circle_param8.intVal)
            {
                pwmFix = (uint32)((validRow - cross_circle_param8.intVal) * cross_circle_param7.floatVal);

            }
            else pwmFix = 0;

        }

        else if(direction == 2)
        {
            if(validRow > cross_circle_param8.intVal)
            {
                pwmFix = (uint32)((cross_circle_param8.intVal - validRow) * cross_circle_param7.floatVal);

            }
            else pwmFix = 0;

        }

    }


//    else if(state == stateIslandCircle && validRow > 70)
//    {
//        direction = islandWhere;
//        if(direction == LEFT)
//        {
//            if(validRow >= cross_circle_param8.intVal)
//            {
//                pwmFix = (uint32)((validRow - cross_circle_param8.intVal) * cross_circle_param7.floatVal);
//
//            }
//            else pwmFix = 0;
//        }
//
//        else if(direction == RIGHT)
//        {
//            if(validRow >= cross_circle_param8.intVal)
//            {
//                pwmFix = (uint32)((cross_circle_param8.intVal - validRow) * cross_circle_param7.floatVal);
//
//            }
//            else pwmFix = 0;
//
//        }
//    }

//    else if(validRow >= cross_circle_param8.intVal)
//    {
//        direction = valid_row_direction();
//        if(direction == 1)//左
//        {
//            if(validRow >= cross_circle_param8.intVal)
//            {
//                pwmFix = (uint32)((validRow - cross_circle_param8.intVal) * cross_circle_param7.floatVal);
//
//            }
//
//        }
//
//        else if(direction == 2)//右
//        {
//            if(validRow >= cross_circle_param8.intVal)
//            {
//                pwmFix = (uint32)((cross_circle_param8.intVal - validRow) * cross_circle_param7.floatVal);
//
//            }
//
//        }
//        else pwmFix = 0;
//    }

    else pwmFix = 0;

//    test_varible[14] = pwmFix;
}



uint8_t aver_mid_line_foresee()
{
    uint8_t averageMidLine;
    float vision1 = mid_line[present_vision], vision2 = mid_line[present_vision - 1], vision3 = mid_line[present_vision + 1];

    averageMidLine = (uint8_t)(vision1 * 0.6 + vision2 * 0.2 + vision3 * 0.2);
    return averageMidLine;
}


////////////////////////////////////////////
//功能：前后求平均位置滤波
//输入：uint8_t left_line[CHANGED_H];//左边线  uint8_t right_line[CHANGED_H];//右边线
//输出：uint8_t left_smooth[CHANGED_H];//左滤波 uint8_t right_smooth[CHANGED_H];//右滤波
//备注：2020.2.19添加 copy学长
///////////////////////////////////////////
void filter_two_line(void)
{
    int gap=5;
    uint8_t left_smooth[CAMERA_H];
    uint8_t right_smooth[CAMERA_H];
    uint8_t i_start;
    uint8_t i_end;
    uint8_t i;
    int j_add = 0;
    uint8_t num = 2;//向上或向下要取多少个点
    uint8_t sum;
    uint8_t left_top = NEAR_LINE - gap, right_top = NEAR_LINE + gap;
    sum = 2 * num + 1;//每个点的值由周围总共几个点决定

    for (i = NEAR_LINE; i >= FAR_LINE; i--)
        if (left_line[i] != MISS)left_top = i;
        else break;

    for (i = NEAR_LINE; i >= FAR_LINE; i--)
        if (right_line[i] != MISS)right_top = i;
        else break;



    //memset(left_smooth, MISS, CHANGED_H);
    //memset(right_smooth, MISS, CHANGED_H);

    //左边界

    i_start = NEAR_LINE - num;
    i_end = left_top + num;

    for (i = NEAR_LINE; i >= i_start + 1; i--)
        left_smooth[i] = left_line[i];

    for (i = i_end - 1; i >= left_top; i--)
        left_smooth[i] = left_line[i];

    j_add = 0;
    for (i = NEAR_LINE; i >= NEAR_LINE - sum + 1; i--)
        j_add += left_line[i];

    for (i = i_start; i >= i_end; i--)
    {
        left_smooth[i] = j_add / sum;
        //IMG[i][left_smooth[i]] = green;
        if (i == i_end)break;
        j_add -= left_line[i + num];
        j_add += left_line[i - num - 1];
    }

    //右边界
    i_start = NEAR_LINE - num;
    i_end = right_top + num;

    for (i = NEAR_LINE; i >= i_start + 1; i--)
        right_smooth[i] = right_line[i];

    for (i = i_end - 1; i >= right_top; i--)
        right_smooth[i] = right_line[i];

    j_add = 0;
    for (i = NEAR_LINE; i >= NEAR_LINE - sum + 1; i--)
        j_add += right_line[i];

    for (i = i_start; i >= i_end; i--)
    {
        right_smooth[i] = j_add / sum;
        //IMG[i][right_smooth[i]] = green;
        if (i == i_end)break;
        j_add -= right_line[i + num];
        j_add += right_line[i - num - 1];
    }
    for (int i = i_start; i <= i_end; i++) {
        left_line[i] = left_smooth[i];
        right_line[i] = right_smooth[i];
    }


}//filter_two_line

void folkTimesCNT()
{
    if(file1.intVal == 1 || file1.intVal == 0)
    {
        if(folkTimes == 0)
        {
            if(integerSpeedAver >= 9000)
            {
                folkCNT = 1;

            }

            if(folkCNT < 1 && state == stateFolkRoadIn) //没有跑到一定距离就识别出三叉 则认为是误识别
            {
                state = 0;
                folkCNT = 0;
            }
        }

        else if(folkTimes == 1 && folkOutTimes == 1)
        {
            if(integerSpeedAver >= 9000 && integerSpeedCNT >= 37000)
            {
                folkCNT = 2;

            }

            if(folkCNT < 2 && state == stateFolkRoadIn) //没有跑到一定距离就识别出三叉 则认为是误识别
            {
                state = 0;
                folkCNT = 1;
            }
        }

        else if(folkTimes == 2 && folkCNT == 2 && folkOutTimes == 2)
        {
            if(integerSpeedAver >= 6000 && integerSpeedCNT > 140000 && islandTimesCNT == 2)
            {
                folkCNT = 3;

            }

            if(folkCNT < 3 && state == stateFolkRoadIn) //没有跑到一定距离就识别出三叉 则认为是误识别
            {
                state = 0;
                folkCNT = 2;
            }
        }

        else if(folkTimes == 3 && folkCNT == 3 && folkOutTimes == 3)
        {
            if(integerSpeedAver >= 3500 && integerSpeedCNT >= 140000)
            {
                folkCNT = 4;
            }

            if(folkCNT < 4 && state == stateFolkRoadIn) //没有跑到一定距离就识别出三叉 则认为是误识别
            {
                state = 0;
                folkCNT = 3;
            }
        }
    }

//    else if(folkTimes == 4)
//    {
//
//    }
}


// 以下是废案，没有成功的代码，以防万一需要使用的内容
////////////////////////////////////////////
//功能：环岛开始
//输入：
//输出：
//备注：
///////////////////////////////////////////
void island_start() {

    //int flag = 0;


    //for (int i = 106; i > 10; i--) {
    //    if (right_line[i - 1] - right_line[i] > 4 && right_line[i - 2] - right_line[i] > 4
    //        && left_line[i - 1] - left_line[i] <= 2 && left_line[i - 2] - left_line[i] <= 2) {
    //        islandWhere = RIGHT;
    //        break;
    //    }
    //    if (left_line[i - 1] - left_line[i] < -4 && left_line[i - 2] - left_line[i] < -4
    //        && right_line[i - 1] - right_line[i] <= 2 && right_line[i - 2] - right_line[i] <= 2) {
    //        islandWhere = LEFT;
    //        break;
    //    }
    //}

    //if (islandWhere == RIGHT) {
    //    //左侧是直道
    //    uint8_t j_mid[CAMERA_H];
    //    for (int i = NEAR_LINE; i >= 2; i--) {
    //        j_mid[i] = j_continue[i];
    //        for (int j = 1; j <= my_road[i].white_num; j++) {
    //            if (abs(my_road[i].connected[j].left - my_road[i + 1].connected[j_mid[i + 1]].left) < abs(my_road[i].connected[j_mid[i]].left - my_road[i + 1].connected[j_mid[i + 1]].left)
    //                && my_road[i].connected[j].width > 10) {
    //                j_mid[i] = j;

    //            }

    //        }
    //    }
    //    double kl1 = calculate_slope_struct(20, 40, j_mid, LEFT);
    //    double kl2 = calculate_slope_struct(50, 70, j_mid, LEFT);
    //    double kl3 = calculate_slope_struct(80, 100, j_mid, LEFT);

    //    if (fabs(kl1 - kl2) < 0.2 && fabs(kl1 - kl3) < 0.2 && fabs(kl2 - kl3) < 0.2) {

    //        int downPoint = 119;
    //        if (calculate_slope_struct(80, 95, j_mid, LEFT) <= 0) {
    //            for (int i = NEAR_LINE - 1; i >= 30; i--) {
    //                if (my_road[i - 1].connected[j_mid[i - 1]].right - my_road[i].connected[j_mid[i]].right > 4
    //                    && abs(my_road[i + 1].connected[j_mid[i + 1]].right - my_road[i].connected[j_mid[i]].right) <= 2
    //                    && my_road[i].connected[j_mid[i]].width < 40
    //                    && my_road[i + 1].connected[j_mid[i + 1]].width < 40
    //                    ) {
    //                    downPoint = i;
    //                    break;
    //                }
    //            }

    //        }
    //        else {

    //            int num = 105;
    //            downPoint = num;
    //            while (num >= 40 && my_road[num].connected[j_mid[num]].right <= right_side[num] - 1
    //                && abs(my_road[num - 1].connected[j_mid[num - 1]].right - my_road[num].connected[j_mid[num]].right) <= 4
    //                && abs(my_road[num + 1].connected[j_mid[num + 1]].right - my_road[num].connected[j_mid[num]].right) <= 4
    //                ) {
    //                if (my_road[num].connected[j_mid[num]].right <= my_road[downPoint].connected[j_mid[downPoint]].right + 1

    //                    ) {
    //                    downPoint = num;
    //                }

    //                num--;
    //            }
    //        }
    //        // //////////////////////printf("dp=%d", downPoint);
    //         //下方是直道，控制一下
    //        if (fabs(calculate_slope_struct(downPoint + 1, downPoint + 15, j_mid, LEFT) - calculate_slope_struct(downPoint + 1, downPoint + 15, j_mid, RIGHT)) < 0.2
    //            && downPoint <= 110) {
    //            //寻找上方圆环
    //            int upPoint = 119;
    //            double kr = calculate_slope_struct(downPoint + 1, downPoint + 15, j_mid, RIGHT);
    //            int rightRoad[CAMERA_H];
    //            rightRoad[downPoint + 1] = my_road[downPoint + 1].connected[j_mid[downPoint + 1]].right + 10;
    //            for (int i = downPoint; i >= 2; i--) {
    //                rightRoad[i] = kr * (i - downPoint) + my_road[downPoint].connected[j_mid[downPoint]].right + 10;
    //                IMG[i][rightRoad[i]] = purple;
    //                if ((my_road[i + 1].connected[j_mid[i + 1]].right >= rightRoad[i + 1] && my_road[i].connected[j_mid[i]].right < rightRoad[i])
    //                    || (my_road[i + 1].connected[j_mid[i + 1]].right > rightRoad[i + 1] && my_road[i].connected[j_mid[i]].right <= rightRoad[i])) {
    //                    upPoint = i;
    //                    break;
    //                }
    //            }
    //            //根据找到的点，确定周围环岛点
    //            int rightCircle[CAMERA_H];
    //            //向下
    //            int downC = upPoint;
    //            int upC = upPoint;
    //            rightCircle[upPoint] = my_road[upPoint].connected[j_mid[upPoint]].right;
    //            for (int i = 1; i <= 10; i++) {
    //                if (abs(my_road[upPoint + i].connected[j_mid[upPoint + i]].right - my_road[upPoint + i - 1].connected[j_mid[upPoint + i - 1]].right) <= 7
    //                    && upPoint + i < downPoint - 2
    //                    && my_road[upPoint + i].connected[j_mid[upPoint + i]].right < right_side[upPoint + i] - 1
    //                    ) {
    //                    rightCircle[upPoint + i] = my_road[upPoint + i].connected[j_mid[upPoint + i]].right;
    //                    downC = upPoint + i;
    //                }
    //                else {

    //                    break;
    //                }
    //            }
    //            for (int i = 1; i <= 10; i++) {
    //                if (abs(my_road[upPoint - i].connected[j_mid[upPoint - i]].right - my_road[upPoint - i + 1].connected[j_mid[upPoint - i + 1]].right) <= 7
    //                    && upPoint - i > 2
    //                    && my_road[upPoint - i].connected[j_mid[upPoint - i]].right < right_side[upPoint - i] - 1
    //                    ) {
    //                    rightCircle[upPoint - i] = my_road[upPoint - i].connected[j_mid[upPoint - i]].right;
    //                    upC = upPoint - i;
    //                }
    //                else {

    //                    break;
    //                }
    //            }
    //            double dk = fabs(calculate_slope(upC, downC, rightCircle) - calculate_slope_struct(downPoint + 1, downPoint + 15, j_mid, RIGHT));
    //            ////////////////////////printf("upC=%d,downC=%d,k=%f,dk=%f\n", upC, downC,calculate_slope(upC,downC,rightCircle),fabs(calculate_slope(upC, downC, rightCircle)- calculate_slope_struct(downPoint + 1, downPoint + 15, j_mid, RIGHT)));

    //            if (dk > 0.55) {
    //                if (75 < downPoint && downPoint < 110) {
    //                    state = stateIslandIn;
    //                }
    //            }
    //        }
    //    }



    //}
    //else if (islandWhere == LEFT) {
    //    uint8_t j_mid[CAMERA_H];
    //    for (int i = NEAR_LINE; i >= 2; i--) {
    //        j_mid[i] = j_continue[i];
    //        for (int j = 1; j <= my_road[i].white_num; j++) {
    //            if (abs(my_road[i].connected[j].right - my_road[i + 1].connected[j_mid[i + 1]].right) < abs(my_road[i].connected[j_mid[i]].right - my_road[i + 1].connected[j_mid[i + 1]].right)
    //                && my_road[i].connected[j].width > 10) {
    //                j_mid[i] = j;

    //            }

    //        }
    //    }
    //    double kl1 = calculate_slope_struct(20, 40, j_mid, RIGHT);
    //    double kl2 = calculate_slope_struct(50, 70, j_mid, RIGHT);
    //    double kl3 = calculate_slope_struct(80, 100, j_mid, RIGHT);

    //    if (fabs(kl1 - kl2) < 0.2 && fabs(kl1 - kl3) < 0.2 && fabs(kl2 - kl3) < 0.2) {

    //        int downPoint = 119;
    //        if (calculate_slope_struct(80, 95, j_mid, RIGHT) >= 0) {
    //            for (int i = NEAR_LINE - 1; i >= 30; i--) {
    //                if (my_road[i - 1].connected[j_mid[i - 1]].right - my_road[i].connected[j_mid[i]].right > 4
    //                    && abs(my_road[i + 1].connected[j_mid[i + 1]].right - my_road[i].connected[j_mid[i]].right) <= 2
    //                    && my_road[i].connected[j_mid[i]].width < 40
    //                    && my_road[i + 1].connected[j_mid[i + 1]].width < 40
    //                    ) {
    //                    downPoint = i;
    //                    break;
    //                }
    //            }

    //        }
    //        else {

    //            int num = 105;
    //            downPoint = num;
    //            while (num >= 40 && my_road[num].connected[j_mid[num]].left >= left_side[num] + 1
    //                && abs(my_road[num - 1].connected[j_mid[num - 1]].left - my_road[num].connected[j_mid[num]].left) <= 4
    //                && abs(my_road[num + 1].connected[j_mid[num + 1]].left - my_road[num].connected[j_mid[num]].left) <= 4
    //                ) {
    //                if (my_road[num].connected[j_mid[num]].left <= my_road[downPoint].connected[j_mid[downPoint]].left - 1

    //                    ) {
    //                    downPoint = num;
    //                }

    //                num--;
    //            }
    //        }
    //        // //////////////////////printf("dp=%d", downPoint);
    //         //下方是直道，控制一下
    //        if (fabs(calculate_slope_struct(downPoint + 1, downPoint + 15, j_mid, RIGHT) - calculate_slope_struct(downPoint + 1, downPoint + 15, j_mid, LEFT)) < 0.2
    //            && downPoint <= 110) {
    //            //寻找上方圆环
    //            int upPoint = 119;
    //            double kl = calculate_slope_struct(downPoint + 1, downPoint + 15, j_mid, LEFT);
    //            int leftRoad[CAMERA_H];
    //            leftRoad[downPoint + 1] = my_road[downPoint + 1].connected[j_mid[downPoint + 1]].left - 10;
    //            for (int i = downPoint; i >= 2; i--) {
    //                leftRoad[i] = kl * (i - downPoint) + my_road[downPoint].connected[j_mid[downPoint]].left - 10;
    //                IMG[i][leftRoad[i]] = purple;
    //                if ((my_road[i + 1].connected[j_mid[i + 1]].left <= leftRoad[i + 1] && my_road[i].connected[j_mid[i]].left > leftRoad[i])
    //                    || (my_road[i + 1].connected[j_mid[i + 1]].left < leftRoad[i + 1] && my_road[i].connected[j_mid[i]].left >= leftRoad[i])) {
    //                    upPoint = i;
    //                    break;
    //                }
    //            }
    //            //根据找到的点，确定周围环岛点
    //            int leftCircle[CAMERA_H];
    //            //向下
    //            int downC = upPoint;
    //            int upC = upPoint;
    //            leftCircle[upPoint] = my_road[upPoint].connected[j_mid[upPoint]].left;
    //            for (int i = 1; i <= 10; i++) {
    //                if (abs(my_road[upPoint + i].connected[j_mid[upPoint + i]].left - my_road[upPoint + i - 1].connected[j_mid[upPoint + i - 1]].left) <= 7
    //                    && upPoint + i < downPoint - 2
    //                    && my_road[upPoint + i].connected[j_mid[upPoint + i]].left > left_side[upPoint + i] + 1
    //                    ) {
    //                    leftCircle[upPoint + i] = my_road[upPoint + i].connected[j_mid[upPoint + i]].right;
    //                    downC = upPoint + i;
    //                }
    //                else {

    //                    break;
    //                }
    //            }
    //            for (int i = 1; i <= 10; i++) {
    //                if (abs(my_road[upPoint - i].connected[j_mid[upPoint - i]].left - my_road[upPoint - i + 1].connected[j_mid[upPoint - i + 1]].left) <= 7
    //                    && upPoint - i > 2
    //                    && my_road[upPoint - i].connected[j_mid[upPoint - i]].right < right_side[upPoint - i] - 1
    //                    ) {
    //                    leftCircle[upPoint - i] = my_road[upPoint - i].connected[j_mid[upPoint - i]].right;
    //                    upC = upPoint - i;
    //                }
    //                else {

    //                    break;
    //                }
    //            }
    //            double dk = fabs(calculate_slope(upC, downC, leftCircle) - calculate_slope_struct(downPoint + 1, downPoint + 15, j_mid, LEFT));
    //            ////////////////////////printf("upC=%d,downC=%d,k=%f,dk=%f\n", upC, downC,calculate_slope(upC,downC,rightCircle),fabs(calculate_slope(upC, downC, rightCircle)- calculate_slope_struct(downPoint + 1, downPoint + 15, j_mid, RIGHT)));

    //            if (dk > 0.55) {
    //                if (75 < downPoint && downPoint < 110) {
    //                    state = stateIslandIn;
    //                }
    //            }
    //        }
    //    }
    //}

}

////////////////////////////////////////////
//功能：入T字口开始
//输入：
//输出：
//备注：
///////////////////////////////////////////
void cross_T_in_start() {
    ////我们认为下方点到100行之前就必须识别上，不然就晚了

    ////寻找正确的上方赛道
    //for (int i = 106; i > 10; i--) {
    //    if (right_line[i - 1] - right_line[i] > 4 && right_line[i - 2] - right_line[i] > 4
    //        && left_line[i - 1] - left_line[i] <= 2 && left_line[i - 2] - left_line[i] <= 2) {
    //        TWhere = RIGHT;
    //        break;
    //    }
    //    if (left_line[i - 1] - left_line[i] < -4 && left_line[i - 2] - left_line[i] < -4
    //        && right_line[i - 1] - right_line[i] <= 2 && right_line[i - 2] - right_line[i] <= 2) {
    //        TWhere = LEFT;
    //        break;
    //    }
    //}

    //if (TWhere == RIGHT) {
    //    //寻找下拐点

    //    uint8_t j_mid[CAMERA_H];
    //    for (int i = NEAR_LINE; i >= 2; i--) {
    //        j_mid[i] = j_continue[i];
    //        for (int j = 1; j <= my_road[i].white_num; j++) {
    //            if (abs(my_road[i].connected[j].left - my_road[i + 1].connected[j_mid[i + 1]].left) < abs(my_road[i].connected[j_mid[i]].left - my_road[i + 1].connected[j_mid[i + 1]].left)
    //                && my_road[i].connected[j].width > 10) {
    //                j_mid[i] = j;
    //                //  break;
    //            }

    //        }
    //    }
    //    //初步确定另一边是直线
    //    double kl1 = calculate_slope_struct(60, 75, j_mid, LEFT);
    //    double kl2 = calculate_slope_struct(85, 100, j_mid, LEFT);


    //    if (fabs(kl1 - kl2) < 0.2) {

    //        //寻找拐点
    //        int downPoint = 119;
    //        int upPoint = 119;
    //        //////////////////////printf("f=%f\n", calculate_slope_struct(60, 80, j_mid, LEFT));
    //        double p = 0.2;
    //        int way = 1;
    //        if (fabs(calculate_slope_struct(80, 95, j_mid, LEFT)) <= p) {
    //            for (int i = NEAR_LINE - 1; i >= 30; i--) {
    //                if (my_road[i - 1].connected[j_mid[i - 1]].right - my_road[i].connected[j_mid[i]].right >= 3
    //                    && abs(my_road[i + 1].connected[j_mid[i + 1]].right - my_road[i].connected[j_mid[i]].right) <= 2
    //                    && my_road[i].connected[j_mid[i]].width < 40
    //                    && my_road[i + 1].connected[j_mid[i + 1]].width < 40
    //                    ) {
    //                    downPoint = i;
    //                    break;
    //                }
    //                if (abs(my_road[i + 1].connected[j_mid[i + 1]].right - my_road[i].connected[j_mid[i]].right) >= 3) {
    //                    break;
    //                }
    //            }
    //            int start = 30;
    //            while (start <= downPoint - 15 && start <= 90 && my_road[start].connected[j_mid[start]].width > 40) {
    //                start++;
    //            }
    //            for (int i = start; i <= downPoint - 15; i++) {
    //                if (my_road[i + 1].connected[j_mid[i + 1]].right - my_road[i].connected[j_mid[i]].right >= 3
    //                    && abs(my_road[i - 1].connected[j_mid[i - 1]].right - my_road[i].connected[j_mid[i]].right) <= 2
    //                    && my_road[i].connected[j_mid[i]].width < 40
    //                    && my_road[i - 1].connected[j_mid[i - 1]].width < 40
    //                    ) {
    //                    upPoint = i;
    //                    break;
    //                }
    //                if (abs(my_road[i - 1].connected[j_mid[i - 1]].right - my_road[i].connected[j_mid[i]].right) >= 3) {
    //                    break;
    //                }
    //            }



    //        }
    //        else if (calculate_slope_struct(80, 95, j_mid, LEFT) > p) {
    //            int start = 30;

    //            if (my_road[start].connected[j_mid[start]].width >= 40
    //                ) {
    //                while (start <= 90 && my_road[start].connected[j_mid[start]].width >= 40) {
    //                    start++;
    //                }
    //            }
    //            for (int i = start; i <= 90; i++) {
    //                if (my_road[i + 1].connected[j_mid[i + 1]].right - my_road[i].connected[j_mid[i]].right > 4
    //                    && abs(my_road[i - 1].connected[j_mid[i - 1]].right - my_road[i].connected[j_mid[i]].right) <= 2

    //                    && my_road[i].connected[j_mid[i]].width < 40
    //                    && my_road[i - 1].connected[j_mid[i - 1]].width < 40
    //                    ) {
    //                    upPoint = i;
    //                    break;
    //                }
    //                if (abs(my_road[i - 1].connected[j_mid[i - 1]].right - my_road[i].connected[j_mid[i]].right) >= 3) {
    //                    break;
    //                }

    //            }


    //            for (int i = 110; i >= 40; i--) {
    //                if (my_road[i + 5].connected[j_mid[i + 5]].right - my_road[i].connected[j_mid[i]].right >= 1 && my_road[i + 10].connected[j_mid[i + 10]].right - my_road[i].connected[j_mid[i]].right >= 2
    //                    && my_road[i - 3].connected[j_mid[i - 3]].right - my_road[i].connected[j_mid[i]].right >= 1 && my_road[i - 7].connected[j_mid[i - 7]].right - my_road[i].connected[j_mid[i]].right >= 2
    //                    && calculate_slope_struct(i - 15, i - 1, j_mid, RIGHT) * calculate_slope_struct(i + 1, i + 15, j_mid, RIGHT) < 0) {
    //                    downPoint = i;
    //                }
    //            }
    //        }
    //        else if (calculate_slope_struct(80, 95, j_mid, LEFT) < -1 * p) {
    //            int start = 30;
    //            if (my_road[start].connected[j_mid[start]].width >= 40
    //                ) {
    //                while (start <= 90 && my_road[start].connected[j_mid[start]].width >= 40) {
    //                    start++;
    //                }
    //            }
    //            for (int i = start; i <= 90; i++) {
    //                if (my_road[i + 5].connected[j_mid[i + 5]].right - my_road[i].connected[j_mid[i]].right >= 1 && my_road[i + 7].connected[j_mid[i + 7]].right - my_road[i].connected[j_mid[i]].right >= 2
    //                    && my_road[i - 5].connected[j_mid[i - 5]].right - my_road[i].connected[j_mid[i]].right >= 1 && my_road[i - 7].connected[j_mid[i - 7]].right - my_road[i].connected[j_mid[i]].right >= 1
    //                    && my_road[i - 12].connected[j_mid[i - 12]].right - my_road[i].connected[j_mid[i]].right >= 2
    //                    && calculate_slope_struct(i - 15, i - 1, j_mid, RIGHT) * calculate_slope_struct(i + 1, i + 15, j_mid, RIGHT) < 0) {
    //                    upPoint = i;
    //                }

    //            }

    //            for (int i = 110; i >= 40; i--) {
    //                if (my_road[i - 1].connected[j_mid[i - 1]].right - my_road[i].connected[j_mid[i]].right > 4
    //                    && abs(my_road[i + 1].connected[j_mid[i + 1]].right - my_road[i].connected[j_mid[i]].right) <= 2
    //                    && my_road[i].connected[j_mid[i]].width < 40
    //                    && my_road[i + 1].connected[j_mid[i + 1]].width < 40
    //                    ) {
    //                    downPoint = i;
    //                    break;
    //                }
    //                if (abs(my_road[i + 1].connected[j_mid[i + 1]].right - my_road[i].connected[j_mid[i]].right) >= 3) {
    //                    break;
    //                }
    //            }
    //        }

    //        //////////////////////printf("up=%d,down=%d\n", upPoint, downPoint);
    //        //准确的直线判据


    //        double kLL1 = calculate_slope_struct(upPoint - 15, upPoint - 1, j_mid, LEFT);
    //        double kLL2 = calculate_slope_struct(upPoint - 5, downPoint + 5, j_mid, LEFT);
    //        double kLL3 = calculate_slope_struct(downPoint + 1, downPoint + 15, j_mid, LEFT);
    //        double kRR1 = calculate_slope_struct(upPoint - 15, upPoint - 1, j_mid, RIGHT);
    //        double kRR2 = calculate_slope_struct(downPoint + 1, downPoint + 20, j_mid, RIGHT);

    //        if (90 < downPoint && downPoint < 105
    //            && 40 < upPoint && upPoint < 90) {

    //            if (fabs(kLL1 - kRR1) < 0.2 && fabs(kLL3 - kRR2) < 0.2
    //                && fabs(kRR1 - kRR2) < 0.2 && fabs(kRR1 - kLL3) < 0.2) {

    //                state = stateCrossTIn;

    //            }

    //        }
    //    }





    //}
    //else if (TWhere == LEFT) {

    //    uint8_t j_mid[CAMERA_H];
    //    for (int i = NEAR_LINE; i >= 2; i--) {
    //        j_mid[i] = j_continue[i];
    //        for (int j = 1; j <= my_road[i].white_num; j++) {
    //            if (abs(my_road[i].connected[j].right - my_road[i + 1].connected[j_mid[i + 1]].right) < abs(my_road[i].connected[j_mid[i]].right - my_road[i + 1].connected[j_mid[i + 1]].right)
    //                && my_road[i].connected[j].width > 10) {
    //                j_mid[i] = j;
    //                //  break;
    //            }
    //        }
    //    }
    //    double kr1 = calculate_slope_struct(60, 75, j_mid, RIGHT);
    //    double kr2 = calculate_slope_struct(85, 100, j_mid, RIGHT);


    //    if (fabs(kr1 - kr2) < 0.2) {

    //        //寻找拐点
    //        int downPoint = 119;
    //        int upPoint = 119;
    //        if (calculate_slope_struct(80, 95, j_mid, RIGHT) >= 0) {
    //            for (int i = NEAR_LINE - 1; i >= 30; i--) {
    //                if (my_road[i - 1].connected[j_mid[i - 1]].left - my_road[i].connected[j_mid[i]].left < -4
    //                    && abs(my_road[i + 1].connected[j_mid[i + 1]].right - my_road[i].connected[j_mid[i]].right) <= 2
    //                    && my_road[i].connected[j_mid[i]].width < 40
    //                    && my_road[i + 1].connected[j_mid[i + 1]].width < 40
    //                    ) {
    //                    downPoint = i;
    //                    break;
    //                }
    //            }

    //            int num = 30;
    //            upPoint = num;
    //            while (num <= downPoint - 15 && my_road[num].connected[j_mid[num]].left >= left_side[num] + 1) {
    //                if (my_road[num].connected[j_mid[num]].left >= my_road[upPoint].connected[j_mid[upPoint]].left - 1
    //                    ) {
    //                    upPoint = num;
    //                }

    //                num++;
    //            }


    //        }
    //        else {
    //            int start = 30;

    //            if (my_road[start].connected[j_mid[start]].width >= 40
    //                ) {
    //                while (start <= 90 && my_road[start].connected[j_mid[start]].width >= 40) {
    //                    start++;
    //                }
    //            }
    //            for (int i = start; i <= 90; i++) {
    //                if (my_road[i + 1].connected[j_mid[i + 1]].left - my_road[i].connected[j_mid[i]].left < -4
    //                    && abs(my_road[i - 1].connected[j_mid[i - 1]].right - my_road[i].connected[j_mid[i]].right) <= 2
    //                    && my_road[i].connected[j_mid[i]].width < 40
    //                    && my_road[i - 1].connected[j_mid[i - 1]].width < 40
    //                    ) {
    //                    upPoint = i;
    //                    break;
    //                }
    //            }

    //            int num = 105;
    //            downPoint = num;
    //            while (num >= upPoint + 15 && my_road[num].connected[j_mid[num]].left >= left_side[num] + 1) {
    //                if (my_road[num].connected[j_mid[num]].left >= my_road[downPoint].connected[j_mid[downPoint]].left - 1
    //                    ) {
    //                    downPoint = num;
    //                }

    //                num--;
    //            }
    //        }

    //        // //////////////////////printf("up=%d,down=%d\n", upPoint, downPoint);
    //         //准确的直线判据

    //        double kRR1 = calculate_slope_struct(upPoint - 15, upPoint - 1, j_mid, RIGHT);
    //        double kRR2 = calculate_slope_struct(upPoint - 5, downPoint + 5, j_mid, RIGHT);
    //        double kRR3 = calculate_slope_struct(downPoint + 1, downPoint + 15, j_mid, RIGHT);
    //        double kLL1 = calculate_slope_struct(upPoint - 15, upPoint - 1, j_mid, LEFT);
    //        double kLL2 = calculate_slope_struct(downPoint + 1, downPoint + 15, j_mid, LEFT);

    //        if (fabs(kRR1 - kLL1) < 0.2 && fabs(kRR3 - kLL2) < 0.2
    //            && fabs(kLL1 - kLL2) < 0.2) {
    //            if (60 < downPoint && downPoint < 105
    //                && 30 < upPoint && upPoint < 90) {

    //                //方
    //                ////////////////////////printf("t=%d\n", TWhere);

    //                state = stateCrossTIn;

    //            }
    //        }
    //    }
    //}
}

////////////////////////////////////////////
//功能：入T字口补线
//输入：
//输出：
//备注：
///////////////////////////////////////////
void design_cross_T_in() {
    //if (TWhere == RIGHT) {

    //    int leftRoad[CAMERA_H];
    //    uint8_t j_mid[CAMERA_H];
    //    for (int i = NEAR_LINE; i >= 2; i--) {
    //        j_mid[i] = j_continue[i];
    //        for (int j = 1; j <= my_road[i].white_num; j++) {
    //            if (abs(my_road[i].connected[j].left - my_road[i + 1].connected[j_mid[i + 1]].left) < abs(my_road[i].connected[j_mid[i]].left - my_road[i + 1].connected[j_mid[i + 1]].left)
    //                && my_road[i].connected[j].width > 10) {
    //                j_mid[i] = j;
    //                //  break;
    //            }

    //        }
    //        leftRoad[i] = my_road[i].connected[j_mid[i]].left;
    //    }
    //    uint8_t xMin = right_line[100], yMin = 100;
    //    for (int i = 100; i > 2; i--) {
    //        if (xMin >= right_line[i]) {
    //            yMin = i;
    //            xMin = right_line[i];
    //        }
    //    }

    //    double k = calculate_slope(80, 100, leftRoad);

    //    for (int i = 110; i >= 2; i--) {
    //        right_line[i] = k * (i - yMin) + xMin;
    //        left_line[i] = leftRoad[i];
    //    }
    //}
    //else if (TWhere == LEFT) {
    //    uint8_t j_mid[CAMERA_H];
    //    int rightRoad[CAMERA_H];
    //    for (int i = NEAR_LINE; i >= 2; i--) {
    //        j_mid[i] = j_continue[i];
    //        for (int j = 1; j <= my_road[i].white_num; j++) {
    //            if (abs(my_road[i].connected[j].right - my_road[i + 1].connected[j_mid[i + 1]].right) < abs(my_road[i].connected[j_mid[i]].right - my_road[i + 1].connected[j_mid[i + 1]].right)
    //                && my_road[i].connected[j].width > 10) {
    //                j_mid[i] = j;
    //                //  break;
    //            }
    //        }
    //        rightRoad[i] = my_road[i].connected[j_mid[i]].right;
    //    }

    //    uint8_t xMin = left_line[100], yMin = 100;
    //    for (int i = 110; i > 2; i--) {
    //        if (xMin <= left_line[i]) {
    //            yMin = i;
    //            xMin = left_line[i];
    //        }
    //        if (my_road[i - 1].white_num == 0) {
    //            break;
    //        }
    //    }

    //    double k = calculate_slope(80, 100, rightRoad);

    //    for (int i = 100; i >= 2; i--) {
    //        left_line[i] = k * (i - yMin) + xMin;
    //        right_line[i] = rightRoad[i];
    //    }
    //}
}

////////////////////////////////////////////
//功能：环岛开始补线
//输入：
//输出：
//备注：
///////////////////////////////////////////
