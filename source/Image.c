#include "image.h"
//using namespace std;
uint16_t f[10 * CAMERA_H];//考察连通域联通性

uint8_t* fullBuffer = &mt9v034_image[0][0];

//每个白条子属性

int state = 0;


int carParkX;
int carParkTimes = 0;
int carParkDelay = 0;
int lastJumpPoint;
int lastK_up, lastK_jump;
int myIslandFlag = 0;
int count = 0;
int speedFlag = 0;
int lastStraight = 0;

all_range white_range[CAMERA_H];//所有白条子
road my_road[CAMERA_H];//赛道
uint8_t IMG[CAMERA_H][CAMERA_W];//二值化后图像数组
uint8_t left_line[CAMERA_H], right_line[CAMERA_H];//赛道的左右边界
uint8_t mid_line[CAMERA_H];
//uint8_t last_mid_line[CAMERA_H];
//road_noise swell;
int all_connect_num = 0;//所有白条子数

uint8_t top_road;//赛道最高处所在行数
uint8_t threshold = 80;//;//阈值
uint8_t thresholdUp;
uint8_t thresholdDown;
uint8_t midDownDistance = 0;
uint8_t midTimes = 0;

int FolkRoadWhere = RIGHT;
int islandWhere;
int TWhere;
int TIslandWhere;
int TFlag = 0;

int stopFlag = 0;
uint8_t stopCount = 0;
uint8_t j_continue[CAMERA_H];

int leftDownJumpPoint;//寻找左下角的拐点的行数
int leftUpJumpPoint;//寻找左上角的拐点的行数
int rightDownJumpPoint;//寻找右下角的拐点的行数
int rightUpJumpPoint;//寻找右下角的拐点的行数
int flagJumpPoint;//跳跃点的个数
int lastUpPoint = 0;

//三叉
int upSharpPoint = 119;
int leftSharpPoint = 119;
int rightSharpPoint = 119;
uint8_t folkTimes = 0;

//车库
int parkPosition = 0;
int leftPark = 0, rightPark = 0;
//uint8_t missLeft[CAMERA_H];
//uint8_t missRight[CAMERA_H];

int crossCircleCount = 0;


int straightFlag = 0, lastStraightFlag = 0;
uint8_t longStrFlag = 0, shortStrFlag = 0;
int slowFlag = 0;
int rampFlag1 = 0, rampFlag2 = 0,rampFlag3 = 0;
int parkJudgeCount = 0;
int rampWayCount = 0;
int rampJudgeCount=199;
int lastTwoState=0;
//int laststate = 0;
uint8_t memoryFlag = 0;
uint16_t memoryState[20] = {0};
float p_last = 0;
uint8_t averMidLine;
uint8_t sRoadFlag = 0;
uint8_t sRoadCount = 0;
uint8_t thresholdAdapt[8];
int forceOut = 0;
//uint8_t ForeSee = 35;
//coordinate foreSee[CAMERA_W];
uint8_t Loud=0;
uint8_t islandTimes = 0, IslandRadius = 0;
uint8_t minThre, maxThre;
uint8_t islandCircleCount = 0;
uint8_t tInCount = 0;
int threOriginal;
int flagIT = 0;
int wayIT = 1; //回环之后一定是环岛，我们用+-1来决定，1肯定是环岛，-1是回环 由发车方向决定
uint8_t tCrossStatus = 0;
uint8_t tCrossTimes = 0;
uint8_t rampTimes = 0;
uint8_t myParkLine = 0;
uint8_t parkSlowDownCount = 0;
uint8_t car_stop = 0;
int flagSee = 0;
uint8_t afterRampFlag = 0;
uint8_t folkCNT = 0;
uint8_t islandTimesCNT = 0;
uint8_t islandFinalTimes = 0;
uint8_t folkOutTimes = 0;
uint8_t speedUpPhase = 0; //省赛记忆加速
uint8_t flag_straight = 0;
//int tCrossStatus;
int last_leftupPoint = 0;
int last_rightupPoint = 0;
int lastState = 0;

uint8_t carparkflag = 0;
uint8_t count_num_IT = 1; // 数环岛回环个数
int num_island = 2;   // 赛道上环岛个数
int num_first_T = 2;  // 第一个回环前环岛数
const uint8_t left_side[CHANGED_H] = { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,5,5,8,8,10,10,12,14,14,16,18,18,19,21,21,23,24,25,25,27,28,29,31,32,33,34,35,37,38,39,40,42,42,44,45,46,47,49,50,51,52,53,55,55,57,58,59,60,62,63,64,65,66,67,69,70 };
const uint8_t right_side[CHANGED_H] = { 187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,187,184,184,182,182,179,179,177,177,175,173,173,171,169,169,168,166,166,164,163,162,162,160,159,158,156,155,154,153,152,150,149,148,147,145,145,143,142,141,140,138,137,136,135,134,132,132,130,129,128,127,125,124,123,122,121,120,118,117 };
const uint8_t i_fix[CHANGED_H] = { 0,0,0,0,1,1,1,1,1,1,2,2,2,2,2,2,3,3,3,3,3,4,4,4,4,4,5,5,5,5,5,6,6,6,6,7,7,7,7,8,8,8,9,9,9,9,10,10,10,11,11,11,12,12,13,13,13,14,14,15,15,15,16,16,17,17,18,18,19,19,20,21,21,22,23,23,24,25,25,26,27,28,28,29,30,31,32,33,34,35,36,38,39,40,41,43,44,46,47,49,51,53,55,57,59,61,64,66,69,72,75,79,83,87,91,96,101,106,112,119 };
const uint8_t j_fix[CHANGED_H][CHANGED_W] = {
    {40,41,41,42,42,43,43,44,45,45,46,46,47,48,48,49,49,50,50,51,52,52,53,53,54,54,55,55,56,57,57,58,58,59,60,60,61,61,62,62,63,63,64,65,65,66,66,67,67,68,69,69,70,70,71,72,72,73,73,74,74,75,76,76,77,77,78,78,79,79,80,81,81,82,82,83,83,84,85,85,86,86,87,87,88,89,89,90,90,91,91,92,93,93,94,94,95,95,96,97,97,98,98,99,99,100,101,101,102,102,103,103,104,105,105,106,106,107,107,108,109,109,110,110,111,111,112,113,113,114,114,115,115,116,117,117,118,118,119,119,120,121,121,122,122,123,123,124,125,125,126,126,127,127,128,129,129,130,130,131,131,132,133,133,134,134,135,135,136,137,137,138,138,139,139,140,141,141,142,142,143,143,144,145,145,146,146,147},
    {40,41,41,42,42,43,43,44,45,45,46,46,47,48,48,49,49,50,50,51,52,52,53,53,54,54,55,55,56,57,57,58,58,59,60,60,61,61,62,62,63,63,64,65,65,66,66,67,67,68,69,69,70,70,71,72,72,73,73,74,74,75,76,76,77,77,78,78,79,79,80,81,81,82,82,83,83,84,85,85,86,86,87,87,88,89,89,90,90,91,91,92,93,93,94,94,95,95,96,97,97,98,98,99,99,100,101,101,102,102,103,103,104,105,105,106,106,107,107,108,109,109,110,110,111,111,112,113,113,114,114,115,115,116,117,117,118,118,119,119,120,121,121,122,122,123,123,124,125,125,126,126,127,127,128,129,129,130,130,131,131,132,133,133,134,134,135,135,136,137,137,138,138,139,139,140,141,141,142,142,143,143,144,145,145,146,146,147},
    {40,41,41,42,42,43,43,44,45,45,46,46,47,48,48,49,49,50,50,51,52,52,53,53,54,54,55,55,56,57,57,58,58,59,60,60,61,61,62,62,63,63,64,65,65,66,66,67,67,68,69,69,70,70,71,72,72,73,73,74,74,75,76,76,77,77,78,78,79,79,80,81,81,82,82,83,83,84,85,85,86,86,87,87,88,89,89,90,90,91,91,92,93,93,94,94,95,95,96,97,97,98,98,99,99,100,101,101,102,102,103,103,104,105,105,106,106,107,107,108,109,109,110,110,111,111,112,113,113,114,114,115,115,116,117,117,118,118,119,119,120,121,121,122,122,123,123,124,125,125,126,126,127,127,128,129,129,130,130,131,131,132,133,133,134,134,135,135,136,137,137,138,138,139,139,140,141,141,142,142,143,143,144,145,145,146,146,147},
    {40,41,41,42,42,43,43,44,45,45,46,46,47,48,48,49,49,50,50,51,52,52,53,53,54,54,55,55,56,57,57,58,58,59,60,60,61,61,62,62,63,63,64,65,65,66,66,67,67,68,69,69,70,70,71,72,72,73,73,74,74,75,76,76,77,77,78,78,79,79,80,81,81,82,82,83,83,84,85,85,86,86,87,87,88,89,89,90,90,91,91,92,93,93,94,94,95,95,96,97,97,98,98,99,99,100,101,101,102,102,103,103,104,105,105,106,106,107,107,108,109,109,110,110,111,111,112,113,113,114,114,115,115,116,117,117,118,118,119,119,120,121,121,122,122,123,123,124,125,125,126,126,127,127,128,129,129,130,130,131,131,132,133,133,134,134,135,135,136,137,137,138,138,139,139,140,141,141,142,142,143,143,144,145,145,146,146,147},
    {37,38,39,39,40,40,41,42,42,43,43,44,45,45,46,46,47,48,48,49,49,50,51,51,52,52,53,54,54,55,55,56,57,57,58,58,59,60,60,61,61,62,63,63,64,64,65,66,66,67,67,68,69,69,70,70,71,72,72,73,73,74,75,75,76,76,77,78,78,79,79,80,81,81,82,82,83,84,84,85,85,86,87,87,88,88,89,90,90,91,91,92,93,93,94,94,95,96,96,97,97,98,99,99,100,100,101,102,102,103,103,104,105,105,106,106,107,108,108,109,109,110,111,111,112,112,113,114,114,115,115,116,117,117,118,118,119,120,120,121,121,122,123,123,124,124,125,126,126,127,127,128,129,129,130,130,131,132,132,133,133,134,135,135,136,136,137,138,138,139,139,140,141,141,142,142,143,144,144,145,145,146,147,147,148,148,149,150},
    {37,38,39,39,40,40,41,42,42,43,43,44,45,45,46,46,47,48,48,49,49,50,51,51,52,52,53,54,54,55,55,56,57,57,58,58,59,60,60,61,61,62,63,63,64,64,65,66,66,67,67,68,69,69,70,70,71,72,72,73,73,74,75,75,76,76,77,78,78,79,79,80,81,81,82,82,83,84,84,85,85,86,87,87,88,88,89,90,90,91,91,92,93,93,94,94,95,96,96,97,97,98,99,99,100,100,101,102,102,103,103,104,105,105,106,106,107,108,108,109,109,110,111,111,112,112,113,114,114,115,115,116,117,117,118,118,119,120,120,121,121,122,123,123,124,124,125,126,126,127,127,128,129,129,130,130,131,132,132,133,133,134,135,135,136,136,137,138,138,139,139,140,141,141,142,142,143,144,144,145,145,146,147,147,148,148,149,150},
    {37,38,39,39,40,40,41,42,42,43,43,44,45,45,46,46,47,48,48,49,49,50,51,51,52,52,53,54,54,55,55,56,57,57,58,58,59,60,60,61,61,62,63,63,64,64,65,66,66,67,67,68,69,69,70,70,71,72,72,73,73,74,75,75,76,76,77,78,78,79,79,80,81,81,82,82,83,84,84,85,85,86,87,87,88,88,89,90,90,91,91,92,93,93,94,94,95,96,96,97,97,98,99,99,100,100,101,102,102,103,103,104,105,105,106,106,107,108,108,109,109,110,111,111,112,112,113,114,114,115,115,116,117,117,118,118,119,120,120,121,121,122,123,123,124,124,125,126,126,127,127,128,129,129,130,130,131,132,132,133,133,134,135,135,136,136,137,138,138,139,139,140,141,141,142,142,143,144,144,145,145,146,147,147,148,148,149,150},
    {37,38,39,39,40,40,41,42,42,43,43,44,45,45,46,46,47,48,48,49,49,50,51,51,52,52,53,54,54,55,55,56,57,57,58,58,59,60,60,61,61,62,63,63,64,64,65,66,66,67,67,68,69,69,70,70,71,72,72,73,73,74,75,75,76,76,77,78,78,79,79,80,81,81,82,82,83,84,84,85,85,86,87,87,88,88,89,90,90,91,91,92,93,93,94,94,95,96,96,97,97,98,99,99,100,100,101,102,102,103,103,104,105,105,106,106,107,108,108,109,109,110,111,111,112,112,113,114,114,115,115,116,117,117,118,118,119,120,120,121,121,122,123,123,124,124,125,126,126,127,127,128,129,129,130,130,131,132,132,133,133,134,135,135,136,136,137,138,138,139,139,140,141,141,142,142,143,144,144,145,145,146,147,147,148,148,149,150},
    {37,38,39,39,40,40,41,42,42,43,43,44,45,45,46,46,47,48,48,49,49,50,51,51,52,52,53,54,54,55,55,56,57,57,58,58,59,60,60,61,61,62,63,63,64,64,65,66,66,67,67,68,69,69,70,70,71,72,72,73,73,74,75,75,76,76,77,78,78,79,79,80,81,81,82,82,83,84,84,85,85,86,87,87,88,88,89,90,90,91,91,92,93,93,94,94,95,96,96,97,97,98,99,99,100,100,101,102,102,103,103,104,105,105,106,106,107,108,108,109,109,110,111,111,112,112,113,114,114,115,115,116,117,117,118,118,119,120,120,121,121,122,123,123,124,124,125,126,126,127,127,128,129,129,130,130,131,132,132,133,133,134,135,135,136,136,137,138,138,139,139,140,141,141,142,142,143,144,144,145,145,146,147,147,148,148,149,150},
    {37,38,39,39,40,40,41,42,42,43,43,44,45,45,46,46,47,48,48,49,49,50,51,51,52,52,53,54,54,55,55,56,57,57,58,58,59,60,60,61,61,62,63,63,64,64,65,66,66,67,67,68,69,69,70,70,71,72,72,73,73,74,75,75,76,76,77,78,78,79,79,80,81,81,82,82,83,84,84,85,85,86,87,87,88,88,89,90,90,91,91,92,93,93,94,94,95,96,96,97,97,98,99,99,100,100,101,102,102,103,103,104,105,105,106,106,107,108,108,109,109,110,111,111,112,112,113,114,114,115,115,116,117,117,118,118,119,120,120,121,121,122,123,123,124,124,125,126,126,127,127,128,129,129,130,130,131,132,132,133,133,134,135,135,136,136,137,138,138,139,139,140,141,141,142,142,143,144,144,145,145,146,147,147,148,148,149,150},
    {35,35,36,37,37,38,38,39,40,40,41,42,42,43,43,44,45,45,46,47,47,48,48,49,50,50,51,52,52,53,54,54,55,55,56,57,57,58,59,59,60,60,61,62,62,63,64,64,65,65,66,67,67,68,69,69,70,71,71,72,72,73,74,74,75,76,76,77,77,78,79,79,80,81,81,82,82,83,84,84,85,86,86,87,88,88,89,89,90,91,91,92,93,93,94,94,95,96,96,97,98,98,99,99,100,101,101,102,103,103,104,105,105,106,106,107,108,108,109,110,110,111,111,112,113,113,114,115,115,116,116,117,118,118,119,120,120,121,122,122,123,123,124,125,125,126,127,127,128,128,129,130,130,131,132,132,133,133,134,135,135,136,137,137,138,139,139,140,140,141,142,142,143,144,144,145,145,146,147,147,148,149,149,150,150,151,152,152},
    {35,35,36,37,37,38,38,39,40,40,41,42,42,43,43,44,45,45,46,47,47,48,48,49,50,50,51,52,52,53,54,54,55,55,56,57,57,58,59,59,60,60,61,62,62,63,64,64,65,65,66,67,67,68,69,69,70,71,71,72,72,73,74,74,75,76,76,77,77,78,79,79,80,81,81,82,82,83,84,84,85,86,86,87,88,88,89,89,90,91,91,92,93,93,94,94,95,96,96,97,98,98,99,99,100,101,101,102,103,103,104,105,105,106,106,107,108,108,109,110,110,111,111,112,113,113,114,115,115,116,116,117,118,118,119,120,120,121,122,122,123,123,124,125,125,126,127,127,128,128,129,130,130,131,132,132,133,133,134,135,135,136,137,137,138,139,139,140,140,141,142,142,143,144,144,145,145,146,147,147,148,149,149,150,150,151,152,152},
    {35,35,36,37,37,38,38,39,40,40,41,42,42,43,43,44,45,45,46,47,47,48,48,49,50,50,51,52,52,53,54,54,55,55,56,57,57,58,59,59,60,60,61,62,62,63,64,64,65,65,66,67,67,68,69,69,70,71,71,72,72,73,74,74,75,76,76,77,77,78,79,79,80,81,81,82,82,83,84,84,85,86,86,87,88,88,89,89,90,91,91,92,93,93,94,94,95,96,96,97,98,98,99,99,100,101,101,102,103,103,104,105,105,106,106,107,108,108,109,110,110,111,111,112,113,113,114,115,115,116,116,117,118,118,119,120,120,121,122,122,123,123,124,125,125,126,127,127,128,128,129,130,130,131,132,132,133,133,134,135,135,136,137,137,138,139,139,140,140,141,142,142,143,144,144,145,145,146,147,147,148,149,149,150,150,151,152,152},
    {35,35,36,37,37,38,38,39,40,40,41,42,42,43,43,44,45,45,46,47,47,48,48,49,50,50,51,52,52,53,54,54,55,55,56,57,57,58,59,59,60,60,61,62,62,63,64,64,65,65,66,67,67,68,69,69,70,71,71,72,72,73,74,74,75,76,76,77,77,78,79,79,80,81,81,82,82,83,84,84,85,86,86,87,88,88,89,89,90,91,91,92,93,93,94,94,95,96,96,97,98,98,99,99,100,101,101,102,103,103,104,105,105,106,106,107,108,108,109,110,110,111,111,112,113,113,114,115,115,116,116,117,118,118,119,120,120,121,122,122,123,123,124,125,125,126,127,127,128,128,129,130,130,131,132,132,133,133,134,135,135,136,137,137,138,139,139,140,140,141,142,142,143,144,144,145,145,146,147,147,148,149,149,150,150,151,152,152},
    {35,35,36,37,37,38,38,39,40,40,41,42,42,43,43,44,45,45,46,47,47,48,48,49,50,50,51,52,52,53,54,54,55,55,56,57,57,58,59,59,60,60,61,62,62,63,64,64,65,65,66,67,67,68,69,69,70,71,71,72,72,73,74,74,75,76,76,77,77,78,79,79,80,81,81,82,82,83,84,84,85,86,86,87,88,88,89,89,90,91,91,92,93,93,94,94,95,96,96,97,98,98,99,99,100,101,101,102,103,103,104,105,105,106,106,107,108,108,109,110,110,111,111,112,113,113,114,115,115,116,116,117,118,118,119,120,120,121,122,122,123,123,124,125,125,126,127,127,128,128,129,130,130,131,132,132,133,133,134,135,135,136,137,137,138,139,139,140,140,141,142,142,143,144,144,145,145,146,147,147,148,149,149,150,150,151,152,152},
    {35,35,36,37,37,38,38,39,40,40,41,42,42,43,43,44,45,45,46,47,47,48,48,49,50,50,51,52,52,53,54,54,55,55,56,57,57,58,59,59,60,60,61,62,62,63,64,64,65,65,66,67,67,68,69,69,70,71,71,72,72,73,74,74,75,76,76,77,77,78,79,79,80,81,81,82,82,83,84,84,85,86,86,87,88,88,89,89,90,91,91,92,93,93,94,94,95,96,96,97,98,98,99,99,100,101,101,102,103,103,104,105,105,106,106,107,108,108,109,110,110,111,111,112,113,113,114,115,115,116,116,117,118,118,119,120,120,121,122,122,123,123,124,125,125,126,127,127,128,128,129,130,130,131,132,132,133,133,134,135,135,136,137,137,138,139,139,140,140,141,142,142,143,144,144,145,145,146,147,147,148,149,149,150,150,151,152,152},
    {32,33,33,34,35,35,36,37,37,38,39,39,40,40,41,42,42,43,44,44,45,46,46,47,48,48,49,50,50,51,52,52,53,54,54,55,56,56,57,58,58,59,60,60,61,62,62,63,64,64,65,66,66,67,67,68,69,69,70,71,71,72,73,73,74,75,75,76,77,77,78,79,79,80,81,81,82,83,83,84,85,85,86,87,87,88,89,89,90,91,91,92,93,93,94,94,95,96,96,97,98,98,99,100,100,101,102,102,103,104,104,105,106,106,107,108,108,109,110,110,111,112,112,113,114,114,115,116,116,117,118,118,119,120,120,121,121,122,123,123,124,125,125,126,127,127,128,129,129,130,131,131,132,133,133,134,135,135,136,137,137,138,139,139,140,141,141,142,143,143,144,145,145,146,147,147,148,148,149,150,150,151,152,152,153,154,154,155},
    {32,33,33,34,35,35,36,37,37,38,39,39,40,40,41,42,42,43,44,44,45,46,46,47,48,48,49,50,50,51,52,52,53,54,54,55,56,56,57,58,58,59,60,60,61,62,62,63,64,64,65,66,66,67,67,68,69,69,70,71,71,72,73,73,74,75,75,76,77,77,78,79,79,80,81,81,82,83,83,84,85,85,86,87,87,88,89,89,90,91,91,92,93,93,94,94,95,96,96,97,98,98,99,100,100,101,102,102,103,104,104,105,106,106,107,108,108,109,110,110,111,112,112,113,114,114,115,116,116,117,118,118,119,120,120,121,121,122,123,123,124,125,125,126,127,127,128,129,129,130,131,131,132,133,133,134,135,135,136,137,137,138,139,139,140,141,141,142,143,143,144,145,145,146,147,147,148,148,149,150,150,151,152,152,153,154,154,155},
    {32,33,33,34,35,35,36,37,37,38,39,39,40,40,41,42,42,43,44,44,45,46,46,47,48,48,49,50,50,51,52,52,53,54,54,55,56,56,57,58,58,59,60,60,61,62,62,63,64,64,65,66,66,67,67,68,69,69,70,71,71,72,73,73,74,75,75,76,77,77,78,79,79,80,81,81,82,83,83,84,85,85,86,87,87,88,89,89,90,91,91,92,93,93,94,94,95,96,96,97,98,98,99,100,100,101,102,102,103,104,104,105,106,106,107,108,108,109,110,110,111,112,112,113,114,114,115,116,116,117,118,118,119,120,120,121,121,122,123,123,124,125,125,126,127,127,128,129,129,130,131,131,132,133,133,134,135,135,136,137,137,138,139,139,140,141,141,142,143,143,144,145,145,146,147,147,148,148,149,150,150,151,152,152,153,154,154,155},
    {32,33,33,34,35,35,36,37,37,38,39,39,40,40,41,42,42,43,44,44,45,46,46,47,48,48,49,50,50,51,52,52,53,54,54,55,56,56,57,58,58,59,60,60,61,62,62,63,64,64,65,66,66,67,67,68,69,69,70,71,71,72,73,73,74,75,75,76,77,77,78,79,79,80,81,81,82,83,83,84,85,85,86,87,87,88,89,89,90,91,91,92,93,93,94,94,95,96,96,97,98,98,99,100,100,101,102,102,103,104,104,105,106,106,107,108,108,109,110,110,111,112,112,113,114,114,115,116,116,117,118,118,119,120,120,121,121,122,123,123,124,125,125,126,127,127,128,129,129,130,131,131,132,133,133,134,135,135,136,137,137,138,139,139,140,141,141,142,143,143,144,145,145,146,147,147,148,148,149,150,150,151,152,152,153,154,154,155},
    {32,33,33,34,35,35,36,37,37,38,39,39,40,40,41,42,42,43,44,44,45,46,46,47,48,48,49,50,50,51,52,52,53,54,54,55,56,56,57,58,58,59,60,60,61,62,62,63,64,64,65,66,66,67,67,68,69,69,70,71,71,72,73,73,74,75,75,76,77,77,78,79,79,80,81,81,82,83,83,84,85,85,86,87,87,88,89,89,90,91,91,92,93,93,94,94,95,96,96,97,98,98,99,100,100,101,102,102,103,104,104,105,106,106,107,108,108,109,110,110,111,112,112,113,114,114,115,116,116,117,118,118,119,120,120,121,121,122,123,123,124,125,125,126,127,127,128,129,129,130,131,131,132,133,133,134,135,135,136,137,137,138,139,139,140,141,141,142,143,143,144,145,145,146,147,147,148,148,149,150,150,151,152,152,153,154,154,155},
    {29,30,31,31,32,33,33,34,35,35,36,37,37,38,39,40,40,41,42,42,43,44,44,45,46,46,47,48,48,49,50,51,51,52,53,53,54,55,55,56,57,57,58,59,59,60,61,62,62,63,64,64,65,66,66,67,68,68,69,70,70,71,72,73,73,74,75,75,76,77,77,78,79,79,80,81,81,82,83,84,84,85,86,86,87,88,88,89,90,90,91,92,92,93,94,95,95,96,97,97,98,99,99,100,101,101,102,103,103,104,105,106,106,107,108,108,109,110,110,111,112,112,113,114,114,115,116,117,117,118,119,119,120,121,121,122,123,123,124,125,125,126,127,128,128,129,130,130,131,132,132,133,134,134,135,136,136,137,138,139,139,140,141,141,142,143,143,144,145,145,146,147,147,148,149,150,150,151,152,152,153,154,154,155,156,156,157,158},
    {29,30,31,31,32,33,33,34,35,35,36,37,37,38,39,40,40,41,42,42,43,44,44,45,46,46,47,48,48,49,50,51,51,52,53,53,54,55,55,56,57,57,58,59,59,60,61,62,62,63,64,64,65,66,66,67,68,68,69,70,70,71,72,73,73,74,75,75,76,77,77,78,79,79,80,81,81,82,83,84,84,85,86,86,87,88,88,89,90,90,91,92,92,93,94,95,95,96,97,97,98,99,99,100,101,101,102,103,103,104,105,106,106,107,108,108,109,110,110,111,112,112,113,114,114,115,116,117,117,118,119,119,120,121,121,122,123,123,124,125,125,126,127,128,128,129,130,130,131,132,132,133,134,134,135,136,136,137,138,139,139,140,141,141,142,143,143,144,145,145,146,147,147,148,149,150,150,151,152,152,153,154,154,155,156,156,157,158},
    {29,30,31,31,32,33,33,34,35,35,36,37,37,38,39,40,40,41,42,42,43,44,44,45,46,46,47,48,48,49,50,51,51,52,53,53,54,55,55,56,57,57,58,59,59,60,61,62,62,63,64,64,65,66,66,67,68,68,69,70,70,71,72,73,73,74,75,75,76,77,77,78,79,79,80,81,81,82,83,84,84,85,86,86,87,88,88,89,90,90,91,92,92,93,94,95,95,96,97,97,98,99,99,100,101,101,102,103,103,104,105,106,106,107,108,108,109,110,110,111,112,112,113,114,114,115,116,117,117,118,119,119,120,121,121,122,123,123,124,125,125,126,127,128,128,129,130,130,131,132,132,133,134,134,135,136,136,137,138,139,139,140,141,141,142,143,143,144,145,145,146,147,147,148,149,150,150,151,152,152,153,154,154,155,156,156,157,158},
    {29,30,31,31,32,33,33,34,35,35,36,37,37,38,39,40,40,41,42,42,43,44,44,45,46,46,47,48,48,49,50,51,51,52,53,53,54,55,55,56,57,57,58,59,59,60,61,62,62,63,64,64,65,66,66,67,68,68,69,70,70,71,72,73,73,74,75,75,76,77,77,78,79,79,80,81,81,82,83,84,84,85,86,86,87,88,88,89,90,90,91,92,92,93,94,95,95,96,97,97,98,99,99,100,101,101,102,103,103,104,105,106,106,107,108,108,109,110,110,111,112,112,113,114,114,115,116,117,117,118,119,119,120,121,121,122,123,123,124,125,125,126,127,128,128,129,130,130,131,132,132,133,134,134,135,136,136,137,138,139,139,140,141,141,142,143,143,144,145,145,146,147,147,148,149,150,150,151,152,152,153,154,154,155,156,156,157,158},
    {29,30,31,31,32,33,33,34,35,35,36,37,37,38,39,40,40,41,42,42,43,44,44,45,46,46,47,48,48,49,50,51,51,52,53,53,54,55,55,56,57,57,58,59,59,60,61,62,62,63,64,64,65,66,66,67,68,68,69,70,70,71,72,73,73,74,75,75,76,77,77,78,79,79,80,81,81,82,83,84,84,85,86,86,87,88,88,89,90,90,91,92,92,93,94,95,95,96,97,97,98,99,99,100,101,101,102,103,103,104,105,106,106,107,108,108,109,110,110,111,112,112,113,114,114,115,116,117,117,118,119,119,120,121,121,122,123,123,124,125,125,126,127,128,128,129,130,130,131,132,132,133,134,134,135,136,136,137,138,139,139,140,141,141,142,143,143,144,145,145,146,147,147,148,149,150,150,151,152,152,153,154,154,155,156,156,157,158},
    {26,27,28,29,29,30,31,32,32,33,34,34,35,36,37,37,38,39,39,40,41,42,42,43,44,44,45,46,47,47,48,49,49,50,51,52,52,53,54,54,55,56,57,57,58,59,59,60,61,62,62,63,64,64,65,66,67,67,68,69,69,70,71,72,72,73,74,75,75,76,77,77,78,79,80,80,81,82,82,83,84,85,85,86,87,87,88,89,90,90,91,92,92,93,94,95,95,96,97,97,98,99,100,100,101,102,102,103,104,105,105,106,107,107,108,109,110,110,111,112,112,113,114,115,115,116,117,118,118,119,120,120,121,122,123,123,124,125,125,126,127,128,128,129,130,130,131,132,133,133,134,135,135,136,137,138,138,139,140,140,141,142,143,143,144,145,145,146,147,148,148,149,150,150,151,152,153,153,154,155,155,156,157,158,158,159,160,161},
    {26,27,28,29,29,30,31,32,32,33,34,34,35,36,37,37,38,39,39,40,41,42,42,43,44,44,45,46,47,47,48,49,49,50,51,52,52,53,54,54,55,56,57,57,58,59,59,60,61,62,62,63,64,64,65,66,67,67,68,69,69,70,71,72,72,73,74,75,75,76,77,77,78,79,80,80,81,82,82,83,84,85,85,86,87,87,88,89,90,90,91,92,92,93,94,95,95,96,97,97,98,99,100,100,101,102,102,103,104,105,105,106,107,107,108,109,110,110,111,112,112,113,114,115,115,116,117,118,118,119,120,120,121,122,123,123,124,125,125,126,127,128,128,129,130,130,131,132,133,133,134,135,135,136,137,138,138,139,140,140,141,142,143,143,144,145,145,146,147,148,148,149,150,150,151,152,153,153,154,155,155,156,157,158,158,159,160,161},
    {26,27,28,29,29,30,31,32,32,33,34,34,35,36,37,37,38,39,39,40,41,42,42,43,44,44,45,46,47,47,48,49,49,50,51,52,52,53,54,54,55,56,57,57,58,59,59,60,61,62,62,63,64,64,65,66,67,67,68,69,69,70,71,72,72,73,74,75,75,76,77,77,78,79,80,80,81,82,82,83,84,85,85,86,87,87,88,89,90,90,91,92,92,93,94,95,95,96,97,97,98,99,100,100,101,102,102,103,104,105,105,106,107,107,108,109,110,110,111,112,112,113,114,115,115,116,117,118,118,119,120,120,121,122,123,123,124,125,125,126,127,128,128,129,130,130,131,132,133,133,134,135,135,136,137,138,138,139,140,140,141,142,143,143,144,145,145,146,147,148,148,149,150,150,151,152,153,153,154,155,155,156,157,158,158,159,160,161},
    {26,27,28,29,29,30,31,32,32,33,34,34,35,36,37,37,38,39,39,40,41,42,42,43,44,44,45,46,47,47,48,49,49,50,51,52,52,53,54,54,55,56,57,57,58,59,59,60,61,62,62,63,64,64,65,66,67,67,68,69,69,70,71,72,72,73,74,75,75,76,77,77,78,79,80,80,81,82,82,83,84,85,85,86,87,87,88,89,90,90,91,92,92,93,94,95,95,96,97,97,98,99,100,100,101,102,102,103,104,105,105,106,107,107,108,109,110,110,111,112,112,113,114,115,115,116,117,118,118,119,120,120,121,122,123,123,124,125,125,126,127,128,128,129,130,130,131,132,133,133,134,135,135,136,137,138,138,139,140,140,141,142,143,143,144,145,145,146,147,148,148,149,150,150,151,152,153,153,154,155,155,156,157,158,158,159,160,161},
    {26,27,28,29,29,30,31,32,32,33,34,34,35,36,37,37,38,39,39,40,41,42,42,43,44,44,45,46,47,47,48,49,49,50,51,52,52,53,54,54,55,56,57,57,58,59,59,60,61,62,62,63,64,64,65,66,67,67,68,69,69,70,71,72,72,73,74,75,75,76,77,77,78,79,80,80,81,82,82,83,84,85,85,86,87,87,88,89,90,90,91,92,92,93,94,95,95,96,97,97,98,99,100,100,101,102,102,103,104,105,105,106,107,107,108,109,110,110,111,112,112,113,114,115,115,116,117,118,118,119,120,120,121,122,123,123,124,125,125,126,127,128,128,129,130,130,131,132,133,133,134,135,135,136,137,138,138,139,140,140,141,142,143,143,144,145,145,146,147,148,148,149,150,150,151,152,153,153,154,155,155,156,157,158,158,159,160,161},
    {24,25,25,26,27,28,28,29,30,30,31,32,33,33,34,35,36,36,37,38,39,39,40,41,42,42,43,44,45,45,46,47,48,48,49,50,51,51,52,53,54,54,55,56,57,57,58,59,60,60,61,62,63,63,64,65,66,66,67,68,69,69,70,71,72,72,73,74,74,75,76,77,77,78,79,80,80,81,82,83,83,84,85,86,86,87,88,89,89,90,91,92,92,93,94,95,95,96,97,98,98,99,100,101,101,102,103,104,104,105,106,107,107,108,109,110,110,111,112,113,113,114,115,115,116,117,118,118,119,120,121,121,122,123,124,124,125,126,127,127,128,129,130,130,131,132,133,133,134,135,136,136,137,138,139,139,140,141,142,142,143,144,145,145,146,147,148,148,149,150,151,151,152,153,154,154,155,156,157,157,158,159,159,160,161,162,162,163},
    {24,25,25,26,27,28,28,29,30,30,31,32,33,33,34,35,36,36,37,38,39,39,40,41,42,42,43,44,45,45,46,47,48,48,49,50,51,51,52,53,54,54,55,56,57,57,58,59,60,60,61,62,63,63,64,65,66,66,67,68,69,69,70,71,72,72,73,74,74,75,76,77,77,78,79,80,80,81,82,83,83,84,85,86,86,87,88,89,89,90,91,92,92,93,94,95,95,96,97,98,98,99,100,101,101,102,103,104,104,105,106,107,107,108,109,110,110,111,112,113,113,114,115,115,116,117,118,118,119,120,121,121,122,123,124,124,125,126,127,127,128,129,130,130,131,132,133,133,134,135,136,136,137,138,139,139,140,141,142,142,143,144,145,145,146,147,148,148,149,150,151,151,152,153,154,154,155,156,157,157,158,159,159,160,161,162,162,163},
    {24,25,25,26,27,28,28,29,30,30,31,32,33,33,34,35,36,36,37,38,39,39,40,41,42,42,43,44,45,45,46,47,48,48,49,50,51,51,52,53,54,54,55,56,57,57,58,59,60,60,61,62,63,63,64,65,66,66,67,68,69,69,70,71,72,72,73,74,74,75,76,77,77,78,79,80,80,81,82,83,83,84,85,86,86,87,88,89,89,90,91,92,92,93,94,95,95,96,97,98,98,99,100,101,101,102,103,104,104,105,106,107,107,108,109,110,110,111,112,113,113,114,115,115,116,117,118,118,119,120,121,121,122,123,124,124,125,126,127,127,128,129,130,130,131,132,133,133,134,135,136,136,137,138,139,139,140,141,142,142,143,144,145,145,146,147,148,148,149,150,151,151,152,153,154,154,155,156,157,157,158,159,159,160,161,162,162,163},
    {24,25,25,26,27,28,28,29,30,30,31,32,33,33,34,35,36,36,37,38,39,39,40,41,42,42,43,44,45,45,46,47,48,48,49,50,51,51,52,53,54,54,55,56,57,57,58,59,60,60,61,62,63,63,64,65,66,66,67,68,69,69,70,71,72,72,73,74,74,75,76,77,77,78,79,80,80,81,82,83,83,84,85,86,86,87,88,89,89,90,91,92,92,93,94,95,95,96,97,98,98,99,100,101,101,102,103,104,104,105,106,107,107,108,109,110,110,111,112,113,113,114,115,115,116,117,118,118,119,120,121,121,122,123,124,124,125,126,127,127,128,129,130,130,131,132,133,133,134,135,136,136,137,138,139,139,140,141,142,142,143,144,145,145,146,147,148,148,149,150,151,151,152,153,154,154,155,156,157,157,158,159,159,160,161,162,162,163},
    {21,22,23,23,24,25,26,26,27,28,29,30,30,31,32,33,33,34,35,36,37,37,38,39,40,40,41,42,43,44,44,45,46,47,47,48,49,50,51,51,52,53,54,54,55,56,57,57,58,59,60,61,61,62,63,64,64,65,66,67,68,68,69,70,71,71,72,73,74,75,75,76,77,78,78,79,80,81,81,82,83,84,85,85,86,87,88,88,89,90,91,92,92,93,94,95,95,96,97,98,99,99,100,101,102,102,103,104,105,106,106,107,108,109,109,110,111,112,112,113,114,115,116,116,117,118,119,119,120,121,122,123,123,124,125,126,126,127,128,129,130,130,131,132,133,133,134,135,136,136,137,138,139,140,140,141,142,143,143,144,145,146,147,147,148,149,150,150,151,152,153,154,154,155,156,157,157,158,159,160,161,161,162,163,164,164,165,166},
    {21,22,23,23,24,25,26,26,27,28,29,30,30,31,32,33,33,34,35,36,37,37,38,39,40,40,41,42,43,44,44,45,46,47,47,48,49,50,51,51,52,53,54,54,55,56,57,57,58,59,60,61,61,62,63,64,64,65,66,67,68,68,69,70,71,71,72,73,74,75,75,76,77,78,78,79,80,81,81,82,83,84,85,85,86,87,88,88,89,90,91,92,92,93,94,95,95,96,97,98,99,99,100,101,102,102,103,104,105,106,106,107,108,109,109,110,111,112,112,113,114,115,116,116,117,118,119,119,120,121,122,123,123,124,125,126,126,127,128,129,130,130,131,132,133,133,134,135,136,136,137,138,139,140,140,141,142,143,143,144,145,146,147,147,148,149,150,150,151,152,153,154,154,155,156,157,157,158,159,160,161,161,162,163,164,164,165,166},
    {21,22,23,23,24,25,26,26,27,28,29,30,30,31,32,33,33,34,35,36,37,37,38,39,40,40,41,42,43,44,44,45,46,47,47,48,49,50,51,51,52,53,54,54,55,56,57,57,58,59,60,61,61,62,63,64,64,65,66,67,68,68,69,70,71,71,72,73,74,75,75,76,77,78,78,79,80,81,81,82,83,84,85,85,86,87,88,88,89,90,91,92,92,93,94,95,95,96,97,98,99,99,100,101,102,102,103,104,105,106,106,107,108,109,109,110,111,112,112,113,114,115,116,116,117,118,119,119,120,121,122,123,123,124,125,126,126,127,128,129,130,130,131,132,133,133,134,135,136,136,137,138,139,140,140,141,142,143,143,144,145,146,147,147,148,149,150,150,151,152,153,154,154,155,156,157,157,158,159,160,161,161,162,163,164,164,165,166},
    {21,22,23,23,24,25,26,26,27,28,29,30,30,31,32,33,33,34,35,36,37,37,38,39,40,40,41,42,43,44,44,45,46,47,47,48,49,50,51,51,52,53,54,54,55,56,57,57,58,59,60,61,61,62,63,64,64,65,66,67,68,68,69,70,71,71,72,73,74,75,75,76,77,78,78,79,80,81,81,82,83,84,85,85,86,87,88,88,89,90,91,92,92,93,94,95,95,96,97,98,99,99,100,101,102,102,103,104,105,106,106,107,108,109,109,110,111,112,112,113,114,115,116,116,117,118,119,119,120,121,122,123,123,124,125,126,126,127,128,129,130,130,131,132,133,133,134,135,136,136,137,138,139,140,140,141,142,143,143,144,145,146,147,147,148,149,150,150,151,152,153,154,154,155,156,157,157,158,159,160,161,161,162,163,164,164,165,166},
    {18,19,20,21,22,22,23,24,25,26,26,27,28,29,30,30,31,32,33,34,34,35,36,37,38,38,39,40,41,42,42,43,44,45,46,46,47,48,49,50,50,51,52,53,54,55,55,56,57,58,59,59,60,61,62,63,63,64,65,66,67,67,68,69,70,71,71,72,73,74,75,75,76,77,78,79,79,80,81,82,83,83,84,85,86,87,87,88,89,90,91,91,92,93,94,95,96,96,97,98,99,100,100,101,102,103,104,104,105,106,107,108,108,109,110,111,112,112,113,114,115,116,116,117,118,119,120,120,121,122,123,124,124,125,126,127,128,128,129,130,131,132,132,133,134,135,136,137,137,138,139,140,141,141,142,143,144,145,145,146,147,148,149,149,150,151,152,153,153,154,155,156,157,157,158,159,160,161,161,162,163,164,165,165,166,167,168,169},
    {18,19,20,21,22,22,23,24,25,26,26,27,28,29,30,30,31,32,33,34,34,35,36,37,38,38,39,40,41,42,42,43,44,45,46,46,47,48,49,50,50,51,52,53,54,55,55,56,57,58,59,59,60,61,62,63,63,64,65,66,67,67,68,69,70,71,71,72,73,74,75,75,76,77,78,79,79,80,81,82,83,83,84,85,86,87,87,88,89,90,91,91,92,93,94,95,96,96,97,98,99,100,100,101,102,103,104,104,105,106,107,108,108,109,110,111,112,112,113,114,115,116,116,117,118,119,120,120,121,122,123,124,124,125,126,127,128,128,129,130,131,132,132,133,134,135,136,137,137,138,139,140,141,141,142,143,144,145,145,146,147,148,149,149,150,151,152,153,153,154,155,156,157,157,158,159,160,161,161,162,163,164,165,165,166,167,168,169},
    {18,19,20,21,22,22,23,24,25,26,26,27,28,29,30,30,31,32,33,34,34,35,36,37,38,38,39,40,41,42,42,43,44,45,46,46,47,48,49,50,50,51,52,53,54,55,55,56,57,58,59,59,60,61,62,63,63,64,65,66,67,67,68,69,70,71,71,72,73,74,75,75,76,77,78,79,79,80,81,82,83,83,84,85,86,87,87,88,89,90,91,91,92,93,94,95,96,96,97,98,99,100,100,101,102,103,104,104,105,106,107,108,108,109,110,111,112,112,113,114,115,116,116,117,118,119,120,120,121,122,123,124,124,125,126,127,128,128,129,130,131,132,132,133,134,135,136,137,137,138,139,140,141,141,142,143,144,145,145,146,147,148,149,149,150,151,152,153,153,154,155,156,157,157,158,159,160,161,161,162,163,164,165,165,166,167,168,169},
    {16,16,17,18,19,20,21,21,22,23,24,25,26,26,27,28,29,30,31,31,32,33,34,35,36,36,37,38,39,40,41,41,42,43,44,45,46,46,47,48,49,50,51,51,52,53,54,55,56,56,57,58,59,60,61,61,62,63,64,65,66,66,67,68,69,70,71,71,72,73,74,75,76,76,77,78,79,80,81,81,82,83,84,85,86,86,87,88,89,90,91,91,92,93,94,95,96,96,97,98,99,100,101,101,102,103,104,105,106,106,107,108,109,110,111,111,112,113,114,115,116,116,117,118,119,120,121,121,122,123,124,125,126,126,127,128,129,130,131,131,132,133,134,135,136,136,137,138,139,140,141,141,142,143,144,145,146,146,147,148,149,150,151,151,152,153,154,155,156,156,157,158,159,160,161,161,162,163,164,165,166,166,167,168,169,170,171,171},
    {16,16,17,18,19,20,21,21,22,23,24,25,26,26,27,28,29,30,31,31,32,33,34,35,36,36,37,38,39,40,41,41,42,43,44,45,46,46,47,48,49,50,51,51,52,53,54,55,56,56,57,58,59,60,61,61,62,63,64,65,66,66,67,68,69,70,71,71,72,73,74,75,76,76,77,78,79,80,81,81,82,83,84,85,86,86,87,88,89,90,91,91,92,93,94,95,96,96,97,98,99,100,101,101,102,103,104,105,106,106,107,108,109,110,111,111,112,113,114,115,116,116,117,118,119,120,121,121,122,123,124,125,126,126,127,128,129,130,131,131,132,133,134,135,136,136,137,138,139,140,141,141,142,143,144,145,146,146,147,148,149,150,151,151,152,153,154,155,156,156,157,158,159,160,161,161,162,163,164,165,166,166,167,168,169,170,171,171},
    {16,16,17,18,19,20,21,21,22,23,24,25,26,26,27,28,29,30,31,31,32,33,34,35,36,36,37,38,39,40,41,41,42,43,44,45,46,46,47,48,49,50,51,51,52,53,54,55,56,56,57,58,59,60,61,61,62,63,64,65,66,66,67,68,69,70,71,71,72,73,74,75,76,76,77,78,79,80,81,81,82,83,84,85,86,86,87,88,89,90,91,91,92,93,94,95,96,96,97,98,99,100,101,101,102,103,104,105,106,106,107,108,109,110,111,111,112,113,114,115,116,116,117,118,119,120,121,121,122,123,124,125,126,126,127,128,129,130,131,131,132,133,134,135,136,136,137,138,139,140,141,141,142,143,144,145,146,146,147,148,149,150,151,151,152,153,154,155,156,156,157,158,159,160,161,161,162,163,164,165,166,166,167,168,169,170,171,171},
    {16,16,17,18,19,20,21,21,22,23,24,25,26,26,27,28,29,30,31,31,32,33,34,35,36,36,37,38,39,40,41,41,42,43,44,45,46,46,47,48,49,50,51,51,52,53,54,55,56,56,57,58,59,60,61,61,62,63,64,65,66,66,67,68,69,70,71,71,72,73,74,75,76,76,77,78,79,80,81,81,82,83,84,85,86,86,87,88,89,90,91,91,92,93,94,95,96,96,97,98,99,100,101,101,102,103,104,105,106,106,107,108,109,110,111,111,112,113,114,115,116,116,117,118,119,120,121,121,122,123,124,125,126,126,127,128,129,130,131,131,132,133,134,135,136,136,137,138,139,140,141,141,142,143,144,145,146,146,147,148,149,150,151,151,152,153,154,155,156,156,157,158,159,160,161,161,162,163,164,165,166,166,167,168,169,170,171,171},
    {13,14,15,16,16,17,18,19,20,21,22,22,23,24,25,26,27,28,28,29,30,31,32,33,34,34,35,36,37,38,39,40,40,41,42,43,44,45,46,47,47,48,49,50,51,52,53,53,54,55,56,57,58,59,59,60,61,62,63,64,65,65,66,67,68,69,70,71,72,72,73,74,75,76,77,78,78,79,80,81,82,83,84,84,85,86,87,88,89,90,90,91,92,93,94,95,96,97,97,98,99,100,101,102,103,103,104,105,106,107,108,109,109,110,111,112,113,114,115,115,116,117,118,119,120,121,122,122,123,124,125,126,127,128,128,129,130,131,132,133,134,134,135,136,137,138,139,140,140,141,142,143,144,145,146,147,147,148,149,150,151,152,153,153,154,155,156,157,158,159,159,160,161,162,163,164,165,165,166,167,168,169,170,171,171,172,173,174},
    {13,14,15,16,16,17,18,19,20,21,22,22,23,24,25,26,27,28,28,29,30,31,32,33,34,34,35,36,37,38,39,40,40,41,42,43,44,45,46,47,47,48,49,50,51,52,53,53,54,55,56,57,58,59,59,60,61,62,63,64,65,65,66,67,68,69,70,71,72,72,73,74,75,76,77,78,78,79,80,81,82,83,84,84,85,86,87,88,89,90,90,91,92,93,94,95,96,97,97,98,99,100,101,102,103,103,104,105,106,107,108,109,109,110,111,112,113,114,115,115,116,117,118,119,120,121,122,122,123,124,125,126,127,128,128,129,130,131,132,133,134,134,135,136,137,138,139,140,140,141,142,143,144,145,146,147,147,148,149,150,151,152,153,153,154,155,156,157,158,159,159,160,161,162,163,164,165,165,166,167,168,169,170,171,171,172,173,174},
    {13,14,15,16,16,17,18,19,20,21,22,22,23,24,25,26,27,28,28,29,30,31,32,33,34,34,35,36,37,38,39,40,40,41,42,43,44,45,46,47,47,48,49,50,51,52,53,53,54,55,56,57,58,59,59,60,61,62,63,64,65,65,66,67,68,69,70,71,72,72,73,74,75,76,77,78,78,79,80,81,82,83,84,84,85,86,87,88,89,90,90,91,92,93,94,95,96,97,97,98,99,100,101,102,103,103,104,105,106,107,108,109,109,110,111,112,113,114,115,115,116,117,118,119,120,121,122,122,123,124,125,126,127,128,128,129,130,131,132,133,134,134,135,136,137,138,139,140,140,141,142,143,144,145,146,147,147,148,149,150,151,152,153,153,154,155,156,157,158,159,159,160,161,162,163,164,165,165,166,167,168,169,170,171,171,172,173,174},
    {10,11,12,13,14,15,16,16,17,18,19,20,21,22,23,24,24,25,26,27,28,29,30,31,32,32,33,34,35,36,37,38,39,40,40,41,42,43,44,45,46,47,48,49,49,50,51,52,53,54,55,56,57,57,58,59,60,61,62,63,64,65,65,66,67,68,69,70,71,72,73,73,74,75,76,77,78,79,80,81,81,82,83,84,85,86,87,88,89,89,90,91,92,93,94,95,96,97,98,98,99,100,101,102,103,104,105,106,106,107,108,109,110,111,112,113,114,114,115,116,117,118,119,120,121,122,122,123,124,125,126,127,128,129,130,130,131,132,133,134,135,136,137,138,138,139,140,141,142,143,144,145,146,147,147,148,149,150,151,152,153,154,155,155,156,157,158,159,160,161,162,163,163,164,165,166,167,168,169,170,171,171,172,173,174,175,176,177},
    {10,11,12,13,14,15,16,16,17,18,19,20,21,22,23,24,24,25,26,27,28,29,30,31,32,32,33,34,35,36,37,38,39,40,40,41,42,43,44,45,46,47,48,49,49,50,51,52,53,54,55,56,57,57,58,59,60,61,62,63,64,65,65,66,67,68,69,70,71,72,73,73,74,75,76,77,78,79,80,81,81,82,83,84,85,86,87,88,89,89,90,91,92,93,94,95,96,97,98,98,99,100,101,102,103,104,105,106,106,107,108,109,110,111,112,113,114,114,115,116,117,118,119,120,121,122,122,123,124,125,126,127,128,129,130,130,131,132,133,134,135,136,137,138,138,139,140,141,142,143,144,145,146,147,147,148,149,150,151,152,153,154,155,155,156,157,158,159,160,161,162,163,163,164,165,166,167,168,169,170,171,171,172,173,174,175,176,177},
    {10,11,12,13,14,15,16,16,17,18,19,20,21,22,23,24,24,25,26,27,28,29,30,31,32,32,33,34,35,36,37,38,39,40,40,41,42,43,44,45,46,47,48,49,49,50,51,52,53,54,55,56,57,57,58,59,60,61,62,63,64,65,65,66,67,68,69,70,71,72,73,73,74,75,76,77,78,79,80,81,81,82,83,84,85,86,87,88,89,89,90,91,92,93,94,95,96,97,98,98,99,100,101,102,103,104,105,106,106,107,108,109,110,111,112,113,114,114,115,116,117,118,119,120,121,122,122,123,124,125,126,127,128,129,130,130,131,132,133,134,135,136,137,138,138,139,140,141,142,143,144,145,146,147,147,148,149,150,151,152,153,154,155,155,156,157,158,159,160,161,162,163,163,164,165,166,167,168,169,170,171,171,172,173,174,175,176,177},
    {7,8,9,10,11,12,13,14,15,16,17,18,19,19,20,21,22,23,24,25,26,27,28,29,30,30,31,32,33,34,35,36,37,38,39,40,41,42,42,43,44,45,46,47,48,49,50,51,52,53,53,54,55,56,57,58,59,60,61,62,63,64,65,65,66,67,68,69,70,71,72,73,74,75,76,76,77,78,79,80,81,82,83,84,85,86,87,88,88,89,90,91,92,93,94,95,96,97,98,99,99,100,101,102,103,104,105,106,107,108,109,110,111,111,112,113,114,115,116,117,118,119,120,121,122,122,123,124,125,126,127,128,129,130,131,132,133,134,134,135,136,137,138,139,140,141,142,143,144,145,145,146,147,148,149,150,151,152,153,154,155,156,157,157,158,159,160,161,162,163,164,165,166,167,168,168,169,170,171,172,173,174,175,176,177,178,179,180},
    {7,8,9,10,11,12,13,14,15,16,17,18,19,19,20,21,22,23,24,25,26,27,28,29,30,30,31,32,33,34,35,36,37,38,39,40,41,42,42,43,44,45,46,47,48,49,50,51,52,53,53,54,55,56,57,58,59,60,61,62,63,64,65,65,66,67,68,69,70,71,72,73,74,75,76,76,77,78,79,80,81,82,83,84,85,86,87,88,88,89,90,91,92,93,94,95,96,97,98,99,99,100,101,102,103,104,105,106,107,108,109,110,111,111,112,113,114,115,116,117,118,119,120,121,122,122,123,124,125,126,127,128,129,130,131,132,133,134,134,135,136,137,138,139,140,141,142,143,144,145,145,146,147,148,149,150,151,152,153,154,155,156,157,157,158,159,160,161,162,163,164,165,166,167,168,168,169,170,171,172,173,174,175,176,177,178,179,180},
    {5,6,7,8,9,10,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,177,178,179,180,181,182},
    {5,6,7,8,9,10,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,177,178,179,180,181,182},
    {5,6,7,8,9,10,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,177,178,179,180,181,182},
    {2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185},
    {2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185},
    {0,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,187},
    {0,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,187},
    {0,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,187},
    {255,255,255,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,255,255,255},
    {255,255,255,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,255,255,255},
    {255,255,255,255,255,0,0,1,2,3,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,184,185,186,187,187,255,255,255,255,255},
    {255,255,255,255,255,0,0,1,2,3,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,184,185,186,187,187,255,255,255,255,255},
    {255,255,255,255,255,255,255,255,0,1,2,3,4,5,7,8,9,10,11,12,13,14,15,16,17,19,20,21,22,23,24,25,26,27,28,29,31,32,33,34,35,36,37,38,39,40,42,43,44,45,46,47,48,49,50,51,52,54,55,56,57,58,59,60,61,62,63,65,66,67,68,69,70,71,72,73,74,75,77,78,79,80,81,82,83,84,85,86,87,89,90,91,92,93,94,95,96,97,98,100,101,102,103,104,105,106,107,108,109,110,112,113,114,115,116,117,118,119,120,121,122,124,125,126,127,128,129,130,131,132,133,135,136,137,138,139,140,141,142,143,144,145,147,148,149,150,151,152,153,154,155,156,158,159,160,161,162,163,164,165,166,167,168,170,171,172,173,174,175,176,177,178,179,180,182,183,184,185,186,187,255,255,255,255,255,255,255,255},
    {255,255,255,255,255,255,255,255,0,1,2,3,4,5,7,8,9,10,11,12,13,14,15,16,17,19,20,21,22,23,24,25,26,27,28,29,31,32,33,34,35,36,37,38,39,40,42,43,44,45,46,47,48,49,50,51,52,54,55,56,57,58,59,60,61,62,63,65,66,67,68,69,70,71,72,73,74,75,77,78,79,80,81,82,83,84,85,86,87,89,90,91,92,93,94,95,96,97,98,100,101,102,103,104,105,106,107,108,109,110,112,113,114,115,116,117,118,119,120,121,122,124,125,126,127,128,129,130,131,132,133,135,136,137,138,139,140,141,142,143,144,145,147,148,149,150,151,152,153,154,155,156,158,159,160,161,162,163,164,165,166,167,168,170,171,172,173,174,175,176,177,178,179,180,182,183,184,185,186,187,255,255,255,255,255,255,255,255},
    {255,255,255,255,255,255,255,255,255,255,0,1,2,3,4,5,6,8,9,10,11,12,13,14,15,17,18,19,20,21,22,23,24,26,27,28,29,30,31,32,33,35,36,37,38,39,40,41,42,44,45,46,47,48,49,50,51,53,54,55,56,57,58,59,60,61,63,64,65,66,67,68,69,70,72,73,74,75,76,77,78,79,81,82,83,84,85,86,87,88,90,91,92,93,94,95,96,97,99,100,101,102,103,104,105,106,108,109,110,111,112,113,114,115,117,118,119,120,121,122,123,124,126,127,128,129,130,131,132,133,134,136,137,138,139,140,141,142,143,145,146,147,148,149,150,151,152,154,155,156,157,158,159,160,161,163,164,165,166,167,168,169,170,172,173,174,175,176,177,178,179,181,182,183,184,185,186,187,255,255,255,255,255,255,255,255,255,255},
    {255,255,255,255,255,255,255,255,255,255,0,1,2,3,4,5,6,8,9,10,11,12,13,14,15,17,18,19,20,21,22,23,24,26,27,28,29,30,31,32,33,35,36,37,38,39,40,41,42,44,45,46,47,48,49,50,51,53,54,55,56,57,58,59,60,61,63,64,65,66,67,68,69,70,72,73,74,75,76,77,78,79,81,82,83,84,85,86,87,88,90,91,92,93,94,95,96,97,99,100,101,102,103,104,105,106,108,109,110,111,112,113,114,115,117,118,119,120,121,122,123,124,126,127,128,129,130,131,132,133,134,136,137,138,139,140,141,142,143,145,146,147,148,149,150,151,152,154,155,156,157,158,159,160,161,163,164,165,166,167,168,169,170,172,173,174,175,176,177,178,179,181,182,183,184,185,186,187,255,255,255,255,255,255,255,255,255,255},
    {255,255,255,255,255,255,255,255,255,255,255,255,0,1,2,3,4,5,7,8,9,10,11,12,13,15,16,17,18,19,20,21,23,24,25,26,27,28,30,31,32,33,34,35,36,38,39,40,41,42,43,45,46,47,48,49,50,51,53,54,55,56,57,58,60,61,62,63,64,65,66,68,69,70,71,72,73,74,76,77,78,79,80,81,83,84,85,86,87,88,89,91,92,93,94,95,96,98,99,100,101,102,103,104,106,107,108,109,110,111,113,114,115,116,117,118,119,121,122,123,124,125,126,127,129,130,131,132,133,134,136,137,138,139,140,141,142,144,145,146,147,148,149,151,152,153,154,155,156,157,159,160,161,162,163,164,166,167,168,169,170,171,172,174,175,176,177,178,179,180,182,183,184,185,186,187,255,255,255,255,255,255,255,255,255,255,255,255},
    {255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,1,2,3,4,5,7,8,9,10,11,13,14,15,16,17,18,20,21,22,23,24,26,27,28,29,30,31,33,34,35,36,37,39,40,41,42,43,44,46,47,48,49,50,52,53,54,55,56,57,59,60,61,62,63,65,66,67,68,69,70,72,73,74,75,76,78,79,80,81,82,83,85,86,87,88,89,91,92,93,94,95,96,98,99,100,101,102,104,105,106,107,108,109,111,112,113,114,115,117,118,119,120,121,122,124,125,126,127,128,130,131,132,133,134,135,137,138,139,140,141,143,144,145,146,147,148,150,151,152,153,154,156,157,158,159,160,161,163,164,165,166,167,169,170,171,172,173,174,176,177,178,179,180,182,183,184,185,186,187,255,255,255,255,255,255,255,255,255,255,255,255,255,255},
    {255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,1,2,3,4,5,7,8,9,10,11,13,14,15,16,17,18,20,21,22,23,24,26,27,28,29,30,31,33,34,35,36,37,39,40,41,42,43,44,46,47,48,49,50,52,53,54,55,56,57,59,60,61,62,63,65,66,67,68,69,70,72,73,74,75,76,78,79,80,81,82,83,85,86,87,88,89,91,92,93,94,95,96,98,99,100,101,102,104,105,106,107,108,109,111,112,113,114,115,117,118,119,120,121,122,124,125,126,127,128,130,131,132,133,134,135,137,138,139,140,141,143,144,145,146,147,148,150,151,152,153,154,156,157,158,159,160,161,163,164,165,166,167,169,170,171,172,173,174,176,177,178,179,180,182,183,184,185,186,187,255,255,255,255,255,255,255,255,255,255,255,255,255,255},
    {255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,1,2,3,5,6,7,8,9,11,12,13,14,15,17,18,19,20,21,23,24,25,26,28,29,30,31,32,34,35,36,37,38,40,41,42,43,44,46,47,48,49,51,52,53,54,55,57,58,59,60,61,63,64,65,66,67,69,70,71,72,74,75,76,77,78,80,81,82,83,84,86,87,88,89,90,92,93,94,95,97,98,99,100,101,103,104,105,106,107,109,110,111,112,113,115,116,117,118,120,121,122,123,124,126,127,128,129,130,132,133,134,135,136,138,139,140,141,143,144,145,146,147,149,150,151,152,153,155,156,157,158,159,161,162,163,164,166,167,168,169,170,172,173,174,175,176,178,179,180,181,182,184,185,186,187,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255},
    {255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,1,2,4,5,6,7,9,10,11,12,14,15,16,17,19,20,21,22,23,25,26,27,28,30,31,32,33,35,36,37,38,40,41,42,43,45,46,47,48,50,51,52,53,54,56,57,58,59,61,62,63,64,66,67,68,69,71,72,73,74,76,77,78,79,80,82,83,84,85,87,88,89,90,92,93,94,95,97,98,99,100,102,103,104,105,107,108,109,110,111,113,114,115,116,118,119,120,121,123,124,125,126,128,129,130,131,133,134,135,136,137,139,140,141,142,144,145,146,147,149,150,151,152,154,155,156,157,159,160,161,162,164,165,166,167,168,170,171,172,173,175,176,177,178,180,181,182,183,185,186,187,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255},
    {255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,1,2,4,5,6,7,9,10,11,12,14,15,16,17,19,20,21,22,23,25,26,27,28,30,31,32,33,35,36,37,38,40,41,42,43,45,46,47,48,50,51,52,53,54,56,57,58,59,61,62,63,64,66,67,68,69,71,72,73,74,76,77,78,79,80,82,83,84,85,87,88,89,90,92,93,94,95,97,98,99,100,102,103,104,105,107,108,109,110,111,113,114,115,116,118,119,120,121,123,124,125,126,128,129,130,131,133,134,135,136,137,139,140,141,142,144,145,146,147,149,150,151,152,154,155,156,157,159,160,161,162,164,165,166,167,168,170,171,172,173,175,176,177,178,180,181,182,183,185,186,187,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255},
    {255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,0,2,3,4,5,7,8,9,10,12,13,14,15,17,18,19,21,22,23,24,26,27,28,29,31,32,33,35,36,37,38,40,41,42,43,45,46,47,48,50,51,52,54,55,56,57,59,60,61,62,64,65,66,67,69,70,71,73,74,75,76,78,79,80,81,83,84,85,87,88,89,90,92,93,94,95,97,98,99,100,102,103,104,106,107,108,109,111,112,113,114,116,117,118,120,121,122,123,125,126,127,128,130,131,132,133,135,136,137,139,140,141,142,144,145,146,147,149,150,151,152,154,155,156,158,159,160,161,163,164,165,166,168,169,170,172,173,174,175,177,178,179,180,182,183,184,185,187,187,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255},
    {255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,1,2,3,5,6,7,9,10,11,12,14,15,16,18,19,20,21,23,24,25,27,28,29,31,32,33,34,36,37,38,40,41,42,44,45,46,47,49,50,51,53,54,55,57,58,59,60,62,63,64,66,67,68,69,71,72,73,75,76,77,79,80,81,82,84,85,86,88,89,90,92,93,94,95,97,98,99,101,102,103,105,106,107,108,110,111,112,114,115,116,118,119,120,121,123,124,125,127,128,129,130,132,133,134,136,137,138,140,141,142,143,145,146,147,149,150,151,153,154,155,156,158,159,160,162,163,164,166,167,168,169,171,172,173,175,176,177,178,180,181,182,184,185,186,187,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255},
    {255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,1,2,3,5,6,7,9,10,11,12,14,15,16,18,19,20,21,23,24,25,27,28,29,31,32,33,34,36,37,38,40,41,42,44,45,46,47,49,50,51,53,54,55,57,58,59,60,62,63,64,66,67,68,69,71,72,73,75,76,77,79,80,81,82,84,85,86,88,89,90,92,93,94,95,97,98,99,101,102,103,105,106,107,108,110,111,112,114,115,116,118,119,120,121,123,124,125,127,128,129,130,132,133,134,136,137,138,140,141,142,143,145,146,147,149,150,151,153,154,155,156,158,159,160,162,163,164,166,167,168,169,171,172,173,175,176,177,178,180,181,182,184,185,186,187,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255},
    {255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,1,3,4,5,7,8,9,11,12,13,15,16,17,19,20,21,23,24,25,27,28,29,30,32,33,34,36,37,38,40,41,42,44,45,46,48,49,50,52,53,54,56,57,58,60,61,62,64,65,66,68,69,70,72,73,74,76,77,78,80,81,82,84,85,86,88,89,90,92,93,94,95,97,98,99,101,102,103,105,106,107,109,110,111,113,114,115,117,118,119,121,122,123,125,126,127,129,130,131,133,134,135,137,138,139,141,142,143,145,146,147,149,150,151,153,154,155,157,158,159,160,162,163,164,166,167,168,170,171,172,174,175,176,178,179,180,182,183,184,186,187,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255},
    {255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,1,2,3,5,6,7,9,10,11,13,14,16,17,18,20,21,22,24,25,26,28,29,30,32,33,35,36,37,39,40,41,43,44,45,47,48,49,51,52,54,55,56,58,59,60,62,63,64,66,67,68,70,71,72,74,75,77,78,79,81,82,83,85,86,87,89,90,91,93,94,96,97,98,100,101,102,104,105,106,108,109,110,112,113,115,116,117,119,120,121,123,124,125,127,128,129,131,132,133,135,136,138,139,140,142,143,144,146,147,148,150,151,152,154,155,157,158,159,161,162,163,165,166,167,169,170,171,173,174,176,177,178,180,181,182,184,185,186,187,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255},
    {255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,0,1,3,4,6,7,8,10,11,12,14,15,17,18,19,21,22,24,25,26,28,29,30,32,33,35,36,37,39,40,42,43,44,46,47,48,50,51,53,54,55,57,58,60,61,62,64,65,66,68,69,71,72,73,75,76,78,79,80,82,83,84,86,87,89,90,91,93,94,96,97,98,100,101,103,104,105,107,108,109,111,112,114,115,116,118,119,121,122,123,125,126,127,129,130,132,133,134,136,137,139,140,141,143,144,145,147,148,150,151,152,154,155,157,158,159,161,162,163,165,166,168,169,170,172,173,175,176,177,179,180,181,183,184,186,187,187,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255},
    {255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,0,1,3,4,6,7,8,10,11,12,14,15,17,18,19,21,22,24,25,26,28,29,30,32,33,35,36,37,39,40,42,43,44,46,47,48,50,51,53,54,55,57,58,60,61,62,64,65,66,68,69,71,72,73,75,76,78,79,80,82,83,84,86,87,89,90,91,93,94,96,97,98,100,101,103,104,105,107,108,109,111,112,114,115,116,118,119,121,122,123,125,126,127,129,130,132,133,134,136,137,139,140,141,143,144,145,147,148,150,151,152,154,155,157,158,159,161,162,163,165,166,168,169,170,172,173,175,176,177,179,180,181,183,184,186,187,187,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255},
    {255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,1,2,4,5,7,8,9,11,12,14,15,16,18,19,21,22,24,25,26,28,29,31,32,33,35,36,38,39,40,42,43,45,46,48,49,50,52,53,55,56,57,59,60,62,63,65,66,67,69,70,72,73,74,76,77,79,80,81,83,84,86,87,89,90,91,93,94,96,97,98,100,101,103,104,106,107,108,110,111,113,114,115,117,118,120,121,122,124,125,127,128,130,131,132,134,135,137,138,139,141,142,144,145,147,148,149,151,152,154,155,156,158,159,161,162,163,165,166,168,169,171,172,173,175,176,178,179,180,182,183,185,186,187,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255},
    {255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,0,2,3,5,6,8,9,11,12,13,15,16,18,19,21,22,24,25,26,28,29,31,32,34,35,37,38,39,41,42,44,45,47,48,49,51,52,54,55,57,58,60,61,62,64,65,67,68,70,71,73,74,75,77,78,80,81,83,84,86,87,88,90,91,93,94,96,97,99,100,101,103,104,106,107,109,110,112,113,114,116,117,119,120,122,123,125,126,127,129,130,132,133,135,136,138,139,140,142,143,145,146,148,149,150,152,153,155,156,158,159,161,162,163,165,166,168,169,171,172,174,175,176,178,179,181,182,184,185,187,187,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255},
    {255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,0,2,3,4,6,7,9,10,12,13,15,16,18,19,21,22,24,25,27,28,29,31,32,34,35,37,38,40,41,43,44,46,47,49,50,52,53,54,56,57,59,60,62,63,65,66,68,69,71,72,74,75,77,78,80,81,82,84,85,87,88,90,91,93,94,96,97,99,100,102,103,105,106,107,109,110,112,113,115,116,118,119,121,122,124,125,127,128,130,131,133,134,135,137,138,140,141,143,144,146,147,149,150,152,153,155,156,158,159,160,162,163,165,166,168,169,171,172,174,175,177,178,180,181,183,184,185,187,187,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255},
    {255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,1,3,4,6,7,9,10,12,13,15,16,18,19,21,22,24,25,27,28,30,31,33,34,36,37,39,40,42,43,45,46,48,49,51,52,54,55,57,58,60,61,63,64,66,67,69,70,72,73,75,76,78,79,81,82,84,85,87,88,90,91,93,94,96,97,99,100,102,103,105,106,108,109,111,112,114,115,117,118,120,121,123,124,126,127,129,130,132,133,135,136,138,139,141,142,144,145,147,148,150,151,153,154,156,157,159,160,162,163,165,166,168,169,171,172,174,175,177,178,180,181,183,184,186,187,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255},
    {255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,1,2,4,6,7,9,10,12,13,15,16,18,19,21,22,24,25,27,28,30,32,33,35,36,38,39,41,42,44,45,47,48,50,51,53,54,56,58,59,61,62,64,65,67,68,70,71,73,74,76,77,79,80,82,84,85,87,88,90,91,93,94,96,97,99,100,102,103,105,107,108,110,111,113,114,116,117,119,120,122,123,125,126,128,129,131,133,134,136,137,139,140,142,143,145,146,148,149,151,152,154,155,157,159,160,162,163,165,166,168,169,171,172,174,175,177,178,180,181,183,185,186,187,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255},
    {255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,1,2,4,5,7,9,10,12,13,15,16,18,19,21,23,24,26,27,29,30,32,33,35,37,38,40,41,43,44,46,48,49,51,52,54,55,57,58,60,62,63,65,66,68,69,71,72,74,76,77,79,80,82,83,85,86,88,90,91,93,94,96,97,99,101,102,104,105,107,108,110,111,113,115,116,118,119,121,122,124,125,127,129,130,132,133,135,136,138,139,141,143,144,146,147,149,150,152,154,155,157,158,160,161,163,164,166,168,169,171,172,174,175,177,178,180,182,183,185,186,187,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255},
    {255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,1,2,4,5,7,9,10,12,13,15,16,18,20,21,23,24,26,28,29,31,32,34,36,37,39,40,42,43,45,47,48,50,51,53,55,56,58,59,61,63,64,66,67,69,70,72,74,75,77,78,80,82,83,85,86,88,90,91,93,94,96,97,99,101,102,104,105,107,109,110,112,113,115,117,118,120,121,123,124,126,128,129,131,132,134,136,137,139,140,142,144,145,147,148,150,151,153,155,156,158,159,161,163,164,166,167,169,171,172,174,175,177,178,180,182,183,185,186,187,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255},
    {255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,1,2,4,5,7,9,10,12,13,15,17,18,20,22,23,25,26,28,30,31,33,34,36,38,39,41,43,44,46,47,49,51,52,54,56,57,59,60,62,64,65,67,68,70,72,73,75,77,78,80,81,83,85,86,88,89,91,93,94,96,98,99,101,102,104,106,107,109,110,112,114,115,117,119,120,122,123,125,127,128,130,131,133,135,136,138,140,141,143,144,146,148,149,151,153,154,156,157,159,161,162,164,165,167,169,170,172,174,175,177,178,180,182,183,185,186,187,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255},
    {255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,1,2,4,6,7,9,11,12,14,16,17,19,21,22,24,26,27,29,31,32,34,36,37,39,41,42,44,46,47,49,51,52,54,56,57,59,61,63,64,66,68,69,71,73,74,76,78,79,81,83,84,86,88,89,91,93,94,96,98,99,101,103,104,106,108,109,111,113,114,116,118,119,121,123,124,126,128,130,131,133,135,136,138,140,141,143,145,146,148,150,151,153,155,156,158,160,161,163,165,166,168,170,171,173,175,176,178,180,181,183,185,186,187,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255},
    {255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,1,2,4,6,7,9,11,13,14,16,18,19,21,23,24,26,28,30,31,33,35,36,38,40,42,43,45,47,48,50,52,53,55,57,59,60,62,64,65,67,69,70,72,74,76,77,79,81,82,84,86,88,89,91,93,94,96,98,99,101,103,105,106,108,110,111,113,115,117,118,120,122,123,125,127,128,130,132,134,135,137,139,140,142,144,145,147,149,151,152,154,156,157,159,161,163,164,166,168,169,171,173,174,176,178,180,181,183,185,186,187,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255},
    {255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,1,3,4,6,8,9,11,13,15,16,18,20,22,23,25,27,29,30,32,34,35,37,39,41,42,44,46,48,49,51,53,55,56,58,60,61,63,65,67,68,70,72,74,75,77,79,81,82,84,86,87,89,91,93,94,96,98,100,101,103,105,106,108,110,112,113,115,117,119,120,122,124,126,127,129,131,132,134,136,138,139,141,143,145,146,148,150,152,153,155,157,158,160,162,164,165,167,169,171,172,174,176,178,179,181,183,184,186,187,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255},
    {255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,1,3,5,6,8,10,12,13,15,17,19,20,22,24,26,27,29,31,33,34,36,38,40,42,43,45,47,49,50,52,54,56,57,59,61,63,64,66,68,70,71,73,75,77,79,80,82,84,86,87,89,91,93,94,96,98,100,101,103,105,107,108,110,112,114,116,117,119,121,123,124,126,128,130,131,133,135,137,138,140,142,144,145,147,149,151,153,154,156,158,160,161,163,165,167,168,170,172,174,175,177,179,181,182,184,186,187,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255},
    {255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,2,3,5,7,9,11,12,14,16,18,20,22,23,25,27,29,31,33,34,36,38,40,42,43,45,47,49,51,53,54,56,58,60,62,63,65,67,69,71,73,74,76,78,80,82,83,85,87,89,91,93,94,96,98,100,102,104,105,107,109,111,113,114,116,118,120,122,124,125,127,129,131,133,134,136,138,140,142,144,145,147,149,151,153,154,156,158,160,162,164,165,167,169,171,173,175,176,178,180,182,184,185,187,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255},
    {255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,0,2,4,6,8,9,11,13,15,17,19,20,22,24,26,28,30,32,33,35,37,39,41,43,44,46,48,50,52,54,56,57,59,61,63,65,67,69,70,72,74,76,78,80,81,83,85,87,89,91,93,94,96,98,100,102,104,106,107,109,111,113,115,117,118,120,122,124,126,128,130,131,133,135,137,139,141,143,144,146,148,150,152,154,155,157,159,161,163,165,167,168,170,172,174,176,178,179,181,183,185,187,187,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255},
    {255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,1,3,5,7,9,11,12,14,16,18,20,22,24,26,28,30,32,33,35,37,39,41,43,45,47,49,51,52,54,56,58,60,62,64,66,68,70,72,73,75,77,79,81,83,85,87,89,91,93,94,96,98,100,102,104,106,108,110,112,114,115,117,119,121,123,125,127,129,131,133,135,136,138,140,142,144,146,148,150,152,154,155,157,159,161,163,165,167,169,171,173,175,176,178,180,182,184,186,187,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255},
    {255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,2,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,63,65,67,69,71,73,75,77,79,81,83,85,87,89,91,93,94,96,98,100,102,104,106,108,110,112,114,116,118,120,122,124,125,127,129,131,133,135,137,139,141,143,145,147,149,151,153,154,156,158,160,162,164,166,168,170,172,174,176,178,180,182,184,185,187,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255},
    {255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53,55,57,59,61,63,65,67,69,71,73,75,77,79,81,83,85,87,89,91,93,94,96,98,100,102,104,106,108,110,112,114,116,118,120,122,124,126,128,130,132,134,136,138,140,142,144,146,148,150,152,154,156,158,160,162,164,166,168,170,172,174,176,178,180,182,184,186,187,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255},
    {255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,0,2,4,6,8,10,12,14,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,95,97,99,101,103,105,107,109,111,113,115,117,119,121,123,125,127,129,131,134,136,138,140,142,144,146,148,150,152,154,156,158,160,162,164,166,168,170,173,175,177,179,181,183,185,187,187,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255},
    {255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,2,4,6,8,10,12,14,16,19,21,23,25,27,29,31,33,35,38,40,42,44,46,48,50,52,54,57,59,61,63,65,67,69,71,73,76,78,80,82,84,86,88,90,92,95,97,99,101,103,105,107,109,111,114,116,118,120,122,124,126,128,130,133,135,137,139,141,143,145,147,149,152,154,156,158,160,162,164,166,168,171,173,175,177,179,181,183,185,187,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255},
    {255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,1,3,6,8,10,12,14,17,19,21,23,25,27,30,32,34,36,38,40,43,45,47,49,51,53,56,58,60,62,64,66,69,71,73,75,77,79,82,84,86,88,90,92,95,97,99,101,103,105,108,110,112,114,116,118,121,123,125,127,129,131,134,136,138,140,142,144,147,149,151,153,155,157,160,162,164,166,168,170,173,175,177,179,181,184,186,187,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255},
    {255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,1,3,6,8,10,12,14,17,19,21,23,26,28,30,32,34,37,39,41,43,46,48,50,52,55,57,59,61,63,66,68,70,72,75,77,79,81,83,86,88,90,92,95,97,99,101,104,106,108,110,112,115,117,119,121,124,126,128,130,132,135,137,139,141,144,146,148,150,153,155,157,159,161,164,166,168,170,173,175,177,179,181,184,186,187,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255},
    {255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,1,3,6,8,10,12,15,17,19,22,24,26,28,31,33,35,38,40,42,44,47,49,51,54,56,58,60,63,65,67,70,72,74,76,79,81,83,86,88,90,92,95,97,99,101,104,106,108,111,113,115,117,120,122,124,127,129,131,133,136,138,140,143,145,147,149,152,154,156,159,161,163,165,168,170,172,175,177,179,181,184,186,187,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255},
    {255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,1,3,6,8,10,13,15,17,20,22,24,27,29,31,34,36,38,41,43,45,48,50,52,55,57,60,62,64,67,69,71,74,76,78,81,83,85,88,90,92,95,97,99,102,104,106,109,111,113,116,118,120,123,125,127,130,132,135,137,139,142,144,146,149,151,153,156,158,160,163,165,167,170,172,174,177,179,181,184,186,187,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255},
    {255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,2,5,7,10,12,15,17,19,22,24,27,29,32,34,36,39,41,44,46,49,51,53,56,58,61,63,66,68,70,73,75,78,80,83,85,87,90,92,95,97,100,102,104,107,109,112,114,117,119,121,124,126,129,131,134,136,138,141,143,146,148,151,153,155,158,160,163,165,168,170,172,175,177,180,182,185,187,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255},
    {255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,0,3,5,8,10,13,15,18,20,23,25,28,30,33,35,38,40,42,45,47,50,52,55,57,60,62,65,67,70,72,75,77,80,82,85,87,90,92,95,97,100,102,105,107,110,112,115,117,120,122,125,127,130,132,135,137,140,142,145,147,149,152,154,157,159,162,164,167,169,172,174,177,179,182,184,187,187,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255},
    {255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,2,5,7,10,12,15,18,20,23,25,28,30,33,36,38,41,43,46,48,51,54,56,59,61,64,66,69,72,74,77,79,82,84,87,90,92,95,97,100,103,105,108,110,113,115,118,121,123,126,128,131,133,136,139,141,144,146,149,151,154,157,159,162,164,167,169,172,175,177,180,182,185,187,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255},
    {255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,2,4,7,10,12,15,18,20,23,26,28,31,34,36,39,42,44,47,50,52,55,58,60,63,66,68,71,74,76,79,82,84,87,90,92,95,97,100,103,105,108,111,113,116,119,121,124,127,129,132,135,137,140,143,145,148,151,153,156,159,161,164,167,169,172,175,177,180,183,185,187,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255},
    {255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,1,4,7,10,12,15,18,21,23,26,29,32,34,37,40,43,45,48,51,54,56,59,62,65,67,70,73,76,78,81,84,87,89,92,95,98,100,103,106,109,111,114,117,120,122,125,128,131,133,136,139,142,144,147,150,153,155,158,161,164,166,169,172,175,177,180,183,186,187,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255},
    {255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,0,3,6,9,12,15,18,20,23,26,29,32,35,38,40,43,46,49,52,55,58,61,63,66,69,72,75,78,81,83,86,89,92,95,98,101,104,106,109,112,115,118,121,124,126,129,132,135,138,141,144,147,149,152,155,158,161,164,167,169,172,175,178,181,184,187,187,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255},
    {255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,3,6,9,11,14,17,20,23,26,29,32,35,38,41,44,47,50,53,56,59,62,65,68,71,74,77,80,83,86,89,92,95,98,101,104,107,110,113,116,119,122,125,128,131,134,137,140,143,146,149,152,155,158,161,164,167,170,173,176,178,181,184,187,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255},
    {255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,2,5,8,11,14,18,21,24,27,30,33,36,39,42,45,49,52,55,58,61,64,67,70,73,76,80,83,86,89,92,95,98,101,104,107,111,114,117,120,123,126,129,132,135,138,142,145,148,151,154,157,160,163,166,169,173,176,179,182,185,187,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255},
    {255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,2,5,8,12,15,18,21,24,28,31,34,37,40,44,47,50,53,57,60,63,66,69,73,76,79,82,85,89,92,95,98,102,105,108,111,114,118,121,124,127,130,134,137,140,143,147,150,153,156,159,163,166,169,172,175,179,182,185,187,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255},
    {255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,1,4,8,11,15,18,21,25,28,31,35,38,41,45,48,52,55,58,62,65,68,72,75,78,82,85,88,92,95,99,102,105,109,112,115,119,122,125,129,132,135,139,142,146,149,152,156,159,162,166,169,172,176,179,183,186,187,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255},
    {255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,1,4,8,11,15,18,22,25,29,32,36,39,43,46,50,53,57,60,64,67,71,74,78,81,85,88,92,95,99,102,106,109,113,116,120,123,127,130,134,137,141,144,148,151,155,158,162,165,169,172,176,179,183,186,187,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255},
    {255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,0,4,8,11,15,19,22,26,30,33,37,41,44,48,52,55,59,62,66,70,73,77,81,84,88,92,95,99,103,106,110,114,117,121,125,128,132,135,139,143,146,150,154,157,161,165,168,172,176,179,183,187,187,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255},
    {255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,4,7,11,15,19,23,27,30,34,38,42,46,50,53,57,61,65,69,72,76,80,84,88,92,95,99,103,107,111,115,118,122,126,130,134,137,141,145,149,153,157,160,164,168,172,176,180,183,187,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255},
    {255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,3,7,11,15,19,23,27,31,35,39,43,47,51,55,59,63,67,71,75,79,83,87,91,96,100,104,108,112,116,120,124,128,132,136,140,144,148,152,156,160,164,168,172,176,180,184,187,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255} };

////////////////////////////////////////////
//功能：逆透视、去畸变与二值化结合
//输入：
//输出：
//备注：
///////////////////////////////////////////
void transform(int wayThre)
{
//    uint8_t* map;
//    if (wayThre == 2) {
//        map = fullBuffer;
//        for (int i = 0; i < 120; i++) {
//            if (i <= 40) {
//                for (int j = 0; j < 188; j++) {
//                    if (*(map + 188 * transform_x[i][j] + transform_y[i][j]) > thresholdUp) {
//                        IMG[i][j] = white;
//                    }
//                    else {
//                        IMG[i][j] = black;
//                    }
//                    if (j<left_side[i] || j>right_side[i]) {
//                        IMG[i][j] = gray;
//                    }
//                }
//            }
//            else {
//                for (int j = 0; j < 188; j++) {
//                    if (*(map + 188 * transform_x[i][j] + transform_y[i][j]) > thresholdDown) {
//                        IMG[i][j] = white;
//                    }
//                    else {
//                        IMG[i][j] = black;
//                    }
//                    if (j<left_side[i] || j>right_side[i]) {
//                        IMG[i][j] = gray;
//                    }
//                }
//            }
//
//        }
//    }
//    else {
//        map = fullBuffer;
//        for (int i = 0; i < 120; i++) {
//            for (int j = 0; j < 188; j++) {
//                if (*(map + 188 * transform_x[i][j] + transform_y[i][j]) > threshold) {
//                    IMG[i][j] = white;
//                }
//                else {
//                    IMG[i][j] = black;
//                }
//                if (j<left_side[i] || j>right_side[i]) {
//                    IMG[i][j] = gray;
//                }
//            }
//        }
//    }

}

////////////////////////////////////////////
//功能：逆透视、去畸变与二值化结合
//输入：
//输出：
//备注：同SD卡
///////////////////////////////////////////
void transform_sd(int wayThre)
{
//    uint8_t* map;
//    uint8_t* threMap;
//    //uint8_t* mapFullBuffer;
//
//    map = fullBuffer;
//    //mapFullBuffer = map;
//
//    if (wayThre == 2 || wayThre == 1 || wayThre == 3) {
//        //map = fullBuffer;
//        threMap = fullBuffer;
//        //mapFullBuffer = map;
//
//        for (int i = 0; i < 86; i++) {
////            if (i <= 30) {
////                for (int j = 0; j < 188; j++) {
////                    if (*(threMap) > thresholdUp) {
////                        *(threMap) = 255;
////                    }
////                    else {
////                        *(threMap) = 0;
////                    }
////                }
////                threMap++;
////
////
////            }
////            else {
////                for (int j = 0; j < 188; j++) {
////                    if (*(threMap) > thresholdDown) {
////                        *(threMap) = 255;
////                    }
////                    else {
////                        *(threMap) = 0;
////                    }
////                }
////                threMap++;
////
////            }
//        }
//        for (int i = 0; i < 120; i++) {
//            if (i < 30) {
//                for (int j = 0; j < 188; j++) {
//                    if (*(map + 188 * transform_x[i][j] + transform_y[i][j]) > thresholdUp) {
//                        IMG[i][j] = white;
//                    }
//                    else {
//                        IMG[i][j] = black;
//                    }
//                    if (j<left_side[i] || j>right_side[i]) {
//                        IMG[i][j] = gray;
//                    }
//                }
//            }
//            else {
//                for (int j = 0; j < 188; j++) {
//                    if (*(map + 188 * transform_x[i][j] + transform_y[i][j]) > thresholdDown) {
//                        IMG[i][j] = white;
//                    }
//                    else {
//                        IMG[i][j] = black;
//                    }
//                    if (j<left_side[i] || j>right_side[i]) {
//                        IMG[i][j] = gray;
//                    }
//                }
//            }
//
//        }
//    }
//    else if (0) {
//        for (int i = 0; i < 2; i++) {
//            for (int j = 0; j < 4; j++) {
//                map = fullBuffer + 188 * 43 * i + j * 47;
//                for (int m = 0; m < 43; m++) {
//                    threMap = map + 188 * m;
//                    for (int n = 0; n < 47; n++) {
//                        if (*threMap > thresholdAdapt[4 * i + j]) {
//                            *threMap = 255;
//                        }
//                        else {
//                            *threMap = 0;
//                        }
//                        threMap++;
//                    }
//                }
//
//
//            }
//        }
//        for (int i = 0; i < 120; i++) {
//            for (int j = 0; j < 188; j++) {
//                if (*(fullBuffer + 188 * transform_x[i][j] + transform_y[i][j]) > 100)
//                    IMG[i][j] = white;
//                else if (*(fullBuffer + 188 * transform_x[i][j] + transform_y[i][j]) <= 100)
//                    IMG[i][j] = black;
//
//                if (j<left_side[i] || j>right_side[i]) {
//                    IMG[i][j] = gray;
//                }
//            }
//        }
//
//    }
//    else {
//    //  map = fullBuffer;
//        threMap = fullBuffer;
//        //mapFullBuffer = fullBuffer;
//        //////////////////////printf("thre:\n");
//        for (int i = 0; i < 86; i++) {
//            for (int j = 0; j < 188; j++) {
//                if (*(threMap) > threshold) {
//                    *(threMap) = 255;
//                }
//                else {
//                    *(threMap) = 0;
//                }
//
//                //////////////////////printf("%d,", *(fullBuffer));
//                //fullBuffer++;
//                threMap++;
//            }
//            //////////////////////printf("\n");
//        }
//        //map = mapFullBuffer;
//        for (int i = 0; i < 120; i++) {
//            for (int j = 0; j < 188; j++) {
//                if (*(map + 188 * transform_x[i][j] + transform_y[i][j]) > threshold)
//                    IMG[i][j] = white;
//                else if (*(map + 188 * transform_x[i][j] + transform_y[i][j]) <= threshold)
//                    IMG[i][j] = black;
//
//                if (j<left_side[i] || j>right_side[i]) {
//                    IMG[i][j] = gray;
//                }
//            }
//        }
//    }

}



void image_Preprocess(void)
{
    uint16_t image_histGram[256] = { 0 };
    float image_histPorprotion[256];
    uint8_t ThreMax = maxThre, ThreMin = minThre/*, threMiddle = 255*/;
    float image_threUpFix = part_klow1.floatVal, image_threDownFix = part_khigh1.floatVal/*, image_threMiddleFix = 1.0*/;
    uint8_t startLine = 2,endLine=86;
    float* ptrhistPorprotion = &image_histPorprotion[0];
        uint16_t* ptrHistGramCy = image_histGram;
        uint8_t* fullBufferCy = fullBuffer;
        for (uint16_t i = 0; i < 256; i++, ptrHistGramCy++)
        {
            *ptrHistGramCy = 0; //初始化灰度直方图
        }
        ptrHistGramCy = image_histGram;
        for (uint8_t i = startLine; i < endLine; i++)
        {
            for (uint8_t j = 2; j < CAMERA_W; j++, fullBufferCy++)
            {
                (*(ptrHistGramCy + (*fullBufferCy)))++; //统计每个灰度值的个数信息
            }
        }
        //归一化
        for (uint16_t i = 0; i < 256; i++, ptrHistGramCy++, ptrhistPorprotion++)
        {
            *ptrhistPorprotion = (float)(*ptrHistGramCy) / (endLine - startLine)*188;
        }



    int thresholdOrigin = 0;
        uint16_t minValue = 0, maxValue = 255, * ptrHistGram;
        float forePorprotion = 0, backPorprotion = 0, foreAverage = 0, backAverage = 0, maxVariance = 0, tmpVariance = 0, * ptrHistPorprotion;
        float tmpBackAverage = 0, tmpForeAverage = 0;
        //测试
        /*uint16_t amount = 0;
        float porAmount = 0;
        for (uint16_t i = CUT_LINE; i < 256; i++)
        {
            amount += image_histGram[i];
            porAmount += image_histPorprotion[i];
        }
        ////////////////////printf("amount:%d\n", amount);
        ////////////////////printf("porAmount:%f\n", porAmount);*/

        ptrHistGram = &image_histGram[0];
        for (minValue = 0; (*ptrHistGram) == 0 && minValue < 256; minValue++, ptrHistGram++);
        ptrHistGram = &image_histGram[255];
        for (maxValue = 255; (*ptrHistGram) == 0 && maxValue > 0; maxValue--, ptrHistGram--);
        ptrHistPorprotion = &image_histPorprotion[minValue];
        for (uint16_t i = minValue; i <= maxValue; i++, ptrHistPorprotion++)
        {
            forePorprotion += (*ptrHistPorprotion);
            tmpForeAverage += (i * (*ptrHistPorprotion));
        }
        ptrHistPorprotion = &image_histPorprotion[minValue];
        for (uint16_t i = minValue; i <= maxValue; i++, ptrHistPorprotion++)
        {
            //背景
            backPorprotion += (*ptrHistPorprotion);
            tmpBackAverage += (i * (*ptrHistPorprotion));
            backAverage = tmpBackAverage / backPorprotion;
            //前景
            forePorprotion -= (*ptrHistPorprotion);
            tmpForeAverage -= (i * (*ptrHistPorprotion));
            foreAverage = tmpForeAverage / forePorprotion;
            //
            tmpVariance = backPorprotion * forePorprotion * (backAverage - foreAverage) * (backAverage - foreAverage);
            if (tmpVariance > maxVariance)
            {
                maxVariance = tmpVariance;
                thresholdOrigin = i;
            }
        }
    threOriginal = thresholdOrigin;


    if (threOriginal > ThreMax)threOriginal = ThreMax;
    if (threOriginal < ThreMin)threOriginal = ThreMin;
    thresholdUp = threOriginal * image_threUpFix, thresholdDown = threOriginal * image_threDownFix/*, threMiddle = threOriginal * image_threMiddleFix*/;

    ////////////////////printf("ThreUp:%d\n", threUp);
    ////////////////////printf("ThreDown:%d\n", threDown);
    //image_RemoveDistortion();
}


////////////////////////////////////////////
//功能：局部阈值分割
//输入：
//输出：
//备注：
///////////////////////////////////////////
void adapt_threshold() {

    uint8_t* map;
    uint8_t* map1;
    for (int i = 0; i < 2; i++) {
        for (int j = 0; j < 4; j++) {
            map = fullBuffer + 188 * 43 * i + j * 47;
            uint8_t my_threshold = 0;
            long int sum = 0;
            uint8_t thre[256] = { 0 };

            for (int m = 0; m < 43; m++) {
                map1 = map + 188 * m;
                for (int n = 0; n < 47; n++) {
                    thre[*(map1)]++;
                    sum += *(map1);
                    map1++;
                }
            }
            int averange = sum / (43 * 47);

            uint8_t max_num = 0, num = 0;

            int min = 160;
            int max = 200;
            // 对不同区域max min 修改,最好使用 “比例”，这样调好之后就不要过多干涉
            if (4 * i + j == 0) {

            }
            else if (4 * i + j == 1) {

            }
            else if (4 * i + j == 2) {

            }
            else if (4 * i + j == 3) {

            }
            else if (4 * i + j == 4) {

            }
            else if (4 * i + j == 5) {

            }
            else if (4 * i + j == 6) {

            }
            else if (4 * i + j == 7) {

            }


            for (int k = 160; k <= 200; k++) {
                int a_less, a_more;
                float p_less, p_more;
                int count_less = 0, count_more = 0;
                int sum_less = 0, sum_more = 0;
                for (int i = 0; i < k; i++) {
                    count_less += thre[i];
                    sum_less += thre[i] * i;
                }
                for (int i = k; i < 255; i++) {
                    count_more += thre[i];
                    sum_more += thre[i] * i;
                }
                p_less = (float)sum_less / (43 * 47);
                p_more = (float)sum_more / (43 * 47);
                if (count_less == 0 || count_more == 0) {
                    continue;
                }
                a_less = sum_less / (count_less);
                a_more = sum_more / (count_more);
                num = count_less * count_more * (a_less - a_more) * (a_less - a_more);
                if (num >= max_num) {
                    max_num = num;
                    my_threshold = k;
                }
            }
            if (my_threshold == 0) {
                my_threshold = threshold;
            }
            //////////////////////printf("thre:threshold=%d\n", my_threshold);
            thresholdAdapt[i * 4+j] = my_threshold;
//            ////////////////////printf("%d=%d\n", i * 4 + j, my_threshold);
        }
    }


}
////////////////////////////////////////////
//功能：阈值的确定
//输入：
//输出：
//备注：大津算法
///////////////////////////////////////////
void OTSU() {
    uint8_t* map;
        uint8_t* my_map;

        map = fullBuffer;
        uint8_t my_threshold = 0;
        uint8_t thre[256] = { 0 };
        double pthre[256] = { 0 };

        for (int i = 0; i < 86 * 188; i++) {
            thre[*(map)]++;
            map++;
        }
        for (int i = 0; i < 256; i++) {
            pthre[i] = (double)thre[i]/(86 * 188);
        }

        uint8_t min_thre, max_thre;
        for (min_thre = 0; thre[min_thre] == 0 && min_thre < 256;  min_thre++);
        for (max_thre = 255; thre[max_thre] == 0 && max_thre >= 0; max_thre--);
        double num = 0, max_num = 0;
        double p_sum_less = 0;
        double p_sum_more = 0;
        double m_Less = 0;
        double m_More = 0;
        double M_Less = 0;
        double M_More = 0;
        for (int i = min_thre; i <= max_thre; i++) {
            p_sum_more += pthre[i];
            m_More += i * pthre[i];
        }
        for (int k = min_thre; k <= max_thre; k++) {
            p_sum_less += pthre[k];
            p_sum_more -= pthre[k];
            m_Less += k * pthre[k];
            m_More -= k * pthre[k];
            M_Less = m_Less / p_sum_less;
            M_More = m_More / p_sum_more;
            num = p_sum_less * p_sum_more * (M_Less - M_More) * (M_Less - M_More);
            if (num > max_num) {
                max_num = num;
                threshold = k;
            }
        }
    //    if(lastThre==0){
    //           lastThre=threshold;
    //       }else{
    //           if(abs(threshold - lastThre) > 7){
    //               threshold=lastThre;
    //           }
    //       }

        uint8_t maxThre1 = maxThre, minThre1 = minThre;
        double upFix = part_klow1.floatVal, downFix = part_khigh1.floatVal;
        if (threshold > maxThre1) threshold = maxThre1;
        if (threshold < minThre1) threshold = minThre1;
        thresholdUp = threshold * upFix;
        thresholdDown = threshold * downFix;
    //  //////////////////printf("upthre=%d,downthre=%d\n", thresholdUp, thresholdDown);


}


uint8_t lastThreUp=0, lastThreDown = 0;
////////////////////////////////////////////
//功能：分区阈值的确定
//输入：
//输出：
//备注：大津算法
///////////////////////////////////////////
void part_OUST() {
        uint8_t* map;
        uint8_t* my_map;
        uint8_t min_thre = minThre, max_thre = maxThre;
        map = fullBuffer;
        uint8_t my_threshold = 0;
        uint8_t thre1[256] = { 0 };
        uint8_t thre2[256] = { 0 };
        double pthre1[256] = { 0 };
        double pthre2[256] = { 0 };
        uint8_t *pt1=thre1,*pt2=thre2;
        double *ppt1=pthre1,*ppt2=pthre2;

        double a;
        double b;
        double c;
        int threB=(max_thre + 25);
        int threA=min_thre;
        int threNewB=threB*1.1;
        int threNewA=threA*0.9;

        if(threNewB > 255) threNewB = 255;
        if(threNewA < 0) threNewA = 0;

        a = (double)threNewA / (double)threA;
        b = (double)(threNewB - threNewA) / (double)(threB - threA);
        c = (double)(255 - threNewB) / (double)(255 - threB);
        int newOne;



        for (int i = 0; i < 30; i++) {
            for(int j=0;j<188;j++){
//                if(40 <= j && j <= 156)   *(map)=(uint8_t)strenghen_contrast_ratio((int)*(map),(int)(min_thre),(int)((min_thre)*0.9),(int)(max_thre + 25),(int)((max_thre + 25)*1.1));

                          thre1[*map]++;
                           map++;
            }
//            if(i>15 * 188){
//                if (*(map) < threA) {
//                    *(map) = a * (*(map));
//                    if(*(map) <= 0) *(map)=0;
//                }
//                else if (threA <= *(map) && threB > *(map)) {
//                    *(map) = b * (*(map) -threA) + threNewA;
//                }
//                else if (threB <= *(map)) {
//                    *(map) = c * (int)(*(map) - threB) + threNewB;
//                    if (*(map) >= 255)  *(map) = 255;
//
//                }
           // }

        }

        for (int i = 30; i < 86; i++) {
            for(int j=0;j<188;j++){
//                if(i<=40 && 40 <= j && j <= 156)  *(map)=(uint8_t)strenghen_contrast_ratio((int)*(map),(int)(min_thre),(int)((min_thre)*0.9),(int)(max_thre + 25),(int)((max_thre + 25)*1.1));
                //            if(i<=40*188){
                //                if (*(map) < threA) {
                //                    *(map) = a * (*(map));
                //                    if(*(map) <= 0) *(map)=0;
                //                }
                //                else if (threA <= *(map) && threB > *(map)) {
                //                    *(map) = b * (*(map) -threA) + threNewA;
                //                }
                //                else if (threB <= *(map)) {
                //                    *(map) = c * (int)(*(map) - threB) + threNewB;
                //                    if (*(map) >= 255)  *(map) = 255;
                //
                //                }
                //            }



                            thre2[(*map)]++;
                            map++;
            }

        }
        for (int i = 0; i < 256; i++) {
            pthre1[i] = (double)(thre1[i]) / (30 * 188);
            pthre2[i] = (double)(thre2[i]) / (56 * 188);
        }
       // uint8_t min_thre = minThre, max_thre = maxThre;
        double numU = 0, max_numU = 0;
        double p_sum_lessU = 0;
        double p_sum_moreU = 0;
        double m_LessU = 0;
        double m_MoreU = 0;
        double M_LessU = 0;
        double M_MoreU = 0;

        double num = 0, max_num = 0;
        double p_sum_less = 0;
        double p_sum_more = 0;
        double m_Less = 0;
        double m_More = 0;
        double M_Less = 0;
        double M_More = 0;

        for (int i = 0; i < min_thre* part_klow1.floatVal - 1; i++) {
            p_sum_lessU +=  pthre1[i];
            m_LessU += i *pthre1[i];
        }
        for (int i = min_thre * part_klow1.floatVal - 1; i < 256; i++) {
            p_sum_moreU += pthre1[i];
            m_MoreU += i *pthre1[i];

        }
        for (int k = min_thre* part_klow1.floatVal; k <= max_thre* part_klow1.floatVal; k++) {
            p_sum_lessU += pthre1[k];
            m_LessU += k*pthre1[k];
            p_sum_moreU -= pthre1[k];
            m_MoreU -= k*pthre1[k];

            M_LessU = m_LessU / p_sum_lessU;
            M_MoreU = m_MoreU / p_sum_moreU;

            numU = p_sum_lessU * p_sum_moreU * (M_LessU - M_MoreU) * (M_LessU - M_MoreU);
            if (numU >= max_numU) {
                max_numU = numU;
                thresholdUp = k ;
            }

        }
        for (int i = 0; i < min_thre- 1; i++){
            p_sum_less += pthre2[i];
            m_Less += i *pthre2[i];
        }
        for (int i = min_thre - 1; i < 256; i++){
            p_sum_more += pthre2[i];
            m_More+=i*pthre2[i];
        }
        for(int k=min_thre;k<=max_thre;k++){
            p_sum_less += pthre2[k];
            m_Less += k *pthre2[k];
            p_sum_more -= pthre2[k];
            m_More -= k * pthre2[k];

            M_Less = m_Less / p_sum_less;
            M_More = m_More / p_sum_more;

            num = p_sum_less * p_sum_more * (M_Less - M_More) * (M_Less - M_More);
            if (num >= max_num) {
                max_num = num;
                thresholdDown = k;
            }
        }
        if(thresholdUp - lastThreUp > 7 && lastThreUp != 0){
            thresholdUp = lastThreUp + 7;
        }else if(thresholdUp - lastThreUp < -7 && lastThreUp != 0){
            thresholdUp = lastThreUp - 7;
        }
        if(thresholdUp>max_thre* part_klow1.floatVal) thresholdUp = max_thre* part_klow1.floatVal;
        if(thresholdUp<min_thre* part_klow1.floatVal) thresholdUp = min_thre* part_klow1.floatVal;

        lastThreUp = thresholdUp;


        if(thresholdDown - lastThreDown > 7 && lastThreDown != 0){
            thresholdDown = lastThreDown + 7;
        }else if(thresholdDown -  lastThreDown< -7 && lastThreDown != 0){
            thresholdDown = lastThreDown - 7;
        }
        if(thresholdDown>max_thre) thresholdDown = max_thre;
        if(thresholdDown<min_thre) thresholdDown = min_thre;
        lastThreDown = thresholdDown;


        //////////////////////printf("upthre=%d,downtgre=%d\n", thresholdUp, thresholdDown);



}

////////////////////////////////////////////
//功能：阈值的确定
//输入：
//输出：
//备注：迭代算法
///////////////////////////////////////////
void iteration() {
    uint8_t* map;
    map = fullBuffer;
    uint8_t threshold1 = 0;
    uint8_t threshold2 = 255;
    float threshold_origin = 0;
    uint8_t img_max = *(map), img_min = *(map);
    for (int i = 0; i < 188 * 120; i++) {
        if (*(map) >= img_max) {
            img_max = *(map);
        }
        else if (*(map) < img_min) {
            img_min = *(map);
        }
        map++;
    }
    threshold_origin = (img_max + img_min) / 2;

    float my_threshold = threshold_origin;

    do {
        threshold_origin = my_threshold;
        map = fullBuffer;
        float img_sum1 = 0, img_sum2 = 0;
        int img_num1 = 0, img_num2 = 0;
        for (int i = 0; i < 120; i++) {
            for (int j = 0; j < 188; j++) {
                if (*(map) >= threshold_origin) {
                    img_sum2 += *(map);
                    img_num2++;
                }
                else {
                    img_sum1 += *(map);
                    img_num1++;
                }
                map++;
            }
        }
        if (img_num1 == 0 || img_num2 == 0) {
            continue;
        }
        else {
            threshold1 = (float)img_sum1 / img_num1;
            threshold2 = (float)img_sum2 / img_num2;
            my_threshold = ((float)(threshold1 + threshold2)) / 2;
        }

    } while (threshold_origin - my_threshold != 0);
    threshold = threshold_origin;
}

////////////////////////////////////////////
//功能：去畸变
//输入：灰度图片
//输出：二值化图片
//备注：
///////////////////////////////////////////
void distortion() {
    uint8_t image_undis[CAMERA_H][CAMERA_W];
    uint8_t image_dis[CAMERA_H][CAMERA_W];

    for (int i = 0; i < 120; i++) {
        for (int j = 0; j < 188; j++) {
            image_dis[i][j] = *(fullBuffer);
            fullBuffer++;
        }
    }


    double fx = 61.5913;
    double fy = 62.0027;
    double u0 = 92.6154;
    double v0 = 63.9785;
    double k1 = -0.0147;
    double k2 = -0.0129;
    double k3 = 0;
    double p1 = -9.6308e-5;
    double p2 = 4.3509e-4;
    double cx = u0, cy = v0;

    for (int x = 0; x < 188; x++) {
        for (int y = 0; y < 120; y++) {
            double x_distorted = 0, y_distorted = 0;
            double x1, y1, x2, y2;
            x1 = (x - cx) / fx;
            y1 = (y - cy) / fy;
            double r2;
            r2 = pow(x1, 2) + pow(y1, 2);
            x2 = x1 * (1 + k1 * r2 + k2 * pow(r2, 2) + k3 * pow(r2, 3)) + 2 * p1 * x1 * y1 + p2 * (r2 + 2 * x1 * x1);
            y2 = y1 * (1 + k1 * r2 + k2 * pow(r2, 2) + k3 * pow(r2, 3)) + p1 * (r2 + 2 * y1 * y1) + 2 * p2 * x1 * y1;
            x_distorted = x2 * fx + cx;
            y_distorted = y2 * fy + cy;

            if (x_distorted >= 0 && y_distorted >= 0 && ((int)x_distorted) < 188 && ((int)y_distorted) < 120) {

                image_undis[y][x] = image_dis[(int)y_distorted][(int)x_distorted];
            }
            else {
                image_undis[y][x] = 0;
            }
        }
    }
    fullBuffer = &image_undis[0][0];

}

////////////////////////////////////////////
//功能：二值化
//输入：灰度图片
//输出：二值化图片
//备注：
///////////////////////////////////////////
void THRE(int num)
{
    if (num != 2) {
        uint8_t* map;
        uint8_t* my_map;
        uint8_t* my_map1;
        map = fullBuffer;

        for (int i = 0; i < 120; i++)
        {
            my_map = &IMG[i][0];
            for (int j = 0; j < 188; j++)
            {
                if ((*map) > threshold)
                    (*my_map) = white;
                else (*my_map) = black;
                map++;
                my_map++;
            }
        }
    }
    else if (num == 2) {
        uint8_t* map;
        uint8_t* my_map;
        uint8_t* my_map1;
        map = fullBuffer;

        for (int i = 0; i < 120; i++)
        {
            my_map = &IMG[i][0];
            if (i < 60) {
                threshold = thresholdUp;
            }
            else if (i >= 120) {
                threshold = thresholdDown;
            }
            for (int j = 0; j < 188; j++)
            {
                if ((*map) > threshold)
                    (*my_map) = white;
                else (*my_map) = black;
                map++;
                my_map++;
            }
        }
    }


}
int My_Max(signed int i, signed int j)
{
    if (i < j)
        return j;
    return i;
}
//取最小值
int My_Min(signed int i, signed int j)
{
    if (i > j)
        return j;
    return i;
}


void ZHAO_THRE()
{

    uint8_t* plineadd = NULL;
    uint8_t* pNextLine = NULL;
    uint8_t* pPreLine = NULL;
    uint8_t* map;
    uint8_t* my_map;
    map = fullBuffer;
    int Grads = 0, sumGrads = 0, sumGrayGrads = 0;

    for (uint8_t i = 1; i < 85; i++)
    {
        plineadd = map + (i * 188);
        pNextLine = map + (i + 1) * 188;
        pPreLine = map + (i - 1) * 188;
        for (uint8_t j = 1; j < 188; j++)
        {
            // 求 水 平 或 垂 直 方 向 的 最 大 梯 度
            Grads = My_Max(abs((int)pPreLine[j] - (int)pNextLine[j]), abs((int)plineadd[j - 1] - (int)plineadd[j + 1]));
            //max( xGrads , yGrads )
            sumGrads += Grads;
            // 梯 度 与 当 前 点 灰 度 的 积
            sumGrayGrads += Grads * ((int)plineadd[j]);
        }
    }
    threshold = sumGrayGrads / sumGrads + 7;

    //以下是使用固定阈值的切换，不用时注释掉
    //threshold = threshold_fix;

    /*for (int i = 0; i < 86; i++)
    {
        my_map = &img_original[i][0];
        for (int j = 0; j < 188; j++)
        {
            if ((*map) > threshold)
                (*my_map) = 1;
            else (*my_map) = 0;
            map++;
            my_map++;
        }
    }*/

}

////////////////////////////////////////////
//功能：逆透视变换 // 指针优化版
//输入：
//输出：
//备注：无
///////////////////////////////////////////
void IPM_map(void)
{
    double fix[CAMERA_H];
    uint8_t line_up = 30;
    uint8_t line_down = 90;
    double fix_up = 1.2;
    double fix_down = 0.9;
    for (int i = 0; i < 120; i++) {
        if (i <= line_up) {
            fix[i] = fix_up;
        }
        else if (line_up < i && i <= line_down) {
            fix[i] = (double)((fix_up - fix_down) / (double)(line_up - line_down)) * (double)(i - line_down) + fix_down;
        }
        else {
            fix[i] = fix_down;
        }
        //////////////printf("%d=%d\n", i, threOriginal * fix[i]);
    }
    int i;
    int j;
    uint8_t* pp = NULL;
    uint8_t* ss = NULL;
    pp = &left_side[0];
    ss = &right_side[0];
    uint8_t* str = NULL;
    uint8_t* ptr = NULL;
    str = &IMG[0][0];//变换后数组
    ptr = fullBuffer;//变换前数组
    uint8_t* pptr = NULL;
    uint8_t* sstr = NULL;
    pptr = &i_fix[0];
    sstr = &j_fix[0][0];
    int j_begin, j_end;
    uint8_t* tstr = NULL;
    uint8_t* tsstr = NULL;
    uint8_t* tptr = NULL;
    for (i = 0; i < CAMERA_H; i++)
    {
        j_begin = *(pp + i);
        j_end = *(ss + i);
        tstr = str + i * 188;
        tsstr = sstr + i * 188;
        tptr = ptr + *(pptr + i) * 188;
        for (j = 0; j < 188; j++)
        {
            if (j_begin <= j && j <= j_end) {
                *(tstr + j) = *(tptr + *(tsstr + j));
                if (*(tptr + *(tsstr + j)) > threOriginal * fix[i]) {
                    *(tstr + j) = white;
                }
                else {
                    *(tstr + j) = black;
                }
            }
            if (j<=left_side[i] || j>=right_side[i]) {
                *(tstr + j) = gray;
            }

        }
    }
}//map

////////////////////////////////////////////
//功能：粗犷的清车头
//输入：
//输出：
//备注：要根据自己车头的大小进行修改
///////////////////////////////////////////
void head_clear(void)
{
    uint8_t* my_map;
    for (int i = 113; i >= 110; i--)
    {
        my_map = &IMG[i][0];
        for (int j = 80; j <= 110; j++)
        {
            *(my_map + j) = white;
        }
    }
}

////////////////////////////////////////////
//功能：查找父节点
//输入：节点编号
//输出：最老祖先
//备注：含路径压缩
///////////////////////////////////////////
int find_f(int node)
{
    if (f[node] == node)return node;//找到最古老祖先，return
    f[node] = find_f(f[node]);//向上寻找自己的父节点
    return f[node];
}

////////////////////////////////////////////
//功能：提取跳变沿 并对全部白条子标号
//输入：IMG[120][188]
//输出：white_range[120]
//备注：指针提速
///////////////////////////////////////////
void search_white_range()
{
    uint8_t i, j;
    int istart = NEAR_LINE;//处理起始行
    int iend = FAR_LINE;//处理终止行
    int tnum = 0;//当前行白条数
    all_connect_num = 0;//白条编号初始化
    uint8_t* map = NULL;
    uint8_t* ptrLeftSide = &left_side[0];
    uint8_t* ptrRightSide = &right_side[0];
    for (i = istart; i >= iend; i--)
    {
        //map = &IMG[i][LEFT_SIDE];//指针行走加快访问速度
        map = &IMG[i][ptrLeftSide[i]];
        tnum = 0;
        for (j = ptrLeftSide[i]; j <= ptrRightSide[i]; j++, map++)//j为横坐标
        {
            if ((*map))//遇白条左边界
            {
                tnum++;
                if (tnum >= white_num_MAX)break;
                range* now_white = &white_range[i].area[tnum];
                now_white->left = j;

                //开始向后一个一个像素点找这个白条右边界
                map++;
                j++;

                while ((*map) && j <= ptrRightSide[i])
                {
                    map++;
                    j++;
                }
                now_white->right = j - 1;
                now_white->connect_num = ++all_connect_num;//白条数加一，给这个白条编号
            }
        }
        white_range[i].num = tnum;
    }
}

////////////////////////////////////////////
//功能：寻找白条子连通性，将全部联通白条子的节点编号刷成最古老祖先的节点编号
//输入：
//输出：
//备注：
///////////////////////////////////////////
void find_all_connect()
{
    //f数组初始化
    for (int i = 1; i <= all_connect_num; i++)
        f[i] = i;

    //u为up d为down 即为当前处理的这两行中的上面那行和下面那行
    //u_num：上面行白条数
    //u_left：上面行当前白条左边界
    //u_right：上面行当前白条右边界
    //i_u：当前处理的这个白条是当前这行（上面行）白条中的第i_u个
    int u_num, i_u, u_left, u_right;
    int d_num, i_d, d_left, d_right;
    all_range* u_white = NULL;
    all_range* d_white = NULL;
    for (int i = NEAR_LINE; i > FAR_LINE; i--)//因为每两行每两行比较 所以循环到FAR_LINE+1
    {
        u_num = white_range[i - 1].num;
        d_num = white_range[i].num;
        u_white = &white_range[i - 1];
        d_white = &white_range[i];
        i_u = 1; i_d = 1;

        //循环到当前行或上面行白条子数耗尽为止/-
        while (i_u <= u_num && i_d <= d_num)
        {
            //变量先保存，避免下面访问写的冗杂且访问效率低
            u_left = u_white->area[i_u].left;
            u_right = u_white->area[i_u].right;
            d_left = d_white->area[i_d].left;
            d_right = d_white->area[i_d].right;

            if (u_left <= d_right && u_right >= d_left)//如果两个白条联通
                f[find_f(u_white->area[i_u].connect_num)] = find_f(d_white->area[i_d].connect_num);//父节点连起来

            //当前算法规则，手推一下你就知道为啥这样了
            if (d_right > u_right)i_u++;
            if (d_right < u_right)i_d++;
            if (d_right == u_right) { i_u++; i_d++; }
        }
    }
}

////////////////////////////////////////////
//功能：寻找赛道
//输入：
//输出：
//备注：
///////////////////////////////////////////
void find_road()
{
    uint8_t istart = NEAR_LINE;
    uint8_t iend = FAR_LINE;
    top_road = NEAR_LINE;//赛道最高处所在行数，先初始化话为最低处
    int road_f = -1;//赛道所在连通域父节点编号，先初始化为-1，以判断是否找到赛道
    int while_range_num = 0, roud_while_range_num = 0;
    all_range* twhite_range = NULL;
    road* tmy_road = NULL;
    //寻找赛道所在连通域
    // 寻找最中心的白条子
    for (int i = 1; i <= white_range[istart].num; i++)
        if (white_range[istart].area[i].left <= CAMERA_W / 2
            && white_range[istart].area[i].right >= CAMERA_W / 2 && (white_range[istart].area[i].right - white_range[istart].area[i].left) >= 90)
            road_f = find_f(white_range[istart].area[i].connect_num);

    if (road_f == -1)//若赛道没在中间，在113行选一行最长的认为这就是赛道
    {
        int widthmax = 0, jselect = 1;
        for (int i = 1; i <= white_range[istart].num; i++)
            if (white_range[istart].area[i].right - white_range[istart].area[i].left > widthmax)
            {
                widthmax = white_range[istart].area[i].right - white_range[istart].area[i].left;
                jselect = i;
            }
        road_f = find_f(white_range[istart].area[jselect].connect_num);
    }

    //现在我们已经得到了赛道所在连通域父节点编号，接下来把所有父节点编号是road_f的所有白条子扔进赛道数组就行了
    for (int i = istart; i >= iend; i--)
    {
        //变量保存，避免之后写的冗杂且低效
        twhite_range = &white_range[i];
        tmy_road = &my_road[i];
        while_range_num = twhite_range->num;
        tmy_road->white_num = 0;
        roud_while_range_num = 0;
        for (int j = 1; j <= while_range_num; j++)
        {
            if (find_f(twhite_range->area[j].connect_num) == road_f)
            {
                top_road = i;
                tmy_road->white_num++; roud_while_range_num++;
                tmy_road->connected[roud_while_range_num].left = twhite_range->area[j].left;
                tmy_road->connected[roud_while_range_num].right = twhite_range->area[j].right;
                tmy_road->connected[roud_while_range_num].width = twhite_range->area[j].right - twhite_range->area[j].left;

            }
        }
    }
}

////////////////////////////////////////////
//功能：返回相连下一行白条子编号
//输入：i_start起始行  j_start白条标号
//输出：白条标号
//备注：认为下一行与本行赛道重叠部分对多的白条为选定赛道
///////////////////////////////////////////
uint8_t find_continue(uint8_t i_start, uint8_t j_start)
{
    uint8_t j_return;
    uint8_t j;
    uint8_t width_max = 0;
    uint8_t width_new = 0;
    uint8_t left = 0;
    uint8_t right = 0;
    uint8_t dright, dleft, uright, uleft;
    j_return = MISS;//如果没找到，输出255
    if (j_start > my_road[i_start].white_num)
        return MISS;
    //选一个重叠最大的
    for (j = 1; j <= my_road[i_start - 1].white_num; j++)
    {
        dleft = my_road[i_start].connected[j_start].left;
        dright = my_road[i_start].connected[j_start].right;
        uleft = my_road[i_start - 1].connected[j].left;
        uright = my_road[i_start - 1].connected[j].right;
        if (//相连
            dleft < uright
            &&
            dright > uleft
            )
        {
            //计算重叠大小
            if (dleft < uleft) left = uleft;
            else left = dleft;

            if (dright > uright) right = uright;
            else right = dright;

            width_new = right - left + 1;

            if (width_new > width_max)
            {
                width_max = width_new;
                j_return = j;
            }
        }

    }
    return j_return;
}

////////////////////////////////////////////
//功能：通用决定双边（找连通路径）
//输入：
//输出：
//备注：
///////////////////////////////////////////
void ordinary_two_line(void)
{
    uint8_t i;
    uint8_t j;
    //uint8_t j_continue[CAMERA_H];//第一条连通路径
    uint8_t i_start;
    uint8_t i_end;
    uint8_t j_start = MISS;
    int width_max;

    //寻找起始行最宽的白条子
    i_start = NEAR_LINE;
    i_end = FAR_LINE;
    width_max = 0;

    for (j = 1; j <= my_road[i_start].white_num; j++)
    {
        ////////////////////////////////////////////////////////////////////////////printf("n=%d", my_road[j].white_num);
        if (my_road[i_start].connected[j].width > width_max)
        {
            width_max = my_road[i_start].connected[j].width;
            j_start = j;
        }
    }
    j_continue[i_start] = j_start;

    //记录连贯区域编号
    for (i = i_start; i > i_end; i--)
    {
        //如果相连编号大于该行白条数，非正常，从此之后都MISS
        if (j_continue[i] > my_road[i].white_num)
        {
            j_continue[i - 1] = MISS;
        }
        else
        {
            j_continue[i - 1] = find_continue(i, j_continue[i]);
        }

    }

    //全部初始化为MISS
    my_memset(left_line, MISS, CAMERA_H);
    my_memset(right_line, MISS, CAMERA_H);


    for (i = i_start; i > i_end; i--)
    {
        if (j_continue[i] <= my_road[i].white_num)
        {

            right_line[i] = my_road[i].connected[j_continue[i]].right;
            left_line[i] = my_road[i].connected[j_continue[i]].left;
            /*IMG[i][left_line[i]] = blue;
            IMG[i][right_line[i]] = red;*/
        }
        else
        {
            left_line[i] = MISS;
            right_line[i] = MISS;
        }
    }
}

////////////////////////////////////////////
//功能：通用决定双边
//输入：
//输出：
//备注：历史寻路法
///////////////////////////////////////////
void orinary_two_line_history() {
    uint8_t i;
    uint8_t j;
    //uint8_t j_continue[CAMERA_H];//第一条连通路径
    uint8_t i_start;
    uint8_t i_end;
    uint8_t j_start = MISS;
    int width_max;


    //寻找起始行最宽的白条子
    i_start = NEAR_LINE;
    i_end = FAR_LINE;
    width_max = 0;

    for (j = 1; j <= my_road[i_start].white_num; j++)
    {
        if (my_road[i_start].connected[j].width > width_max)
        {
            width_max = my_road[i_start].connected[j].width;
            j_start = j;
        }
    }
    j_continue[i_start] = j_start;

    for (int i = i_start; i > i_end; i--) {
        uint8_t midComb[100];
        uint8_t min = 1;
        int flag = 0;
        if (mid_line[i] == 0) {
            mid_line[i] = 94;
        }
        ////////////////////////////////////////////////////////////////printf("%d=%d\n", i, mid_line[i]);
        for (int j = 1; j <= my_road[i].white_num; j++) {
            midComb[j] = (my_road[i].connected[j].left + my_road[i].connected[j].right) / 2;

            if (my_road[i].connected[j].width < 10) {
                continue;
            }
            else {
                if (abs(mid_line[i] - midComb[min]) >= abs(mid_line[i] - midComb[j])) {
                    min = j;
                    flag = 1;
                }
            }

        }
        j_continue[i] = min;
        ////////////////////////////////////////////////////////////////printf("j=%d", j_continue[i]);
    }

    //记录连贯区域编号
    /*for (i = i_start; i > i_end; i--)
    {
        //如果相连编号大于该行白条数，非正常，从此之后都MISS
        if (j_continue[i] > my_road[i].white_num)
        {
            j_continue[i - 1] = MISS;
        }
        else
        {
            j_continue[i - 1] = find_continue(i, j_continue[i]);
        }

    }*/

    //全部初始化为MISS
    my_memset(left_line, MISS, CAMERA_H);
    my_memset(right_line, MISS, CAMERA_H);


    for (i = i_start; i > i_end; i--)
    {
        if (j_continue[i] <= my_road[i].white_num)
        {

            right_line[i] = my_road[i].connected[j_continue[i]].right;
            left_line[i] = my_road[i].connected[j_continue[i]].left;
        }
        else
        {
            left_line[i] = MISS;
            right_line[i] = MISS;
        }
    }
}

////////////////////////////////////////////
//功能：数组初始化
//输入：uint8_t* ptr 数组首地址, uint8_t num初始化的值, uint8_t size数组大小
//输出：
//备注：因为k66库中认为memset函数不安全，所以无法使用；因此需要自己写一个my_memset
///////////////////////////////////////////
void my_memset(uint8_t* ptr, uint8_t num, uint8_t size)
{
    uint8_t* p = ptr;
    uint8_t my_num = num;
    uint8_t Size = size;
    for (int i = 0; i < Size; i++, p++)
    {
        *p = my_num;
    }
}

////////////////////////////////////////////
//功能：中线合成
//输入：左右边界
//输出：中线
//备注：
///////////////////////////////////////////
void get_mid_line(void)
{
    my_memset(mid_line, MISS, CAMERA_H);
        for (int i = NEAR_LINE; i >= FAR_LINE; i--) {
            if (left_line[i] != MISS && my_road[i].white_num!=0)
            {
                mid_line[i] = (left_line[i] + right_line[i]) / 2;
            }
            else
            {

                mid_line[i] = mid_line[i + 1];
            }
           // last_mid_line[i] = mid_line[i];
        }
//    my_memset(mid_line, MISS, CAMERA_H);
//
//    for (int i = NEAR_LINE; i >= FAR_LINE; i--){
//        if (left_line[i] != MISS && my_road[i].white_num!=0)
//        {
//            mid_line[i] = (left_line[i] + right_line[i]) / 2;
//        }
//        else if (left_line[i] == MISS && state != stateRampway)
//        {
//
//            mid_line[i] = mid_line[i + 1];
//        }
//        else if(left_line[i] == MISS && state == stateRampway)
//        {
//            int way=1;
//            if(way == 1){
//                mid_line[i] = 92;
//            }else if(way == 2){
//                if(my_road[i].white_num!=0){
//                    mid_line[i]=(my_road[i].connected[1].left+my_road[i].connected[1].right)/2;
//                    for(int j=1;j<=my_road[i].white_num;j++){
//                        if(abs((my_road[i].connected[j].left+my_road[i].connected[j].right)/2-92)<abs(mid_line[i]-92)){
//                            mid_line[i]=(my_road[i].connected[j].left+my_road[i].connected[j].right)/2;
//                        }
//                    }
//                }else{
//                    mid_line[i] = mid_line[i + 1];
//                }
//
//            }
//
//        }
//        last_mid_line[i] = mid_line[i];
//    }


}
////////////////////////////////////////////
//功能：增强对比度
//输入：像素值，对比度节点
//输出：像素值
//备注：
///////////////////////////////////////////
int strenghen_contrast_ratio(int oldThre,int threA, int threNewA, int threB, int threNewB) {

    double a;
    double b;
    double c;

    if(threNewB > 255) threNewB = 255;
    if(threNewA < 0) threNewA = 0;
    a = (double)threNewA / (double)threA;
    b = (double)(threNewB - threNewA) / (double)(threB - threA);
    c = (double)(255 - threNewB) / (double)(255 - threB);
    int newOne;

    if (oldThre < threA) {
        newOne = a * oldThre;
        if(newOne <= 0) newOne=0;
    }
    else if (threA <= oldThre && threB > oldThre) {
        newOne = b * (oldThre -threA) + threNewA;
    }
    else if (threB <= oldThre) {
        newOne = c * (int)(oldThre - threB) + threNewB;
        if (newOne >= 255)  newOne = 255;

    }

    return newOne;

}
////////////////////////////////////////////
//功能：图像处理主程序
//输入：
//输出：
//备注：
///////////////////////////////////////////
void image_main()
{
    threshold = presentTHRE.intVal;
    int wayThreshold = wayThre.intVal;
    protection();
//    strenghen_contrast_ratio();
//    uint64 tim1 = 0, tim2 = 0;


//    tim1 = Systick_Get(STM0)/100000;
    switch (wayThreshold) {
    case 0:break;
    case 1:OTSU();
        break;
    case 2:part_OUST();
        break;
    case 3:image_Preprocess();
        break;
    case 4:ZHAO_THRE();
        break;
    case 5:iteration();
        break;
    }

//    tim2 = Systick_Get(STM0)/100000;
//    test_varible[14] = (float)(tim1);
//    test_varible[15] = (float)(tim2);
    //distortion();
    //THRE(wayThreshold);
    IPM_map();
    //decide_miss();
//    head_clear();
   // transform(wayThreshold);


//
//    transform_sd(wayThreshold);

    //



    search_white_range();
    find_all_connect();
    find_road();
    /*到此处为止 我们已经得到了属于赛道的结构体数组my_road[CAMERA_H]*/
    ordinary_two_line();

    if(parkStart == 0 && parkStart != 3)
    {
        judge_type_road();

    }

    test_varible[13]=state;

    for (int i = NEAR_LINE; i > FAR_LINE; i--)
    {

        IMG[i][left_line[i]] = red;
        IMG[i][right_line[i]] = blue;
    }
    get_mid_line();
    mid_line_filter();
    averMidLine = mid_aver(2);
//    test_varible[15] = valid_row();
//    for (int )
    for (int i = NEAR_LINE; i >= FAR_LINE; i--)
        if (mid_line[i] != MISS)
            IMG[i][mid_line[i]] = green;

   // IMG[74][mid_line[74]] = purple;
}

////////////////////////////////////////////
//功能：道路类型判断
//输入：
//输出：
//备注：初判断应该会出现很多混淆，之后会进行类似元素的单独判断
///////////////////////////////////////////
void judge_type_road() {
//    state = 110;
//    islandWhere = LEFT;
    leftUpJumpPoint = 119;
    leftDownJumpPoint = 119;
    rightUpJumpPoint = 119;
    rightDownJumpPoint = 119;
    int flagChange = 0;

    if(state != lastState)
    {
        lastState = state;
        integerSpeedCNT += (integerSpeedR - integerSpeedL) / 2;
//        test_varible[14] = integerSpeedCNT;
        integerSpeedL = 0;
        integerSpeedR = 0;
    }

    CTRL_encoderCount();

//    CCD();

    //十字
    if (state == stateStart && flagChange == 0) {
        cross_in();
        if (my_road[40].white_num != 0)
            folk_road_in();
//            folkTimesCNT();
//            test_varible[6] = folkCNT;

        T_island_in_start();
        if (lastState != state) {
            flagChange = 1;
        }

    }

    if (state == stateCrossIn && flagChange == 0) {
        cross_over();
        if (lastState != state) {
            flagChange = 1;
        }

    }
    if (state == stateFolkRoadIn && flagChange == 0) {
        folk_road_out();
        if (lastState != state) {
            flagChange = 1;
        }

    }
    if (state == stateTIslandIn && flagChange == 0) {
        T_or_island();
     //   island_radius();
        if (lastState != state) {
            flagChange = 1;
        }

    }
    if (state == stateSTIsland && flagChange == 0) {
        straightT_or_island();
//            island_radius();
            if (lastState != state) {
                flagChange = 1;
            }

        }

    if (state == stateIslandIng && (flagChange == 0 || state == stateSTIsland)) {
        island_turn();
        if (lastState != state) {
            flagChange = 1;
        }

    }
    if (state == stateIslandTurn && flagChange == 0) {
        island_circle();
        if (lastState != state) {
            flagChange = 1;
        }

    }
    if (state == stateIslandCircle && flagChange == 0) {

        islandCircleCount += 1;
        if(islandCircleCount >= 4)
        {
            island_out();

        }
        if (lastState != state) {
            flagChange = 1;
        }

    }
    if (state == stateIslandOut && flagChange == 0) {
        island_straight();
        if (lastState != state) {
            flagChange = 1;
        }

    }
    if (state == stateIslandFinal && flagChange == 0) {
        island_final();
        if (lastState != state) {
            flagChange = 1;
        }

    }
    if (state == stateTIn && flagChange == 0) {
//        TcircleFix();
        cross_T_out_start();
        if (lastState != state) {
            flagChange = 1;
        }


    }
    if (state == stateTOut && flagChange == 0) {
        cross_T_out_over();
        if (lastState != state) {
            flagChange = 1;
        }

    }

//    carPark_main();

    if (lastState == 30 && state == 70) {
        islandTimes++;
    }
//    test_varible[14] = islandTimes;
    if (islandTimes == 1) {
        if(smallIsland.intVal == 1 && bigIsland.intVal == 2)
        {
            IslandRadius = islandParam6.intVal;
        }
        else if(smallIsland.intVal == 2 && bigIsland.intVal == 1)
        {
            IslandRadius = bigParam8.intVal;

        }
//        IslandRadius = 80;
//        IslandRadius = islandParam6.intVal;
    }
    else if (islandTimes == 2) {
        if(smallIsland.intVal == 1 && bigIsland.intVal == 2)
        {
            IslandRadius = bigParam8.intVal;
        }
        else if(smallIsland.intVal == 2 && bigIsland.intVal == 1)
        {
            IslandRadius = islandParam6.intVal;

        }
//        IslandRadius = 50;
//        IslandRadius = islandParam6.intVal;
    }
    else if(islandTimes == 3) { //对于往返赛道
        if(smallIsland.intVal == 1 && bigIsland.intVal == 2)
        {
            IslandRadius = bigParam8.intVal;
        }
        else if(smallIsland.intVal == 2 && bigIsland.intVal == 1)
        {
            IslandRadius = islandParam6.intVal;

        }
//        IslandRadius = islandParam6.intVal;
//        IslandRadius = 100;
    }
    else if (islandTimes == 4) {
        if(smallIsland.intVal == 1 && bigIsland.intVal == 2)
        {
            IslandRadius = islandParam6.intVal;
        }
        else if(smallIsland.intVal == 2 && bigIsland.intVal == 1)
        {
            IslandRadius = bigParam8.intVal;

        }
//        IslandRadius = islandParam6.intVal;
//        IslandRadius = 50;

    }

//        else if (islandTimes == 5) {
//            IslandRadius;
//        }
//        else if (islandTimes == 6) {
//            IslandRadius;
//        }

    if(lastState == 60 && state == 40){
        islandTimes--;
    }

    if(state == 50 && lastState == 40)
    {
        tCrossTimes += 1;
    }


//    if(file1.intVal == 1)
//    {
//        if(state == 0 && lastState == 20)
//        {
//            folkTimes += 1;
//        }
//        if(folkTimes >= 4)
//        {
//            leftPark = 0;
//            rightPark = 1;
////            searchParkLine();
//        }
//    }
//
//    else if(file1.intVal == -1)
//    {
//        if(lastState == 50)
//        {
//            tCrossTimes += 1;
//        }
//
//        if(tCrossTimes >= 2)
//        {
//            leftPark = 1;
//            rightPark = 0;
////            searchParkLine();
//        }
//    }
//    searchParkLine();
//    test_varible[15] = folkTimes;
//    test_varible[14] = lastState;
    //补线
    if (state == stateCrossIn) {
        design_cross_ing();

    }
    if (state == stateFolkRoadIn) {
        design_folk_road();
    }
    if (state == stateTIslandIn || state == stateSTIsland) {
        design_T_island_in();
        tInCount = 0;

    }
    if (state == stateIslandIng) {
        design_island_ing();
    }
    if (state == stateIslandTurn) {
        design_island_turn();
    }
    if (state == stateIslandCircle) {
//        design_island_circle();
//        roof();
    }
    if (state == stateIslandOut) {
        design_island_out();
    }
    if (state == stateIslandFinal) {
        design_island_straight();
    }
    if (state == stateTIn) {
        design_cross_T_circle();
        roof();
    }
    if (state == stateTOut) {
        design_cross_T_out();
    }


//    test_varible[4] = integerSpeedAver;

    if(state == stateStart)
    {
        if(integerSpeedAver > 3000)
        {
            rampwayOn();

        }

        lastTwoState = 0;
        rampWayCount = 0;
        //        lastRampGyro = 0;
        //        rampGyro = 0;
        //        rampGyroMax = 0;
    }

    if(state == stateRampway)
    {
        GPIO_Set(P22, 0, 1);
        rampWayCount += 1;
        rampwayDown();

        if(rampWayCount > rampCount.intVal)
        {

//            state = 0;
//            afterRampFlag = 1;
            rampWayCount=0;
        }

        if(state == 0)
        {
            afterRampFlag = 1;
        }
    }

    else if(state != stateRampway)
    {
//        GPIO_Set(P22, 0, 0);
        rampWayCount = 0;
    }

    if(afterRampFlag == 1)
    {

        if(integerSpeedAver > 3000)
        {
            afterRampFlag = 0;
        }
    }

    if(state != stateRampway && state != stateParkIn){
//        TcircleFix();
        rampJudgeCount += 1;
    }

    if(state != stateRampway)
    {
        straight_define();

//        test_varible[14] = straightFlag;
    }
    test_varible[4] = longStrFlag;
    test_varible[5] = shortStrFlag;
//    roadMemory();
//    if(sRoadFlag == 0)
//    {
//        small_s_road();
//        sRoadCount = 0;
//    }
//    else if(sRoadFlag == 1)
//    {
//        big_mid_line_filter();
//        sRoadCount += 1;
//        if(sRoadCount >= 80)
//        {
//            sRoadFlag = 0;
//        }
//    }
//    test_varible[14] = sRoadFlag;
//    if(folkTimes == 1 || folkTimes == 3)
//    {
//        big_mid_line_filter();
//    }

    //关于想区分环岛与T字路口的想法失败
    //因此不得不再次尝试共用状态
    if (state != 30 && state != 40 && state != 50 && state != 60 && state != 70 && state != 80 && state != 90 && state != 100 && state != 110 ) {
        TIslandWhere = 0;
        islandWhere = 0;
        TWhere = 0;
    }
    if (state != 30 && state != 70 && state != 80 && state != 90 && state != 100 && state != 110) {
        midDownDistance = 0;
        midTimes = 0;
    }



//    if (state == 10 || state == 20 ) {
//        forceOut++;
//        if (state == 10 || state == 20) {
//            if (forceOut >= 50) {
//                state = 0;
//                forceOut = 0;
//            }
//        }
////        if (state == 50 || state == 110) {
////            if (forceOut >= 50) {
////                state = 0;
////                forceOut = 0;
////            }
////        }
//    }
//    else {
//        forceOut = 0;
//    }
    if(state != 80){
        lastUpPoint = 0;
    }

    if(state != lastState){
        Loud=0;
        Loud++;
    }else if(Loud !=0){
        Loud++;
    }

    if(Loud > 0 && Loud <= 5){
        GPIO_Set(P22,0,1);
    }else{
        GPIO_Set(P22,0,0);
        Loud=0;
    }


}

////////////////////////////////////////////
//功能：斜率计算
//输入：起点，终点，起点,终点所在数组
//输出：斜率
//备注：最小二乘法
///////////////////////////////////////////
double calculate_slope(int start, int end, int side[CAMERA_H]) {
    double ySum = 0;
    double y2Sum = 0;
    double xSum = 0;
    double xySum = 0;

    if (end >= NEAR_LINE) {
        end = NEAR_LINE - 1;
    }
    if (start <= 0) {
        start = 0;
    }
    int num = end - start + 1;
    for (int i = start; i <= end; i++) {
        xSum += side[i];
        ySum += i;
        y2Sum += i * i;
        xySum += i * side[i];
    }
    if ((num * y2Sum - ySum * ySum) != 0) {

        double Slope = (double)(num * xySum - xSum * ySum) / (num * y2Sum - ySum * ySum);
        return Slope;
    }
    else {
        return 0;
    }
}

////////////////////////////////////////////
//功能：斜率计算
//输入：起点，终点，起点,终点所在数组
//输出：斜率
//备注：最小二乘法
///////////////////////////////////////////
double calculate_slope_uint(int start, int end, uint8_t side[CAMERA_H]) {
    double ySum = 0;
    double y2Sum = 0;
    double xSum = 0;
    double xySum = 0;

    if (end >= NEAR_LINE) {
        end = NEAR_LINE;
    }
    if (start <= 0) {
        start = 0;
    }
    int num = end - start + 1;
    for (int i = start; i <= end; i++) {
        xSum += side[i];
        ySum += i;
        y2Sum += i * i;
        xySum += i * side[i];
    }
    if ((num * y2Sum - ySum * ySum) != 0) {

        double Slope = (double)(num * xySum - xSum * ySum) / (num * y2Sum - ySum * ySum);
        return Slope;
    }
    else {
        return 0;
    }
}

////////////////////////////////////////////
//功能：斜率计算
//输入：起点，终点，起点,终点所在数组
//输出：斜率
//备注：最小二乘法
///////////////////////////////////////////
double calculate_slope_struct(int start, int end, uint8_t j_mid[CAMERA_H],int type) {
    double ySum = 0;
    double y2Sum = 0;
    double xSum = 0;
    double xySum = 0;

    if (end >= NEAR_LINE) {
        end = NEAR_LINE;
    }
    if (start <= 1) {
        start = 1;
    }
    int num = end - start + 1;

    uint8_t side[CAMERA_H];

    if (type == LEFT) {
        for (int i = end; i >= start; i--) {
            side[i] = my_road[i].connected[j_mid[i]].left;
        }
    }
    else if (type == RIGHT) {
        for (int i = end; i >= start; i--) {
            side[i] = my_road[i].connected[j_mid[i]].right;
        }
    }

    for (int i = start; i <= end; i++) {
        xSum += side[i];
        ySum += i;
        y2Sum += i * i;
        xySum += i * side[i];
    }
    if ((num * y2Sum - ySum * ySum) != 0) {

        double Slope = (double)(num * xySum - xSum * ySum) / (num * y2Sum - ySum * ySum);
        return Slope;
    }
    else {
        return 0;
    }
}

////////////////////////////////////////////
//功能：斜率计算
//输入：起点，终点，起点,终点横坐标
//输出：斜率
//备注：两点式
///////////////////////////////////////////
double calculate_two_point_slope(int start, int xStart, int end, int xEnd) {

    double k = (double)(xStart - xEnd) / (start - end);
    return k;

}

////////////////////////////////////////////
//功能：方差
//输入：
//输出：
//备注：
///////////////////////////////////////////
double variance(int yStart, int yEnd, int side[CAMERA_H]) {

    int xSum = 0;
    int ySum = 0;
    int x[CAMERA_H];
    double xAverange = 0;
    double x2Delta = 0;
    double D;

    for (int i = yStart; i <= yEnd; i++) {
        xSum += side[i];
    }

    xAverange = (double)xSum / (yEnd - yStart + 1);

    for (int i = yStart; i < yEnd; i++) {
        x2Delta += (side[i] - xAverange) * (side[i] - xAverange);
    }

    D = x2Delta / (yEnd - yStart);
    return D;
}

////////////////////////////////////////////
//功能：相关系数
//输入：
//输出：
//备注：
///////////////////////////////////////////
double correlation_coefficient(int start, int end, int side[CAMERA_W]) {
    int xSum = 0;
    int ySum = 0;
    for (int i = start; i <= end; i++) {
        xSum += i;
        ySum += side[i];
    }
    double xAver = (double)xSum / (end - start + 1);
    double yAver = (double)ySum / (end - start + 1);

    double xy = 0;
    double x2 = 0;
    double y2 = 0;
    for (int i = start; i <= end; i++) {
        xy += (double)(i - xAver) * (side[i] - yAver);
        x2 += (double)(i - xAver) * (i - xAver);
        y2 += (double)(side[i] - yAver) * (side[i] - yAver);
    }
    if (x2 != 0 && y2 != 0) {
        double r = xy / (sqrt(x2) * sqrt(y2));
        return r;
    }
    else {
        return 2;
    }


}

////////////////////////////////////////////
//功能：余弦值
//输入：
//输出：
//备注：
///////////////////////////////////////////
double cos_angle(int x1, int x2, int x3, int y1, int y2, int y3) {

    ////////////////////////余弦函数计算
    double l1 = sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
    double l2 = sqrt((x2 - x3) * (x2 - x3) + (y2 - y3) * (y2 - y3));
    double l3 = sqrt((x1 - x3) * (x1 - x3) + (y1 - y3) * (y1 - y3));

    if (x3 > NEAR_LINE) {
        x3 = NEAR_LINE;
    }
    if (x1 <= 1) {
        x1 = 1;
    }
    double cosA;
    if (l1 != 0 && l2 != 0) {
        cosA = (double)(l1 * l1 + l2 * l2 - l3 * l3) / (2 * l1 * l2);
    }
    else {
        if (l1 * l1 + l2 * l2 - l3 * l3 > 0) {
            cosA = 2;
        }
        else {
            cosA = -2;
        }
    }


    return cosA;

    ////////////////////////
}

////////////////////////////////////////////
//功能：线性判断
//输入：
//输出：
//备注：
///////////////////////////////////////////
double linear_judgement(int start, int end, uint8_t side[CAMERA_H]) {

    if(start<=1) start=1;
    if(end>=NEAR_LINE)end=NEAR_LINE;
    //先拟合直线
    double k = calculate_slope_uint(start, end, side);

    int xSum = 0;
    int ySum = 0;
    for (int i = start; i <= end; i++) {
        xSum += side[i];
        ySum += i;
    }
    double xAve = (double)xSum / (end - start + 1);
    double yAve = (double)ySum / (end - start + 1);

    double b = xAve - k * yAve;
//    //////////////////printf("k=%f,b=%f\n", k, b);
    int difference[CAMERA_H] = { 0 };
    int sumA = 0;
    for (int i = start; i <= end; i++) {
        difference[i] = ((int)side[i] - (int)(k * i + b));
        sumA += difference[i];
//        //////////////////printf("dx:%d=%d-%d=%d,%d\n", i, side[i], (int)(k * i + b),difference[i],sumA);
    }
    double ave = (double)sumA / (end - start + 1);
//    //////////////////printf("sum=%d,ave=%f\n",sumA, ave);
    double dv = 0;
    for (int i = start; i <= end; i++) {
        dv += (difference[i] - ave) * (difference[i] - ave);
    }
    return dv;

}


////////////////////////////////////////////
//功能：线性判断
//输入：
//输出：
//备注：
///////////////////////////////////////////
double linear_judgement_struct(int start, int end, uint8_t j[CAMERA_H],int direction) {
    if(start<=1) start=1;
    if(end>=NEAR_LINE) end=NEAR_LINE;
    uint8_t side[CAMERA_H];
    for (int i = start; i <= end; i++) {
        if (direction == LEFT)side[i] = my_road[i].connected[j[i]].left;
        else if (direction == RIGHT)side[i] = my_road[i].connected[j[i]].right;
    }


    //先拟合直线
    double k = calculate_slope_uint(start, end, side);

    int xSum = 0;
    int ySum = 0;
    for (int i = start; i <= end; i++) {
        xSum += side[i];
        ySum += i;
    }
    double xAve = (double)xSum / (end - start + 1);
    double yAve = (double)ySum / (end - start + 1);

    double b = xAve - k * yAve;
    //////////////printf("k=%f,b=%f\n", k, b);
    int difference[CAMERA_H] = { 0 };
    int sumA = 0;
    for (int i = start; i <= end; i++) {
        difference[i] = ((int)side[i] - (int)(k * i + b));
        sumA += difference[i];
        //////////////printf("dx:%d=%d-%d=%d,%d\n", i, side[i], (int)(k * i + b),difference[i],sumA);
    }
    double ave = (double)sumA / (end - start + 1);
    //////////////printf("sum=%d,ave=%f\n",sumA, ave);
    double dv = 0;
    for (int i = start; i <= end; i++) {
        dv += (difference[i] - ave) * (difference[i] - ave);
    }
    return dv;

}


///////////////////////////////////////////
//功能：模拟CCD获取新的赛道数据
//输入：
//输出：
//备注：
///////////////////////////////////////////
void CCD() {
//    uint8_t* map;
//    map = fullBuffer;
//    uint8_t j_num = 1;
//    //再一次得到全新的二值化结果
//    my_road[35] = my_road[95];
//    for (int i = 34; i >= 0; i--) {
//        for (int j = 0; j < 188; j++) {
//            if(188 * transform_x[i + 60][j] < 30){
//                if (*(map + 188 * transform_x[i + 60][j] + transform_y[i + 60][j]) > thresholdUp *1.2) {
//                    IMG[i][j] = white;
//                }
//                else {
//                    IMG[i][j] = black;
//                }
//                if (j<left_side[i + 60] || j>right_side[i + 60]) {
//                    IMG[i][j] = black;
//                }
//            }
//            else {
//                if (*(map + 188 * transform_x[i + 60][j] + transform_y[i + 60][j]) > thresholdDown *1.2) {
//                    IMG[i][j] = white;
//                }
//                else {
//                    IMG[i][j] = black;
//                }
//                if (j<left_side[i + 60] || j>right_side[i + 60]) {
//                    IMG[i][j] = black;
//                }
//
//            }
//        //  ////////////////printf("%d*%d:%d-%d\n", i + 25, j, IMG[i + 24][j], IMG_zebra[i][j]);
//        }
//        uint8_t* white_road = &IMG[i][0];
//        int flag = 0;
//        int start_white, end_white;
//        //这里寻找连通域，找到所有赛道
//        for (int j = left_side[i + 60]; j < right_side[i + 60]; j++) {
//            if (*(white_road + j) == white && *(white_road + j - 1) == black && flag == 0) {
//                start_white = j;
//                flag = 1;
//            }
//            if (*(white_road + j) == white && *(white_road + j + 1) == black && flag == 1) {
//                end_white = j;
//                for (int k = 1; k <= my_road[i + 1].white_num; k++) {
//                    if ((my_road[i + 1].connected[k].left <= start_white && start_white < my_road[i + 1].connected[k].right) || (my_road[i + 1].connected[k].left < end_white && end_white <= my_road[i + 1].connected[k].right)
//                        || (my_road[i + 1].connected[k].left >= start_white && end_white >= my_road[i + 1].connected[k].right) || (my_road[i + 1].connected[k].left <= start_white && end_white <= my_road[i + 1].connected[k].right)) {
//                        my_road[i].connected[j_num].left = start_white;
//                        my_road[i].connected[j_num].right = end_white;
//                        //IMG[i + 60][my_road[i].connected[j_num].left] = red, IMG[i  +60][my_road[i].connected[j_num].right] = blue;
//                        my_road[i].connected[j_num].width = end_white - start_white + 1;
//                        j_num++;
//                        flag = 0;
//                        break;
//                    }
//                }
//            }
//
//        }
//        my_road[i].white_num = j_num - 1;
//        j_num = 1;
//
//    }

}


////////////////////////////////////////////
//功能：进十字
//输入：
//输出：
//备注：
///////////////////////////////////////////
void cross_in() {
    leftUpJumpPoint = 119;
    leftDownJumpPoint = 119;
    rightUpJumpPoint = 119;
    rightDownJumpPoint = 119;

    //只有同时看到四个点我们才确定是十字
    //我们认为下方点到100行之前就必须识别上，不然就晚了
    //寻找正确的上方赛道
    ////////printf("\n十字开始识别：\n");
    int mid[CAMERA_H];
    for (int i = NEAR_LINE; i >= 100; i--) {
        mid[i] = (left_line[i] + right_line[i]) / 2;
    }

    double kMid = calculate_slope(100, NEAR_LINE - 1, mid);
    int direction;
    double kRange = 0.2;
    if (fabs(kMid) <= kRange) {
        direction = 0;
    }
    else if (kMid > kRange) {
        direction = LEFT;
    }
    else if (kMid < -1 * kRange) {
        direction = RIGHT;
    }

    for (int i = 99; i >= 1; i--) {
        mid[i] = kMid * (i - 100) + mid[100];
    //  IMG[i][mid[i]] = purple;
    }

    uint8_t j_mid[CAMERA_H];

    for (int i = NEAR_LINE; i >= 1; i--) {
        j_mid[i] = j_continue[i];
        for (int j = 1; j <= my_road[i].white_num; j++) {
            if (abs((my_road[i].connected[j].left + my_road[i].connected[j].right) / 2 - mid[i]) < abs((my_road[i].connected[j_mid[i]].left + my_road[i].connected[j_mid[i]].right) / 2 - mid[i])
                && my_road[i].connected[j].width > 10) {
                j_mid[i] = j;
            }
        }
         //////////printf("%d:l=%d,r=%d\n", i, my_road[i].connected[j_mid[i]].left, my_road[i].connected[j_mid[i]].width);
    }
    uint8_t jumpLine = 119;
    for (int i = 113; i >= 30; i--) {
        if (my_road[i - 2].connected[j_mid[i - 2]].width - my_road[i].connected[j_mid[i]].width >= 6
            && abs(my_road[i + 1].connected[j_mid[i + 1]].width - my_road[i].connected[j_mid[i]].width) <= 4
            && my_road[i].connected[j_mid[i]].width <= 65
            && my_road[i].connected[j_mid[i]].right < right_side[i] - 2 && my_road[i].connected[j_mid[i]].left > left_side[i] + 2
            ) {
            jumpLine = i;
            break;
        }
    }
    ////////printf("下跳变点=%d\n", jumpLine);
    //Q弯看不到底下的角针对Q弯写的三点十字，一定要和三叉区分开！！！！！

    int way = 1;
    int sumDR = 0;
    int sumDL = 0;
    if (way == 0) {
        for (int i = NEAR_LINE; i >= 102; i--) {
            if (right_line[i] >= right_side[i] - 3) {
                sumDR++;
            }
            if (left_line[i] <= left_side[i] + 3) {
                sumDL++;
            }
        }
    }

    //////////printf("sr=%d,sl=%d", sumDR, sumDL);
    if (sumDR >= 10 && sumDL <= 2) {
        for (int i = NEAR_LINE; i >= 100; i--) {
            mid[i] = (left_line[i] + right_line[i]) / 2;
        }

        kMid = calculate_slope_uint(102, NEAR_LINE - 1, right_line);
        //////////printf("km=%f\n", kMid);

        for (int i = NEAR_LINE - 3; i >= 10; i--) {
            mid[i] = kMid * (i - 110) + (left_line[110]+right_line[110]) / 2;
            if (mid[i] > right_side[i]) {
                mid[i] = right_side[i];
            }
            if (mid[i] < left_side[i]) {
                mid[i] = left_side[i];
            }
        }

        uint8_t j_mid[CAMERA_H];

        for (int i = NEAR_LINE; i >= 1; i--) {
            j_mid[i] = j_continue[i];
            for (int j = 1; j <= my_road[i].white_num; j++) {
                if (abs((my_road[i].connected[j].left + my_road[i].connected[j].right) / 2 - mid[i]) < abs((my_road[i].connected[j_mid[i]].left + my_road[i].connected[j_mid[i]].right) / 2 - mid[i])
                    && my_road[i].connected[j].width > 20) {
                    j_mid[i] = j;
                }
            }

        }

        int yMax = NEAR_LINE - 3;
        if (1) {
            int i = NEAR_LINE - 3;
            while (i >= 70 && my_road[i].connected[j_mid[i]].left > left_side[i] + 1
                && abs(my_road[i].connected[j_mid[i]].left - my_road[i + 1].connected[j_mid[i + 1]].left) <= 5
                ){
                if (my_road[i].connected[j_mid[i]].left >= my_road[yMax].connected[j_mid[yMax]].left - 1
                    && calculate_slope_struct(i - 18, i - 3, j_mid, LEFT) * calculate_slope_struct(i + 3, i + 18, j_mid, LEFT) <= 0) {
                    yMax = i;
                }
                i--;
            }
            leftDownJumpPoint = yMax;
        }
        if (leftDownJumpPoint <= 110 && leftDownJumpPoint >= 70) {
            int start = leftDownJumpPoint - 40;

            uint8_t jumpLineD = 119;
            for (int i = start; i <= jumpLine; i++) {
                if (my_road[i + 2].connected[j_mid[i + 2]].width - my_road[i].connected[j_mid[i]].width >= 5
                    && abs(my_road[i - 1].connected[j_mid[i - 1]].width - my_road[i].connected[j_mid[i]].width) <= 3
                    && my_road[i].connected[j_mid[i]].width < 40
                    && my_road[i].connected[j_mid[i]].right < right_side[i] - 2 && my_road[i].connected[j_mid[i]].left > left_side[i] + 2
                    ) {
                    jumpLineD = i;
                    break;
                }


            }

            leftUpJumpPoint = jumpLineD;
            int i = jumpLineD - 1;
            rightUpJumpPoint = i;
            while (i <= jumpLineD + 30 && my_road[i].connected[j_mid[i]].right <= right_side[i] - 5) {
                if (my_road[i].connected[j_mid[i]].right <= my_road[rightUpJumpPoint].connected[j_mid[rightUpJumpPoint]].right
                    && calculate_slope_struct(i - 18, i - 3, j_mid, RIGHT) * calculate_slope_struct(i + 3, i + 18, j_mid, RIGHT) <= 0
                    && abs(my_road[i].connected[j_mid[i]].right - my_road[i - 1].connected[j_mid[i - 1]].right) <= 5) {
                    rightUpJumpPoint = i;
                }

                i++;
            }


            if (jumpLineD - 1 < leftUpJumpPoint && jumpLineD - 1 < rightUpJumpPoint
                && leftUpJumpPoint <= jumpLine && rightUpJumpPoint <= jumpLine
                && leftDownJumpPoint - 5 > leftUpJumpPoint
                && leftDownJumpPoint - 5 > rightUpJumpPoint
                //右上的拐点不应该在左下拐点的左边,同理，左上拐点不应该在右下拐点的右边
                && my_road[rightUpJumpPoint].connected[j_mid[rightUpJumpPoint]].right > my_road[leftDownJumpPoint].connected[j_mid[leftDownJumpPoint]].left
                && my_road[leftUpJumpPoint].connected[j_mid[leftUpJumpPoint]].left > my_road[leftDownJumpPoint].connected[j_mid[leftDownJumpPoint]].left
                && my_road[leftUpJumpPoint + 7].connected[j_mid[leftUpJumpPoint + 7]].left < my_road[leftUpJumpPoint].connected[j_mid[leftUpJumpPoint]].left
                && my_road[rightUpJumpPoint + 7].connected[j_mid[rightUpJumpPoint + 7]].right > my_road[rightUpJumpPoint].connected[j_mid[rightUpJumpPoint]].right
                && my_road[leftDownJumpPoint - 7].connected[j_mid[leftDownJumpPoint - 7]].left < my_road[leftDownJumpPoint].connected[j_mid[leftDownJumpPoint]].left
                && my_road[rightDownJumpPoint - 7].connected[j_mid[rightDownJumpPoint - 7]].right > my_road[rightDownJumpPoint].connected[j_mid[rightDownJumpPoint]].right
                //&& fabs(calculate_slope_struct(leftUpJumpPoint - 16, leftUpJumpPoint - 1, j_mid, LEFT) - calculate_slope_struct(rightUpJumpPoint - 16, rightUpJumpPoint - 1, j_mid, RIGHT)) < 0.2
                ) {
                //这个时候我们已经找到了四个点，但这四个点不一定准

                //区别三叉
                double dk;
                double dk2;

                    //  ////////printf("d=%d,ku=%f,kd=%f\n", direction, calculate_slope_struct(rightUpJumpPoint - 20 + 2, rightUpJumpPoint - 5 + 2, j_mid, RIGHT), calculate_slope_struct(leftDownJumpPoint + 5 - 2, leftDownJumpPoint + 20 - 2, j_mid, LEFT));
                dk = fabs(calculate_slope_struct(rightUpJumpPoint - 18, rightUpJumpPoint - 3, j_mid, RIGHT) - calculate_slope_struct(leftDownJumpPoint + 3, leftDownJumpPoint + 18, j_mid, LEFT));
                dk2= fabs(calculate_slope_struct(leftUpJumpPoint - 18, leftUpJumpPoint - 3, j_mid, LEFT) - calculate_slope_struct(leftDownJumpPoint + 3, leftDownJumpPoint + 18, j_mid, LEFT));




                if (dk < 0.2 && dk2 < 0.2) {
                    //区别环岛，T字路口

                    double kl1 = calculate_slope_struct(leftUpJumpPoint - 15, leftUpJumpPoint - 1, j_mid, LEFT);
                    double kl2 = calculate_slope_struct(leftUpJumpPoint + 1, leftDownJumpPoint - 1, j_mid, LEFT);
                    double kl3 = calculate_slope_struct(leftDownJumpPoint + 1, leftDownJumpPoint + 15, j_mid, LEFT);
                    double kr1 = calculate_slope_struct(rightUpJumpPoint - 15, rightUpJumpPoint - 1, j_mid, RIGHT);
                    double kr2 = calculate_slope_struct(rightUpJumpPoint + 1, leftDownJumpPoint - 1, j_mid, RIGHT);
                    double kr3 = calculate_slope_struct(rightDownJumpPoint + 1, leftDownJumpPoint + 15, j_mid, RIGHT);
                    //////////printf("dk=%f\n", fabs(kl2 - kl3));
                    if (((fabs(kl1 - kl2) < 0.2 && fabs(kl1 - kl3) < 0.2 && fabs(kl2 - kl3) < 0.2) || (fabs(kr1 - kr2) < 0.2 && fabs(kr1 - kr3) < 0.2 && fabs(kr2 - kr3) < 0.2))) {

                    }
                    else {
                        state = stateCrossIn;
                    }

                }
            }


        }

    }
    else if (sumDR <= 2 && sumDL >= 10) {
        for (int i = NEAR_LINE; i >= 100; i--) {
            mid[i] = (left_line[i] + right_line[i]) / 2;
        }

        kMid = calculate_slope_uint(102, NEAR_LINE - 1, left_line);

        for (int i = NEAR_LINE - 3; i >= 10; i--) {
            mid[i] = kMid * (i - 110) + (left_line[110] + right_line[110]) / 2;

        }

        uint8_t j_mid[CAMERA_H];

        for (int i = NEAR_LINE; i >= 1; i--) {
            j_mid[i] = j_continue[i];
            for (int j = 1; j <= my_road[i].white_num; j++) {
                if (abs((my_road[i].connected[j].left + my_road[i].connected[j].right) / 2 - mid[i]) < abs((my_road[i].connected[j_mid[i]].left + my_road[i].connected[j_mid[i]].right) / 2 - mid[i])
                    && my_road[i].connected[j].width > 20) {
                    j_mid[i] = j;
                }
            }

        }
        int yMin = NEAR_LINE;
        if (1) {
            int i = NEAR_LINE - 3;
            while (i >= 70 && my_road[i].connected[j_mid[i]].right < right_side[i] - 1
                && abs(my_road[i].connected[j_mid[i]].right - my_road[i + 1].connected[j_mid[i + 1]].right) <= 5
                ) {
                if (my_road[i].connected[j_mid[i]].right <= my_road[yMin].connected[j_mid[yMin]].right + 1
                    && calculate_slope_struct(i - 18, i - 3, j_mid, RIGHT) * calculate_slope_struct(i + 3, i + 18, j_mid, RIGHT) <= 0) {
                    yMin = i;
                }
                i--;
            }
            rightDownJumpPoint = yMin;
        }
    if (rightDownJumpPoint <= 110 && rightDownJumpPoint >= 70) {
        int start = rightDownJumpPoint - 40;

        uint8_t jumpLineD = 119;
        for (int i = start; i <= jumpLine; i++) {
            if (my_road[i + 2].connected[j_mid[i + 2]].width - my_road[i].connected[j_mid[i]].width >= 5
                && abs(my_road[i - 1].connected[j_mid[i - 1]].width - my_road[i].connected[j_mid[i]].width) <= 3
                && my_road[i].connected[j_mid[i]].width < 40
                && my_road[i].connected[j_mid[i]].right < right_side[i] - 2 && my_road[i].connected[j_mid[i]].left > left_side[i] + 2
                ) {
                jumpLineD = i;
                break;
            }


        }
        rightUpJumpPoint = jumpLineD;
        int i = jumpLineD - 1;
        leftUpJumpPoint = i;
        while (i <= jumpLineD + 30 && my_road[i].connected[j_mid[i]].left >= left_side[i] + 5) {
            if (my_road[i].connected[j_mid[i]].left >= my_road[leftUpJumpPoint].connected[j_mid[leftUpJumpPoint]].left
                && calculate_slope_struct(i - 18, i - 3, j_mid, LEFT) * calculate_slope_struct(i + 3, i + 18, j_mid, LEFT) <= 0
                && abs(my_road[i].connected[j_mid[i - 1]].left-my_road[i - 1].connected[j_mid[i - 1]].left) <= 5) {
                leftUpJumpPoint = i;
            }

            i++;
        }


        if (jumpLineD - 1 < leftUpJumpPoint && jumpLineD - 1 < rightUpJumpPoint
            && leftUpJumpPoint <= jumpLine && rightUpJumpPoint <= jumpLine
            && rightDownJumpPoint - 5 > leftUpJumpPoint
            && rightDownJumpPoint - 5 > rightUpJumpPoint
            //右上的拐点不应该在左下拐点的左边,同理，左上拐点不应该在右下拐点的右边
            && my_road[rightUpJumpPoint].connected[j_mid[rightUpJumpPoint]].right < my_road[rightDownJumpPoint].connected[j_mid[rightDownJumpPoint]].right
            && my_road[leftUpJumpPoint].connected[j_mid[leftUpJumpPoint]].left < my_road[rightDownJumpPoint].connected[j_mid[rightDownJumpPoint]].right
            //&& fabs(calculate_slope_struct(leftUpJumpPoint - 16, leftUpJumpPoint - 1, j_mid, LEFT) - calculate_slope_struct(rightUpJumpPoint - 16, rightUpJumpPoint - 1, j_mid, RIGHT)) < 0.2
            ) {
            //这个时候我们已经找到了四个点，但这四个点不一定准

            //区别三叉
            double dk = 2;

            dk = fabs(calculate_slope_struct(rightUpJumpPoint - 18, rightUpJumpPoint - 3, j_mid, RIGHT) - calculate_slope_struct(rightDownJumpPoint + 3, rightDownJumpPoint + 18, j_mid, RIGHT));
            double dk2= fabs(calculate_slope_struct(leftUpJumpPoint - 18, leftUpJumpPoint - 3, j_mid, LEFT) - calculate_slope_struct(rightDownJumpPoint + 3, rightDownJumpPoint + 18, j_mid, RIGHT));




            if (dk < 0.2 && dk2 < 0.2) {
                //区别环岛，T字路口

                double kl1 = calculate_slope_struct(leftUpJumpPoint - 15, leftUpJumpPoint - 1, j_mid, LEFT);
                double kl2 = calculate_slope_struct(leftUpJumpPoint + 1, rightDownJumpPoint - 1, j_mid, LEFT);
                double kl3 = calculate_slope_struct(leftDownJumpPoint + 1, rightDownJumpPoint + 15, j_mid, LEFT);
                double kr1 = calculate_slope_struct(rightUpJumpPoint - 15, rightUpJumpPoint - 1, j_mid, RIGHT);
                double kr2 = calculate_slope_struct(rightUpJumpPoint + 1, rightDownJumpPoint - 1, j_mid, RIGHT);
                double kr3 = calculate_slope_struct(rightDownJumpPoint + 1, rightDownJumpPoint + 15, j_mid, RIGHT);
                //////////printf("dk=%f\n", fabs(kl2 - kl3));
                if (((fabs(kl1 - kl2) < 0.2 && fabs(kl1 - kl3) < 0.2 && fabs(kl2 - kl3) < 0.2) || (fabs(kr1 - kr2) < 0.2 && fabs(kr1 - kr3) < 0.2 && fabs(kr2 - kr3) < 0.2))) {

                }
                else {
                    state = stateCrossIn;
                }

            }
        }


    }
    }
    else {
        //统一坐标
        if (60 < jumpLine && jumpLine <= NEAR_LINE - 1) {

            uint8_t jumpLineEnd = jumpLine + 15;
            if (jumpLineEnd >= NEAR_LINE) {
                jumpLineEnd = NEAR_LINE;
            }
            for (int i = jumpLine; i <= jumpLineEnd; i++) {
                mid[i] = (left_line[i] + right_line[i]) / 2;
            }

            double kMid = calculate_slope(jumpLine, jumpLineEnd, mid);
            if (fabs(kMid) <= kRange) {
                direction = 0;
            }
            else if (kMid > kRange) {
                direction = LEFT;
            }
            else if (kMid < -1 * kRange) {
                direction = RIGHT;
            }
            ////////printf("十字倾斜方向=%d\n", direction);
            if (direction == 0) {
                if (my_road[jumpLine - 10].connected[j_mid[jumpLine - 10]].right + 1 >= my_road[jumpLine].connected[j_mid[jumpLine]].right
                    && my_road[jumpLine - 10].connected[j_mid[jumpLine - 10]].left - 1 <= my_road[jumpLine].connected[j_mid[jumpLine]].left) {
                    leftDownJumpPoint = jumpLine;
                    rightDownJumpPoint = jumpLine;
                }
            }
            else if (direction == LEFT) {
                leftDownJumpPoint = jumpLine;
                int i = jumpLine + 1;
                rightDownJumpPoint = i;
                while (i >= jumpLine - 30 && my_road[i].connected[j_mid[i]].right <= my_road[jumpLine].connected[j_mid[jumpLine]].right + 10) {
                    if (my_road[i].connected[j_mid[i]].right <= my_road[rightDownJumpPoint].connected[j_mid[rightDownJumpPoint]].right
                        && calculate_slope_struct(i - 18, i - 3, j_mid, RIGHT) * calculate_slope_struct(i + 3, i + 18, j_mid, RIGHT) <= 0) {
                        rightDownJumpPoint = i;
                    }

                    i--;
                }

            }
            else if (direction == RIGHT) {
                rightDownJumpPoint = jumpLine;
                int i = jumpLine + 1;
                leftDownJumpPoint = i;
                while (i >= jumpLine - 30 && my_road[i].connected[j_mid[i]].left >= my_road[jumpLine].connected[j_mid[jumpLine]].left - 10) {
                    if (my_road[i].connected[j_mid[i]].left >= my_road[leftDownJumpPoint].connected[j_mid[leftDownJumpPoint]].left
                        && calculate_slope_struct(i - 18, i - 3, j_mid, LEFT) * calculate_slope_struct(i + 3, i + 18, j_mid, LEFT) <= 0) {
                        leftDownJumpPoint = i;
                    }

                    i--;
                }
            }
            ////////printf("下突变点:左下%d=%d,右下:%d=%d\n", leftDownJumpPoint, my_road[leftDownJumpPoint].connected[j_mid[leftDownJumpPoint]].left, rightDownJumpPoint, my_road[rightDownJumpPoint].connected[j_mid[rightDownJumpPoint]].right);
            ////////printf("线性判断:左:%f右:%f\n", linear_judgement_struct(jumpLine, NEAR_LINE, j_mid, LEFT) && linear_judgement_struct(jumpLine, NEAR_LINE, j_mid, RIGHT));
            ////////printf("平行判断:%f\n", fabs(calculate_slope_struct(leftDownJumpPoint + 1, leftDownJumpPoint + 16, j_mid, LEFT) - calculate_slope_struct(rightDownJumpPoint + 1, rightDownJumpPoint + 16, j_mid, RIGHT)));

            if (leftDownJumpPoint < jumpLine + 1 && rightDownJumpPoint < jumpLine + 1
                && ((fabs(calculate_slope_struct(leftDownJumpPoint + 1,leftDownJumpPoint + 16, j_mid, LEFT) - calculate_slope_struct(rightDownJumpPoint + 1, rightDownJumpPoint + 16, j_mid, RIGHT)) < 0.35 && linear_judgement_struct(jumpLine, jumpLine + 15, j_mid, LEFT) < 20 && linear_judgement_struct(jumpLine, jumpLine + 15, j_mid, RIGHT) < 20
                    && jumpLine <= 103)
                    || (jumpLine >= 103 && linear_judgement_struct(jumpLine , NEAR_LINE,j_mid,LEFT) < 20 && linear_judgement_struct(jumpLine, NEAR_LINE, j_mid, RIGHT) < 20))
                && my_road[15].white_num != 0) {

                //矫正mid与direction
                for (int i = jumpLine; i >= 1; i--) {
                    mid[i] = kMid * (i - jumpLine) + mid[jumpLine];
                //  IMG[i][mid[i]] = purple;
                }
                for (int i = jumpLine; i >= 1; i--) {
                    j_mid[i] = j_continue[i];
                    for (int j = 1; j <= my_road[i].white_num; j++) {
                        if (abs((my_road[i].connected[j].left + my_road[i].connected[j].right) / 2 - mid[i]) < abs((my_road[i].connected[j_mid[i]].left + my_road[i].connected[j_mid[i]].right) / 2 - mid[i])
                            && my_road[i].connected[j].width > 10) {
                            j_mid[i] = j;
                        }
                    }
                    //////////printf("%d:l=%d,r=%d\n", i, my_road[i].connected[j_mid[i]].left, my_road[i].connected[j_mid[i]].width);
                }

                //这时候我们认为我们已经找到了下方两个突变点的坐标，
                //我们继续寻找上方两个坐标点

                int start = jumpLine - 70;
                if (start <= 10) {
                    start = 10;
                }

                if (my_road[start].connected[j_mid[start]].width >= lim_white_straight
                    ) {
                    while (start <= jumpLine - 20 && my_road[start].connected[j_mid[start]].width >= lim_white_straight) {
                        start++;
                    }
                }
                uint8_t jumpLineD = 119;
                //////////printf("start = %d\n", start);
                for (int i = jumpLine - 25; i >= start; i--) {
                    if (my_road[i + 2].connected[j_mid[i + 2]].width - my_road[i].connected[j_mid[i]].width >= 6
                        && abs(my_road[i - 1].connected[j_mid[i - 1]].width - my_road[i].connected[j_mid[i]].width) <= 4
                        && my_road[i].connected[j_mid[i]].width < lim_white_straight
                        && my_road[i].connected[j_mid[i]].right < right_side[i] - 2 && my_road[i].connected[j_mid[i]].left > left_side[i] + 2
                        ) {
                        jumpLineD = i;
                        break;
                    }


                }
                ////////printf("上跳变行=%d\n", jumpLineD);
                if (direction == 0) {

                    if (my_road[jumpLineD + 15].connected[j_mid[jumpLineD + 15]].right + 1 >= my_road[jumpLine].connected[j_mid[jumpLine]].right
                        && my_road[jumpLineD + 15].connected[j_mid[jumpLineD + 15]].left - 1 <= my_road[jumpLine].connected[j_mid[jumpLine]].left) {
                        leftUpJumpPoint = jumpLineD;
                        rightUpJumpPoint = jumpLineD;
                    }


                }
                else if (direction == LEFT) {
                    rightUpJumpPoint = jumpLineD;
                    int i = jumpLineD;
                    leftUpJumpPoint = i;
                    while (i <= jumpLineD + 30 && my_road[i].connected[j_mid[i]].left >= left_side[i] + 5) {
                        if (my_road[i].connected[j_mid[i]].left >= my_road[leftUpJumpPoint].connected[j_mid[leftUpJumpPoint]].left
                            && calculate_slope_struct(i - 18, i - 3, j_mid, LEFT) * calculate_slope_struct(i + 3, i + 18, j_mid, LEFT) <= 0) {
                            leftUpJumpPoint = i;
                        }

                        i++;
                    }

                }
                else if (direction == RIGHT) {
                    leftUpJumpPoint = jumpLineD;
                    int i = jumpLineD;
                    rightUpJumpPoint = i;
                    while (i <= jumpLineD + 30 && my_road[i].connected[j_mid[i]].right <= right_side[i] - 5) {
                        if (my_road[i].connected[j_mid[i]].right <= my_road[rightUpJumpPoint].connected[j_mid[rightUpJumpPoint]].right
                            && calculate_slope_struct(i - 18, i - 3, j_mid, RIGHT) * calculate_slope_struct(i + 3, i + 18, j_mid, RIGHT) <= 0) {
                            rightUpJumpPoint = i;
                        }

                        i++;
                    }
                }
                //////////printf("jD=%d\n", jumpLineD);
                ////////printf("上跳变点：左:%d=%d,右:%d=%d\n", leftUpJumpPoint, my_road[leftUpJumpPoint].connected[j_mid[leftUpJumpPoint]].left, rightUpJumpPoint, my_road[rightUpJumpPoint].connected[j_mid[rightUpJumpPoint]].right);
                ////////printf("线性判断:左上%f,右上:%f\n", linear_judgement_struct(leftUpJumpPoint - 15, leftUpJumpPoint - 1, j_mid, LEFT), linear_judgement_struct(rightUpJumpPoint - 15, rightUpJumpPoint - 1, j_mid, RIGHT));
                if (jumpLineD - 1 < leftUpJumpPoint && jumpLineD - 1 < rightUpJumpPoint
                    && jumpLine-jumpLineD <= 65
                    && leftUpJumpPoint <= jumpLine && rightUpJumpPoint <= jumpLine
                    && leftDownJumpPoint  > leftUpJumpPoint - 7 && rightDownJumpPoint  > leftUpJumpPoint - 7
                    && leftDownJumpPoint  > rightUpJumpPoint - 7 && rightDownJumpPoint > rightUpJumpPoint - 7
                    //右上的拐点不应该在左下拐点的左边,同理，左上拐点不应该在右下拐点的右边
                    && my_road[rightUpJumpPoint].connected[j_mid[rightUpJumpPoint]].right >= my_road[leftDownJumpPoint].connected[j_mid[leftDownJumpPoint]].left - 7
                    && my_road[leftUpJumpPoint].connected[j_mid[leftUpJumpPoint]].left <= my_road[rightDownJumpPoint].connected[j_mid[rightDownJumpPoint]].right + 7
                    /*&& my_road[leftUpJumpPoint + 6].connected[j_mid[leftUpJumpPoint + 6]].left < my_road[leftUpJumpPoint].connected[j_mid[leftUpJumpPoint]].left
                    && my_road[rightUpJumpPoint + 6].connected[j_mid[rightUpJumpPoint + 6]].right > my_road[rightUpJumpPoint].connected[j_mid[rightUpJumpPoint]].right
                    && my_road[leftDownJumpPoint - 6].connected[j_mid[leftDownJumpPoint - 6]].left < my_road[leftDownJumpPoint].connected[j_mid[leftDownJumpPoint]].left
                    && my_road[rightDownJumpPoint - 6].connected[j_mid[rightDownJumpPoint - 6]].right > my_road[rightDownJumpPoint].connected[j_mid[rightDownJumpPoint]].right
                    */&& my_road[rightUpJumpPoint].connected[j_mid[rightUpJumpPoint]].right > my_road[leftUpJumpPoint].connected[j_mid[leftUpJumpPoint]].left
                    && my_road[rightDownJumpPoint].connected[j_mid[rightDownJumpPoint]].right > my_road[leftDownJumpPoint].connected[j_mid[leftDownJumpPoint]].left
                    && ((linear_judgement_struct(leftUpJumpPoint - 15,leftUpJumpPoint - 1,j_mid,LEFT) < 25 && linear_judgement_struct(rightUpJumpPoint - 15, rightUpJumpPoint - 1, j_mid, RIGHT) < 25 && jumpLineD >= 40)
                        || (linear_judgement_struct(leftUpJumpPoint - 15, leftUpJumpPoint - 1, j_mid, LEFT) < 20 && jumpLineD < 40 && direction == LEFT) || (linear_judgement_struct(rightUpJumpPoint - 15, rightUpJumpPoint - 1, j_mid, RIGHT) < 20 && jumpLineD < 40 && direction == RIGHT)
                        || (linear_judgement_struct(leftUpJumpPoint - 15, leftUpJumpPoint - 1, j_mid, LEFT) < 25 && linear_judgement_struct(rightUpJumpPoint - 15, rightUpJumpPoint - 1, j_mid, RIGHT) < 25 && jumpLineD < 40 && direction == 0))
                    //&& fabs(calculate_slope_struct(leftUpJumpPoint - 16, leftUpJumpPoint - 1, j_mid, LEFT) - calculate_slope_struct(rightUpJumpPoint - 16, rightUpJumpPoint - 1, j_mid, RIGHT)) < 0.2
                    ) {
                    //这个时候我们已经找到了四个点，但这四个点不一定准

                    //区别三叉
                    double dk;

                    if (direction == 0) {
                        double dk1= fabs(calculate_slope_struct(rightUpJumpPoint - 18, rightUpJumpPoint - 3, j_mid, RIGHT) - calculate_slope_struct(rightDownJumpPoint + 3, rightDownJumpPoint + 18, j_mid, RIGHT));
                        double dk2 = fabs(calculate_slope_struct(leftUpJumpPoint - 18, leftUpJumpPoint - 3, j_mid, LEFT) - calculate_slope_struct(leftDownJumpPoint + 3, leftDownJumpPoint + 18, j_mid, LEFT));
                        if (dk1 > dk2) dk = dk2;
                        else dk = dk1;
                    }
                    else if (direction == LEFT) {
                        //////////printf("d=%d,ku=%f,kd=%f\n", direction, calculate_slope_struct(leftUpJumpPoint - 20 + 2, leftUpJumpPoint - 5 + 2, j_mid, LEFT), calculate_slope_struct(rightDownJumpPoint + 5 - 2, rightDownJumpPoint + 20 - 2, j_mid, RIGHT));
                        dk = fabs(calculate_slope_struct(rightUpJumpPoint - 18, rightUpJumpPoint - 3, j_mid, RIGHT) - calculate_slope_struct(rightDownJumpPoint + 3, rightDownJumpPoint + 18, j_mid, RIGHT));
                    }
                    else if (direction == RIGHT) {
                        //  ////////printf("d=%d,ku=%f,kd=%f\n", direction, calculate_slope_struct(rightUpJumpPoint - 20 + 2, rightUpJumpPoint - 5 + 2, j_mid, RIGHT), calculate_slope_struct(leftDownJumpPoint + 5 - 2, leftDownJumpPoint + 20 - 2, j_mid, LEFT));
                        dk = fabs(calculate_slope_struct(leftUpJumpPoint - 18, leftUpJumpPoint - 3, j_mid, LEFT) - calculate_slope_struct(leftDownJumpPoint + 3, leftDownJumpPoint + 18, j_mid, LEFT));
                    }
            //      ////////printf("dk=%f\n", dk);
                    if (dk < 0.3) {
                        //区别环岛，T字路口

                        ////////printf("区分环岛回环:%f,%f\n", linear_judgement_struct(leftUpJumpPoint - 3, leftDownJumpPoint + 3, j_mid, LEFT), linear_judgement_struct(rightUpJumpPoint - 3, rightDownJumpPoint + 3, j_mid, RIGHT));
                        if (/*((fabs(kl1 - kl2) < 0.2 && fabs(kl1 - kl3) < 0.2 && fabs(kl2 - kl3) < 0.2) || (fabs(kr1 - kr2) < 0.2 && fabs(kr1 - kr3) < 0.2 && fabs(kr2 - kr3) < 0.2))*/
                            linear_judgement_struct(leftUpJumpPoint - 3, leftDownJumpPoint + 3, j_mid, LEFT) < 100 || linear_judgement_struct(rightUpJumpPoint - 3, rightDownJumpPoint + 3, j_mid, RIGHT) < 100) {

                        }
                        else {
                            state = stateCrossIn;
                        }

                    }
                }

            }

        }



    }



}

////////////////////////////////////////////
//功能：进十字补线
//输入：
//输出：
//备注：
///////////////////////////////////////////
void design_cross_ing() {
    int mid[CAMERA_H];
    for (int i = NEAR_LINE; i >= 100; i--) {
        mid[i] = (left_line[i] + right_line[i]) / 2;
    }

    double kMid = calculate_slope(100, 113, mid);
    int direction;
    double kRange = 0.2;
    if (fabs(kMid) <= kRange) {
        direction = 0;
    }
    else if (kMid > kRange) {
        direction = LEFT;
    }
    else if (kMid < -1 * kRange) {
        direction = RIGHT;
    }

    for (int i = 99; i >= 1; i--) {
        mid[i] = kMid * (i - 100) + mid[100];
        if (mid[i] <= left_side[i]) {
            mid[i] = left_side[i];
        }
        if (mid[i] >= right_line[i]) {
            mid[i] = right_side[i];
        }
        //IMG[i][mid[i]] = purple;
    }



    uint8_t j_mid[CAMERA_H];

    for (int i = NEAR_LINE; i >= 1; i--) {
        j_mid[i] = j_continue[i];
        for (int j = 1; j <= my_road[i].white_num; j++) {
            if (abs((my_road[i].connected[j].left + my_road[i].connected[j].right) / 2 - mid[i]) < abs((my_road[i].connected[j_mid[i]].left + my_road[i].connected[j_mid[i]].right) / 2 - mid[i])
                && my_road[i].connected[j].width > 20) {
                j_mid[i] = j;
            }
        }

    }
    uint8_t jumpLine = 119;
    for (int i = 110; i >= 30; i--) {
        if (my_road[i - 2].connected[j_mid[i - 2]].width - my_road[i].connected[j_mid[i]].width >= 6
            && abs(my_road[i + 1].connected[j_mid[i + 1]].width - my_road[i].connected[j_mid[i]].width) <= 4
            && my_road[i].connected[j_mid[i]].width <= lim_white_straight
            && my_road[i].connected[j_mid[i]].right < right_side[i] - 2 && my_road[i].connected[j_mid[i]].left > left_side[i] + 2
            ) {
            jumpLine = i;
            break;
        }
        if ((my_road[i].connected[j_mid[i]].left == left_side[i] || my_road[i].connected[j_mid[i]].right == right_side[i]) && i<=100) {
            break;
        }
    }
    //////printf("jl=%d\n", jumpLine);
    if (60 < jumpLine && jumpLine <= 107) {

        for (int i = NEAR_LINE; i >= jumpLine + 1; i--) {
            mid[i] = (left_line[i] + right_line[i]) / 2;
        }
        if (jumpLine >= 100) {
            if (right_line[jumpLine - 4] > right_line[jumpLine] + 2 && abs(left_line[jumpLine - 4] - left_line[jumpLine]) <= 2 ) {
                kMid = calculate_slope_uint(jumpLine, jumpLine + 10, left_line);
            }
            else if (abs(right_line[jumpLine - 4] - right_line[jumpLine]) <= 2 && left_line[jumpLine - 4] < left_line[jumpLine] - 2) {
                kMid = calculate_slope_uint(jumpLine - 3, jumpLine + 10, right_line);
            }
            else {
                kMid = calculate_slope(jumpLine , jumpLine + 15, mid);
            }
        }
        else {
            kMid = calculate_slope(jumpLine + 1, jumpLine + 15, mid);
        }


        if (fabs(kMid) <= kRange) {
            direction = 0;
        }
        else if (kMid > kRange) {
            direction = LEFT;
        }
        else if (kMid < -1 * kRange) {
            direction = RIGHT;
        }

        for (int i = jumpLine + 3; i >= 1; i--) {
            mid[i] = kMid * (i - jumpLine - 3) + mid[jumpLine + 3];
            //IMG[i][mid[i]] = gray;
        }
        for (int i = NEAR_LINE; i >= 1; i--) {
            j_mid[i] = j_continue[i];
            if (!(1 <= j_continue[i] && j_continue[i] <= my_road[i].white_num)) {
                j_mid[i] = 1;
            }
            for (int j = 1; j <= my_road[i].white_num; j++) {

                if (abs((my_road[i].connected[j].left + my_road[i].connected[j].right) / 2 - mid[i]) < abs((my_road[i].connected[j_mid[i]].left + my_road[i].connected[j_mid[i]].right) / 2 - mid[i])
                    && my_road[i].connected[j].width >= 10
                    ) {
                    j_mid[i] = j;

                }
            }
        //  ////printf("%d:l=%d,r=%d\n",i,my_road[i].connected[j_mid[i]].left,my_road[i].connected[j_mid[i]].right);
        }
        for (int i = 20; i <= NEAR_LINE; i++) {
            if (my_road[i].connected[j_mid[i]].left > my_road[i - 1].connected[j_mid[i - 1]].right
                && my_road[i].connected[j_mid[i]].left > my_road[i - 2].connected[j_mid[i - 2]].right
                && my_road[i].connected[j_mid[i]].left > my_road[i - 3].connected[j_mid[i - 3]].right
                && my_road[i].connected[j_mid[i]].left > my_road[i - 4].connected[j_mid[i - 4]].right
                && my_road[i].connected[j_mid[i]].left > my_road[i - 5].connected[j_mid[i - 5]].right
                && my_road[i].connected[j_mid[i]].left > my_road[i - 6].connected[j_mid[i - 6]].right
                && my_road[i - 1].connected[j_mid[i - 1]].left < my_road[i - 2].connected[j_mid[i - 2]].right
                && my_road[i - 1].connected[j_mid[i - 1]].left < my_road[i - 3].connected[j_mid[i - 3]].right
                && my_road[i - 1].connected[j_mid[i - 1]].left < my_road[i - 4].connected[j_mid[i - 4]].right
                && my_road[i - 1].connected[j_mid[i - 1]].left < my_road[i - 5].connected[j_mid[i - 5]].right
                && my_road[i - 1].connected[j_mid[i - 1]].left < my_road[i - 6].connected[j_mid[i - 6]].right
                && my_road[i - 2].connected[j_mid[i - 2]].left < my_road[i - 3].connected[j_mid[i - 3]].right
                && my_road[i - 2].connected[j_mid[i - 2]].left < my_road[i - 4].connected[j_mid[i - 4]].right
                && my_road[i - 2].connected[j_mid[i - 2]].left < my_road[i - 5].connected[j_mid[i - 5]].right
                && my_road[i - 2].connected[j_mid[i - 2]].left < my_road[i - 6].connected[j_mid[i - 6]].right
                && my_road[i - 3].connected[j_mid[i - 3]].left < my_road[i - 4].connected[j_mid[i - 4]].right
                && my_road[i - 3].connected[j_mid[i - 3]].left < my_road[i - 5].connected[j_mid[i - 5]].right
                && my_road[i - 3].connected[j_mid[i - 3]].left < my_road[i - 6].connected[j_mid[i - 6]].right
                && my_road[i - 4].connected[j_mid[i - 4]].left < my_road[i - 5].connected[j_mid[i - 5]].right
                && my_road[i - 4].connected[j_mid[i - 4]].left < my_road[i - 6].connected[j_mid[i - 6]].right
                && my_road[i - 5].connected[j_mid[i - 5]].left < my_road[i - 6].connected[j_mid[i - 6]].right
                && my_road[i].connected[j_mid[i]].width < my_road[i + 5].connected[j_mid[i + 5]].width - 20
                && my_road[i].connected[j_mid[i]].width < my_road[i + 6].connected[j_mid[i + 6]].width - 20
                && my_road[i].connected[j_mid[i]].width<32
                && j_mid[i] > 1
                ) {
                j_mid[i] -= 1;
                i--;
                //////printf("-1\n");
            }
        }
        for (int i = 20; i <= NEAR_LINE; i++) {
            if (my_road[i].connected[j_mid[i]].right < my_road[i - 1].connected[j_mid[i - 1]].left
                && my_road[i].connected[j_mid[i]].right < my_road[i - 2].connected[j_mid[i - 2]].left
                && my_road[i].connected[j_mid[i]].right < my_road[i - 3].connected[j_mid[i - 3]].left
                && my_road[i].connected[j_mid[i]].right < my_road[i - 4].connected[j_mid[i - 4]].left
                && my_road[i].connected[j_mid[i]].right < my_road[i - 5].connected[j_mid[i - 5]].left
                && my_road[i].connected[j_mid[i]].right < my_road[i - 6].connected[j_mid[i - 6]].left
                && my_road[i - 1].connected[j_mid[i - 1]].right > my_road[i - 2].connected[j_mid[i - 2]].left
                && my_road[i - 1].connected[j_mid[i - 1]].right > my_road[i - 3].connected[j_mid[i - 3]].left
                && my_road[i - 1].connected[j_mid[i - 1]].right > my_road[i - 4].connected[j_mid[i - 4]].left
                && my_road[i - 1].connected[j_mid[i - 1]].right > my_road[i - 5].connected[j_mid[i - 5]].left
                && my_road[i - 1].connected[j_mid[i - 1]].right > my_road[i - 6].connected[j_mid[i - 6]].left
                && my_road[i - 2].connected[j_mid[i - 2]].right > my_road[i - 3].connected[j_mid[i - 3]].left
                && my_road[i - 2].connected[j_mid[i - 2]].right > my_road[i - 4].connected[j_mid[i - 4]].left
                && my_road[i - 2].connected[j_mid[i - 2]].right > my_road[i - 5].connected[j_mid[i - 5]].left
                && my_road[i - 2].connected[j_mid[i - 2]].right > my_road[i - 6].connected[j_mid[i - 6]].left
                && my_road[i - 3].connected[j_mid[i - 3]].right > my_road[i - 4].connected[j_mid[i - 4]].left
                && my_road[i - 3].connected[j_mid[i - 3]].right > my_road[i - 5].connected[j_mid[i - 5]].left
                && my_road[i - 3].connected[j_mid[i - 3]].right > my_road[i - 6].connected[j_mid[i - 6]].left
                && my_road[i - 4].connected[j_mid[i - 4]].right > my_road[i - 5].connected[j_mid[i - 5]].left
                && my_road[i - 5].connected[j_mid[i - 5]].right > my_road[i - 6].connected[j_mid[i - 6]].left
                && my_road[i - 6].connected[j_mid[i - 6]].right > my_road[i - 6].connected[j_mid[i - 6]].left
                //&& my_road[i].connected[j_mid[i]].width < my_road[i + 4].connected[j_mid[i + 4]].width - 20
                && my_road[i].connected[j_mid[i]].width < my_road[i + 5].connected[j_mid[i + 5]].width - 20
                && my_road[i].connected[j_mid[i]].width < my_road[i + 6].connected[j_mid[i + 6]].width - 20
                && my_road[i].connected[j_mid[i]].width < 32
                && j_mid[i] < my_road[i].white_num
                ) {
                j_mid[i] += 1;
                i--;
            //  ////printf("1\n");
            }
        }

        /*for (int i = NEAR_LINE; i >= 1; i--) {
            ////printf("%d:l=%d,r=%d\n", i, my_road[i].connected[j_mid[i]].left, my_road[i].connected[j_mid[i]].right);
        }*/

        if (direction == 0) {
            int dy = 10;
            if (1) {
                leftDownJumpPoint = jumpLine;
                rightDownJumpPoint = jumpLine;
            }
        }
        else if (direction == LEFT) {
            leftDownJumpPoint = jumpLine;
            int i = jumpLine + 5;
            if (jumpLine + 5 > NEAR_LINE) {
                i = NEAR_LINE;
            }
            rightDownJumpPoint = i;
            while (i >= jumpLine - 30 && my_road[i].connected[j_mid[i]].right <= right_side[i] - 3 && my_road[i].connected[j_mid[i]].right <= my_road[NEAR_LINE].connected[j_mid[NEAR_LINE]].right + 15) {
                if (my_road[i].connected[j_mid[i]].right <= my_road[rightDownJumpPoint].connected[j_mid[rightDownJumpPoint]].right + 1) {
                    rightDownJumpPoint = i;
                }

                i--;
            }

        }
        else if (direction == RIGHT) {
            rightDownJumpPoint = jumpLine;
            int i = jumpLine + 5;
            if (i >= NEAR_LINE) {
                i = NEAR_LINE;
            }
            leftDownJumpPoint = i;
            while (i >= jumpLine - 30 && my_road[i].connected[j_mid[i]].left >= left_side[i] + 5 && my_road[i].connected[j_mid[i]].left > my_road[NEAR_LINE].connected[j_mid[NEAR_LINE]].left - 15) {
                if (my_road[i].connected[j_mid[i]].left >= my_road[leftDownJumpPoint].connected[j_mid[leftDownJumpPoint]].left - 1) {
                    leftDownJumpPoint = i;
                }

                i--;
            }
        }
        //////printf("%d=%d,%d=%d\n", leftDownJumpPoint, my_road[leftDownJumpPoint].connected[j_mid[leftDownJumpPoint]].left, rightDownJumpPoint, my_road[rightDownJumpPoint].connected[j_mid[rightDownJumpPoint]].right);
        if (leftDownJumpPoint <= jumpLine + 1 && rightDownJumpPoint <= jumpLine + 1
            && my_road[jumpLine - 60].white_num != 0) {
            //这时候我们认为我们已经找到了下方两个突变点的坐标，
            //我们继续寻找上方两个坐标点

            int start = jumpLine - 70;
            if (start <= 10) {
                start = 10;
            }

            if (my_road[start].connected[j_mid[start]].width >= lim_white_straight
                ) {
                while (start <= jumpLine - 20 && my_road[start].connected[j_mid[start]].width >= lim_white_straight) {
                    start++;
                }
            }
            uint8_t jumpLineD = 119;
            for (int i = jumpLine; i >= start; i--) {
                if (my_road[i + 2].connected[j_mid[i + 2]].width - my_road[i].connected[j_mid[i]].width >= 6
                    && abs(my_road[i - 1].connected[j_mid[i - 1]].width - my_road[i].connected[j_mid[i]].width) <= 4
                    && abs(my_road[i - 2].connected[j_mid[i - 2]].width - my_road[i].connected[j_mid[i]].width) <= 8
                    && abs(my_road[i - 3].connected[j_mid[i - 3]].width - my_road[i].connected[j_mid[i]].width) <= 8

                    && my_road[i].connected[j_mid[i]].width < lim_white_straight
                    && my_road[i].connected[j_mid[i]].right < right_side[i] - 2 && my_road[i].connected[j_mid[i]].left > left_side[i] + 2
                    ) {
                    jumpLineD = i;
                    break;
                }


            }
            //////printf("jlD=%d\n", jumpLineD);
            if (direction == 0) {
                if (1) {
                    leftUpJumpPoint = jumpLineD;
                    rightUpJumpPoint = jumpLineD;
                }
            }
            else if (direction == LEFT) {
                rightUpJumpPoint = jumpLineD;
                int i = jumpLineD;
                leftUpJumpPoint = i;
                while (i <= jumpLineD + 30 && my_road[i].connected[j_mid[i]].left >= left_side[i] + 5
                    && my_road[i].connected[j_mid[i]].left >= my_road[jumpLineD].connected[j_mid[jumpLineD]].left - 10) {
                    if (my_road[i].connected[j_mid[i]].left >= my_road[leftUpJumpPoint].connected[j_mid[leftUpJumpPoint]].left) {
                        leftUpJumpPoint = i;
                    }

                    i++;
                }

            }
            else if (direction == RIGHT) {
                leftUpJumpPoint = jumpLineD;
                int i = jumpLineD;
                rightUpJumpPoint = i;
                while (i <= jumpLineD + 30 && my_road[i].connected[j_mid[i]].right <= right_side[i] - 5
                    && my_road[i].connected[j_mid[i]].right <= my_road[jumpLineD].connected[j_mid[jumpLineD]].right + 15
                    ) {
                    if (my_road[i].connected[j_mid[i]].right <= my_road[rightUpJumpPoint].connected[j_mid[rightUpJumpPoint]].right) {
                        rightUpJumpPoint = i;
                    }

                    i++;
                }
            }
            //////printf("ru=%d\n", rightUpJumpPoint);
        //  ////printf("l:%d=%d,r:%d=%d", leftUpJumpPoint,my_road[leftUpJumpPoint].connected[j_mid[leftUpJumpPoint]].left,rightUpJumpPoint,my_road[rightUpJumpPoint].connected[j_mid[rightUpJumpPoint]].right);


            if (jumpLineD - 5 <= leftUpJumpPoint && jumpLineD - 5 <= rightUpJumpPoint
                && leftUpJumpPoint <= jumpLine && rightUpJumpPoint <= jumpLine) {

                for (int i = NEAR_LINE; i >= 1; i--) {
                    left_line[i] = my_road[i].connected[j_mid[i]].left;
                    right_line[i] = my_road[i].connected[j_mid[i]].right;
                    double kl = calculate_two_point_slope(leftUpJumpPoint, my_road[leftUpJumpPoint].connected[j_mid[leftUpJumpPoint]].left, leftDownJumpPoint, my_road[leftDownJumpPoint].connected[j_mid[leftDownJumpPoint]].left);
                    if (leftUpJumpPoint <= i && i <= leftDownJumpPoint) {
                        left_line[i] = kl * (i - leftDownJumpPoint) + my_road[leftDownJumpPoint].connected[j_mid[leftDownJumpPoint]].left;
                    }
                    double kr = calculate_two_point_slope(rightUpJumpPoint, my_road[rightUpJumpPoint].connected[j_mid[rightUpJumpPoint]].right, rightDownJumpPoint, my_road[rightDownJumpPoint].connected[j_mid[rightDownJumpPoint]].right);
                    if (rightUpJumpPoint <= i && i <= rightDownJumpPoint) {
                        right_line[i] = kr * (i - rightDownJumpPoint) + my_road[rightDownJumpPoint].connected[j_mid[rightDownJumpPoint]].right;
                    }
                    // ////printf("%d:w=%d\n", i, right_line[i] - left_line[i]);
                }

            }


        }
    }
    else if (jumpLine == 119 || jumpLine <= 60 || jumpLine > 106) {
        //跳变行消失，赛道下方还有没有突变点

        //找到消失的点
        int sum_right_miss = 0;
        int sum_left_miss = 0;
        for (int i = NEAR_LINE; i >= 90; i--) {
            if (right_line[i] >= right_side[i] - 2) {
                sum_right_miss++;
            }
            if (left_line[i] <= left_side[i] + 2) {
                sum_left_miss++;
            }
        }
        int standard_miss = 12;
        int miss_direction = 0;
        int flag_dismiss_point = 119;
        if (sum_left_miss >= standard_miss && sum_right_miss < standard_miss) {
            //左miss
            miss_direction = LEFT;

        }
        else if (sum_left_miss < standard_miss && sum_right_miss >= standard_miss) {
            //右miss
            miss_direction = RIGHT;

        }

        if (miss_direction == RIGHT) {
            uint8_t max = 0;

            for (int i = NEAR_LINE; i >= 90; i--) {
                if (linear_judgement(i, i + 10, left_line) < 10 && calculate_slope_uint(i,i+10,left_line) <=0 && calculate_slope_uint(i - 10, i, left_line) > 0 && left_line[i] > max) {
                    max = left_line[i];
                    leftDownJumpPoint = i;

                }
            }
        }
        else if (miss_direction == LEFT) {
            uint8_t min = 180;

            for (int i = NEAR_LINE; i >= 90; i--) {
                if (linear_judgement(i, i + 10, right_line) < 10 && calculate_slope_uint(i, i + 10, right_line) >= 0 && calculate_slope_uint(i - 10, i, right_line) < 0 && right_line[i] < min) {
                    min = right_line[i];
                    rightDownJumpPoint = i;

                }
            }
        }

        uint8_t j_midL[CAMERA_H];
        uint8_t j_midR[CAMERA_H];
        j_midL[NEAR_LINE] = j_continue[NEAR_LINE];
        j_midR[NEAR_LINE] = j_continue[NEAR_LINE];
        int topL = 30, topR = 30;
        for (int i = NEAR_LINE - 1; i >= 2; i--) {
            j_midL[i] = j_continue[i];
            for (int j = 1; j <= my_road[i].white_num; j++) {
                if (abs(my_road[i].connected[j].left - my_road[i + 1].connected[j_midL[i + 1]].left) < abs(my_road[i].connected[j_midL[i]].left - my_road[i + 1].connected[j_midL[i + 1]].left)
                    && my_road[i].connected[j].width > 20 && my_road[i].connected[j].left <= my_road[i + 1].connected[j_midL[i + 1]].right && my_road[i].connected[j].right >= my_road[i + 1].connected[j_midL[i + 1]].left
                    ) {
                    j_midL[i] = j;

                }
                if (j == my_road[i].white_num && i > 30) {
                    //前方没路了
                    if (!(my_road[i].connected[j_midL[i]].left <= my_road[i + 1].connected[j_midL[i + 1]].right && my_road[i].connected[j_midL[i]].right >= my_road[i + 1].connected[j_midL[i + 1]].left)) {
                        topL = i;
                        break;
                    }
                }
            }
        }
        for (int i = NEAR_LINE - 1; i >= 2; i--) {
            j_midR[i] = j_continue[i];
            for (int j = 1; j <= my_road[i].white_num; j++) {
                if (abs(my_road[i].connected[j].right - my_road[i + 1].connected[j_midR[i + 1]].right) < abs(my_road[i].connected[j_midR[i]].right - my_road[i + 1].connected[j_midR[i + 1]].right)
                    && my_road[i].connected[j].width > 20 && my_road[i].connected[j].left <= my_road[i + 1].connected[j_midR[i + 1]].right && my_road[i].connected[j].right >= my_road[i + 1].connected[j_midR[i + 1]].left) {
                    j_midR[i] = j;
                }

                if (j == my_road[i].white_num && i > 30) {
                    //前方没路了
                    if (!(my_road[i].connected[j_midR[i]].left <= my_road[i + 1].connected[j_midR[i + 1]].right && my_road[i].connected[j_midR[i]].right >= my_road[i + 1].connected[j_midR[i + 1]].left)) {
                        topR = i;
                        break;
                    }
                }
            }
        }
        //////printf("topL=%d,topR=%d\n", topL, topR);
        if (miss_direction == RIGHT && leftDownJumpPoint > 90 && leftDownJumpPoint <= NEAR_LINE) {
            for (int i = NEAR_LINE - 1; i >= 2; i--) {
                j_mid[i] = j_midR[i];
            //  IMG[i][(my_road[i].connected[j_mid[i]].left + my_road[i].connected[j_mid[i]].right) / 2] = purple;
            }
        }
        else if (miss_direction == LEFT && rightDownJumpPoint > 90 && rightDownJumpPoint <= NEAR_LINE) {
            for (int i = NEAR_LINE - 1; i >= 2; i--) {
                j_mid[i] = j_midL[i];
            //  IMG[i][(my_road[i].connected[j_mid[i]].left + my_road[i].connected[j_mid[i]].right) / 2] = purple;
            }
        }
        else {
            if (topL >= 50 && topR < 50) {
                for (int i = NEAR_LINE - 1; i >= 2; i--) {
                    j_mid[i] = j_midR[i];
                //  IMG[i][(my_road[i].connected[j_mid[i]].left + my_road[i].connected[j_mid[i]].right) / 2] = purple;
                }
            }
            else if (topR >= 50 && topL < 50) {
                for (int i = NEAR_LINE - 1; i >= 2; i--) {
                    j_mid[i] = j_midL[i];
                //  IMG[i][(my_road[i].connected[j_mid[i]].left + my_road[i].connected[j_mid[i]].right) / 2] = purple;
                }
            }
            else {
                int sumL = 0;
                int sumR = 0;
                for (int i = 105; i > topL; i--) {
                    sumL += (my_road[i].connected[j_midL[i]].left + my_road[i].connected[j_midL[i]].right) / 2;
                }
                for (int i = 105; i > topR; i--) {
                    sumR += (my_road[i].connected[j_midR[i]].left + my_road[i].connected[j_midR[i]].right) / 2;
                }
                double aveL = (double)sumL / (105 - topL);
                double aveR = (double)sumR / (105 - topR);
            //  ////printf("avel=%f,aver=%f\n", aveL, aveR);
                if (fabs(aveL - 94) >= fabs(aveR - 94)) {
                //  ////printf("R\n");
                    for (int i = NEAR_LINE - 1; i >= 2; i--) {
                        j_mid[i] = j_midR[i];
                    //  IMG[i][(my_road[i].connected[j_mid[i]].left + my_road[i].connected[j_mid[i]].right) / 2] = purple;
                    }
                }
                else if (fabs(aveL - 94) < fabs(aveR - 94)) {
                //  ////printf("L\n");
                    for (int i = NEAR_LINE - 1; i >= 2; i--) {
                        j_mid[i] = j_midL[i];
                //      IMG[i][(my_road[i].connected[j_mid[i]].left + my_road[i].connected[j_mid[i]].right) / 2] = purple;
                    }
                }
            }
        }



        int start = 110;
        if (my_road[start].connected[j_mid[start]].width <= lim_white_straight
            ) {
            while (start >= 100 && my_road[start].connected[j_mid[start]].width <= lim_white_straight) {
                start--;
            }
        }

        uint8_t jumpLineD = 119;
        for (int i = start; i >= 40; i--) {
            if (my_road[i + 1].connected[j_mid[i + 1]].width - my_road[i].connected[j_mid[i]].width >= 6
                && abs(my_road[i - 1].connected[j_mid[i - 1]].width - my_road[i].connected[j_mid[i]].width) <= 4
                && abs(my_road[i - 2].connected[j_mid[i - 2]].width - my_road[i].connected[j_mid[i]].width) <= 8
                && abs(my_road[i - 3].connected[j_mid[i - 3]].width - my_road[i].connected[j_mid[i]].width) <= 10
                && my_road[i].connected[j_mid[i]].width < 60
                && my_road[i].connected[j_mid[i]].right < right_side[i] - 2 && my_road[i].connected[j_mid[i]].left > left_side[i] + 2
                ) {
                jumpLineD = i;
                break;
            }


        }
        for (int i = jumpLineD - 1; i >= jumpLineD - 20; i--) {
            mid[i] = (my_road[i].connected[j_mid[i]].right + my_road[i].connected[j_mid[i]].left) / 2;
        }
        kMid = calculate_slope(jumpLineD - 15, jumpLineD - 3, mid);
        kRange = 0.2;

        if (fabs(kMid) <= kRange) {
            direction = 0;
        }
        else if (kMid > kRange) {
            direction = LEFT;
        }
        else if (kMid < -1 * kRange) {
            direction = RIGHT;
        }

        if (direction == 0) {
            if (1) {
                leftUpJumpPoint = jumpLineD;
                rightUpJumpPoint = jumpLineD;
            }
        }
        else if (direction == LEFT) {
            rightUpJumpPoint = jumpLineD;
            int i = jumpLineD;
            leftUpJumpPoint = i;
            while (i <= jumpLineD + 30 && my_road[i].connected[j_mid[i]].left >= left_side[i] + 5) {
                if (my_road[i].connected[j_mid[i]].left >= my_road[leftUpJumpPoint].connected[j_mid[leftUpJumpPoint]].left) {
                    leftUpJumpPoint = i;
                }

                i++;
            }

        }
        else if (direction == RIGHT) {
            leftUpJumpPoint = jumpLineD;
            int i = jumpLineD;
            rightUpJumpPoint = i;
            while (i <= jumpLineD + 30 && my_road[i].connected[j_mid[i]].right <= right_side[i] - 5) {
                if (my_road[i].connected[j_mid[i]].right <= my_road[rightUpJumpPoint].connected[j_mid[rightUpJumpPoint]].right) {
                    rightUpJumpPoint = i;
                }

                i++;
            }
        }



        for (int i = NEAR_LINE; i >= 1; i--) {
            left_line[i] = my_road[i].connected[j_mid[i]].left;
            right_line[i] = my_road[i].connected[j_mid[i]].right;
            double kl = calculate_slope_struct(leftUpJumpPoint - 15, leftUpJumpPoint - 1, j_mid, LEFT);
            if (leftUpJumpPoint <= i) {
                left_line[i] = kl * (i - leftUpJumpPoint) + my_road[leftUpJumpPoint].connected[j_mid[leftUpJumpPoint]].left;
            }
            double kr = calculate_slope_struct(rightUpJumpPoint - 15, rightUpJumpPoint - 1, j_mid, RIGHT);
            if (rightUpJumpPoint <= i) {
                right_line[i] = kr * (i - rightUpJumpPoint) + my_road[rightUpJumpPoint].connected[j_mid[rightUpJumpPoint]].right;
            }
            // ////printf("1\n");
        }


    }
}
////////////////////////////////////////////
//功能：出十字
//输入：
//输出：
//备注：
///////////////////////////////////////////
void cross_over() {
    //////printf("\n出十字:\n");
    int jumpLine = 119;
    for (int i = NEAR_LINE - 2; i >= 60; i--) {

        if ((right_line[i] - left_line[i]) - (right_line[i + 1] - left_line[i + 1]) < -9 && (right_line[i] - left_line[i]) - (right_line[i + 2] - left_line[i + 2]) < -9
            && abs((right_line[i] - left_line[i]) - (right_line[i - 1] - left_line[i - 1])) <= 6 && abs((right_line[i] - left_line[i]) - (right_line[i - 2] - left_line[i - 2])) <= 6
            && right_line[i] < right_side[i] - 1 && left_line[i] > left_side[i] + 1
            ) {
            jumpLine = i;
            break;
        }
    }
    //////printf("跳变行：%d\n", jumpLine);
    uint8_t mid[CAMERA_H];
    for (int i = jumpLine - 1; i >= jumpLine - 20; i--) {
        mid[i] = (left_line[i] + right_line[i]) / 2;
    }
    int direction;
    double kmid = calculate_slope_uint(jumpLine - 20, jumpLine - 1, mid);
    double kRange = 0.5;
    if (fabs(kmid) <= kRange) {
        direction = 0;
    }
    else if (kmid > kRange) {
        direction = LEFT;
    }
    else if (kmid < -kRange) {
        direction = RIGHT;
    }
    //////printf("方向:%d\n", direction);
    int flag = 0;
    if (direction == 0) {
        if (linear_judgement(jumpLine - 15, jumpLine - 2, left_line) < 15 && linear_judgement(jumpLine - 15, jumpLine - 2, right_line) < 15
            && fabs(calculate_slope_uint(jumpLine - 15, jumpLine - 2, left_line) - calculate_slope_uint(jumpLine - 15, jumpLine - 2, right_line)) < 0.3
            && jumpLine >= 90 && jumpLine <= NEAR_LINE
            ) {
            flag = 1;
        }
    }
    else if (direction == 1) {
        if (linear_judgement(jumpLine - 12, jumpLine + 1, left_line) < 15 && linear_judgement(jumpLine - 15, jumpLine - 2, right_line) < 15
            && fabs(calculate_slope_uint(jumpLine - 12, jumpLine + 1, left_line) - calculate_slope_uint(jumpLine - 15, jumpLine - 2, right_line)) < 0.3
            && jumpLine >= 90 && jumpLine <= NEAR_LINE
            ) {
            flag = 1;
        }
    }
    else if (direction == -1) {
        if (linear_judgement(jumpLine - 12, jumpLine + 1, right_line) < 15 && linear_judgement(jumpLine - 15, jumpLine - 2, left_line) < 15
            && fabs(calculate_slope_uint(jumpLine - 12, jumpLine + 1, right_line) - calculate_slope_uint(jumpLine - 15, jumpLine - 2, left_line)) < 0.3
            && jumpLine >= 90 && jumpLine <= NEAR_LINE
            ) {
            flag = 1;
        }
    }
    if (flag == 1) {
        state = 0;
    }
    if (my_road[55].white_num == 0) {
        state = stateStart;
    }

}

////////////////////////////////////////////
//功能：环岛对应参数汇总
//输入：
//输出：
//备注：
///////////////////////////////////////////
int param_island(int state) {
    if (state == 80) {
        if (IslandRadius == 50) {
            return 58;
        }
        else if (IslandRadius == 60) {
            return 57;
        }
        else if (IslandRadius == 70) {
            return 56;
        }
        else if (IslandRadius == 80) {
            return 55;
        }
        else if (IslandRadius == 90) {
            return 54;
        }
        else if (IslandRadius == 100) {
            return 53;
        }
    }
    else if(state == 90) {
        if (islandWhere == LEFT) {
            if (IslandRadius == 50) {
                return 58;
            }
            else if (IslandRadius == 60) {
                return 57;
            }
            else if (IslandRadius == 70) {
                return 56;
            }
            else if (IslandRadius == 80) {
                return 55;
            }
            else if (IslandRadius == 90) {
                return 54;
            }
            else if (IslandRadius == 100) {
                return 53;
            }
        }
        else if (islandWhere == RIGHT) {
            if (IslandRadius == 50) {
                return 58;
            }
            else if (IslandRadius == 60) {
                return 57;
            }
            else if (IslandRadius == 70) {
                return 56;
            }
            else if (IslandRadius == 80) {
                return 55;
            }
            else if (IslandRadius == 90) {
                return 54;
            }
            else if (IslandRadius == 100) {
                return 53;
            }
        }

    }
}

////////////////////////////////////////////
//功能：环岛回环赛道记忆
//输入：
//输出：
//备注：
///////////////////////////////////////////
int memory_IT() {
    if(num_island == -1){
        return 1;
    }
    if (num_first_T == num_island) {
        num_first_T = -1;
    }
    if (count_num_IT % (num_island + 1) == (num_first_T + 1)) {
        return -1;
    }
    else {
        return 1;
    }


}

/////////////////////////////////////////////
//功能：进T字路口或者环岛
//输入：
//输出：
//备注：
///////////////////////////////////////////
void T_island_in_start() {
    ////////printf("\n环岛回环开始：\n");
    int flag = 0;
    int sumDL = 0;
    int sumDR = 0;
    double aveDL = 0;
    double aveDR = 0;
    for (int i = NEAR_LINE; i > 20; i--) {
        sumDL += left_line[i] - left_line[i - 1];
        sumDR += right_line[i] - right_line[i - 1];
        aveDL = (double)sumDL / (NEAR_LINE - i + 1);
        aveDR = (double)sumDR / (NEAR_LINE - i + 1);
        if (right_line[i] - right_line[i - 1] < aveDL - 3 && right_line[i] - right_line[i - 2] < aveDL - 3
            && abs(left_line[i - 1] - left_line[i] )<= 2 && abs(left_line[i - 2] - left_line[i]) <= 2) {
            TIslandWhere = RIGHT;
            break;
        }
        if (left_line[i] - left_line[i - 1] > aveDL + 3 && left_line[i] - left_line[i - 2] > aveDR + 3
            && abs(right_line[i - 1] - right_line[i]) <= 2 && abs(right_line[i - 2] - right_line[i]) <= 2) {
            TIslandWhere = LEFT;
            break;
        }
    }

    ////////printf("环岛回环左右=%d\n", TIslandWhere);
    if (TIslandWhere == RIGHT) {
        //左侧是直道
        uint8_t left_road[CAMERA_H];
        uint8_t j_mid[CAMERA_H];
        for (int i = NEAR_LINE; i >= 2; i--) {
            j_mid[i] = j_continue[i];
            for (int j = 1; j <= my_road[i].white_num; j++) {
                if (abs(my_road[i].connected[j].left - my_road[i + 1].connected[j_mid[i + 1]].left) < abs(my_road[i].connected[j_mid[i]].left - my_road[i + 1].connected[j_mid[i + 1]].left)
                    && my_road[i].connected[j].width > 20) {
                    j_mid[i] = j;

                }

            }
            left_road[i] = my_road[i].connected[j_mid[i]].left;
        }
        //  ////////printf("dv=%f\n", linear_judgement(70, 90, left_road));
        int downPoint = 119;
        if (calculate_slope_struct(80, 95, j_mid, LEFT) <= 0.1) {
            for (int i = NEAR_LINE - 1; i >= 30; i--) {
                if (my_road[i - 1].connected[j_mid[i - 1]].right - my_road[i].connected[j_mid[i]].right > 6
                    && my_road[i - 2].connected[j_mid[i - 2]].right - my_road[i].connected[j_mid[i]].right > 6
                    && abs(my_road[i + 1].connected[j_mid[i + 1]].right - my_road[i].connected[j_mid[i]].right) <= 4
                    && abs(my_road[i + 2].connected[j_mid[i + 2]].right - my_road[i].connected[j_mid[i]].right) <= 4
                    && my_road[i].connected[j_mid[i]].width < 58
                    && my_road[i + 1].connected[j_mid[i + 1]].width < 58
                    && linear_judgement_struct(i,i+10,j_mid,RIGHT) < 10
                    ) {
                    downPoint = i;
                    break;
                }
            }

        }
        else {
            int num = NEAR_LINE - 2;
            downPoint = num;
            while (num >= 30 && my_road[num].connected[j_mid[num]].right <= right_side[num] - 1
                && abs(my_road[num - 1].connected[j_mid[num - 1]].right - my_road[num].connected[j_mid[num]].right) <= 4
                && abs(my_road[num + 1].connected[j_mid[num + 1]].right - my_road[num].connected[j_mid[num]].right) <= 4
                ) {
                if (my_road[num].connected[j_mid[num]].right <= my_road[downPoint].connected[j_mid[downPoint]].right

                    ) {
                    downPoint = num;
                }

                num--;
            }
        }
        ////////printf("环岛回环下突变点=%d\n", downPoint);
        //由于T路的特征，不一定都是直线，另一边绝对不能是边界，不然与十字说不清
        double kl1;
        double kl2;
        double kl3;
        if (downPoint >= 105) {
            kl1 = calculate_slope_struct(50, 65, j_mid, LEFT);
            kl2 = calculate_slope_struct(70, 85, j_mid, LEFT);
            kl3 = calculate_slope_struct(90, 105, j_mid, LEFT);
        }
        else {
            kl1 = calculate_slope_struct(40, 55, j_mid, LEFT);
            kl2 = calculate_slope_struct(60, 80, j_mid, LEFT);
            kl3 = calculate_slope_struct(85, 100, j_mid, LEFT);
        }
        //double kl4 = calculate_slope_struct(85, 100, j_mid, LEFT);
        int sumL = 0;
        int sumD = 0;
        for (int i = 30; i <= 110; i++) {
            if (my_road[i].connected[j_mid[i]].left <= left_side[i] + 3) {
                sumL++;
            }
        }
        for (int i = NEAR_LINE; i >= 105; i--) {
            if (my_road[i].connected[j_mid[i]].right >= right_side[i]) {
                sumD++;
            }
        }
        int Break = 0;
        for (int i = 50; i <= 100; i++) {
            if (abs(my_road[i].connected[j_mid[i]].left - my_road[i + 2].connected[j_mid[i + 2]].left) >= 8) {
                Break = 1;
            }
        }
        ////////printf("左边界的个数（区分环岛回环与两点十字）= %d\n", sumL);
        if (sumL <= 25 && Break == 0) {


            if (fabs(calculate_slope_struct(downPoint - 7, downPoint + 7, j_mid, LEFT) - calculate_slope_struct(downPoint + 1, downPoint + 15, j_mid, RIGHT)) < 0.5
                && downPoint < NEAR_LINE - 2 && 55 <= downPoint) {
                //寻找上方窄道
                int upPoint = 119;
                double kr = calculate_slope_struct(downPoint + 1, downPoint + 15, j_mid, RIGHT);
                int rightRoad[CAMERA_H];
                rightRoad[downPoint + 1] = my_road[downPoint + 1].connected[j_mid[downPoint + 1]].right + 15;
                int rightside[CAMERA_W];

                for (int i = downPoint - 10; i >= 2; i--) {
                    rightRoad[i] = kr * (i - downPoint) + my_road[downPoint].connected[j_mid[downPoint]].right + 15;
                    if (rightRoad[i] > right_side[i]) {
                        rightRoad[i] = right_side[i];
                    }
                    //    IMG[i][rightRoad[i]] = purple;
                    if ((my_road[i + 1].connected[j_mid[i + 1]].right >= rightRoad[i + 1] && my_road[i].connected[j_mid[i]].right < rightRoad[i])
                        || (my_road[i + 1].connected[j_mid[i + 1]].right > rightRoad[i + 1] && my_road[i].connected[j_mid[i]].right <= rightRoad[i])) {
                        upPoint = i;
                        break;
                    }

                }

                ////////printf("上端窄赛道突变点=%d\n", upPoint);
                ////////printf("左端赛道线性=%f\n", linear_judgement(40, 90, left_road));
                if (upPoint < downPoint && linear_judgement(30, 90, left_road) <= 60 && linear_judgement_struct(downPoint - 10,downPoint+5,j_mid,RIGHT) > 18
                        && fabs(calculate_slope_struct(30,50,j_mid,LEFT) - calculate_slope_struct(60,80,j_mid,LEFT)) < 0.3) {
                    int sumU = 0;
                    for (int i = upPoint; i >= upPoint - 30 && i >= 0; i--) {
                        if (my_road[i].connected[j_mid[i]].width < my_road[downPoint + 2].connected[j_mid[downPoint + 2]].width + 15) {
                            sumU++;
                        }

                    }
                    ////////printf("窄赛道数量=%d\n", sumU);
                    if (sumU > 5) {
                        state = stateTIslandIn;
                    }
                    else {
                        TIslandWhere = 0;
                    }
                }


            }
        }



    }
    else if (TIslandWhere == LEFT) {
        uint8_t j_mid[CAMERA_H];
        uint8_t right_road[CAMERA_H];
        for (int i = NEAR_LINE; i >= 2; i--) {
            j_mid[i] = j_continue[i];
            for (int j = 1; j <= my_road[i].white_num; j++) {
                if (abs(my_road[i].connected[j].right - my_road[i + 1].connected[j_mid[i + 1]].right) < abs(my_road[i].connected[j_mid[i]].right - my_road[i + 1].connected[j_mid[i + 1]].right)
                    && my_road[i].connected[j].width > 20) {
                    j_mid[i] = j;

                }

            }
            right_road[i] = my_road[i].connected[j_mid[i]].right;

        }
        //////////printf("dv=%f\n", linear_judgement(70, 90, left_road));
        int downPoint = 119;
        if (calculate_slope_struct(80, 95, j_mid, RIGHT) >= 0) {
            for (int i = NEAR_LINE - 1; i >= 30; i--) {
                if (my_road[i - 1].connected[j_mid[i - 1]].left - my_road[i].connected[j_mid[i]].left < -6
                    && abs(my_road[i + 1].connected[j_mid[i + 1]].left - my_road[i].connected[j_mid[i]].left) <= 4
                    && my_road[i].connected[j_mid[i]].width <= 58
                    && my_road[i + 1].connected[j_mid[i + 1]].width <= 58
                    && linear_judgement_struct(i,i+10,j_mid,-RIGHT) < 10
                    ) {
                    downPoint = i;
                    break;
                }
            }

        }
        else {

            int num = NEAR_LINE - 2;
            downPoint = num;
            while (num >= 30 && my_road[num].connected[j_mid[num]].left >= left_side[num] + 1
                && abs(my_road[num - 1].connected[j_mid[num - 1]].left - my_road[num].connected[j_mid[num]].left) <= 4
                && abs(my_road[num + 1].connected[j_mid[num + 1]].left - my_road[num].connected[j_mid[num]].left) <= 4
                ) {
                if (my_road[num].connected[j_mid[num]].left >= my_road[downPoint].connected[j_mid[downPoint]].left - 1

                    ) {
                    downPoint = num;
                }

                num--;
            }
        }
        ////////printf("环岛回环下突变点=%d\n", downPoint);
        double kl1;
        double kl2;
        double kl3;
        if (downPoint >= 105) {
            kl1 = calculate_slope_struct(50, 65, j_mid, RIGHT);
            kl2 = calculate_slope_struct(70, 85, j_mid, RIGHT);
            kl3 = calculate_slope_struct(90, 105, j_mid, RIGHT);
        }
        else {
            kl1 = calculate_slope_struct(40, 55, j_mid, RIGHT);
            kl2 = calculate_slope_struct(60, 80, j_mid, RIGHT);
            kl3 = calculate_slope_struct(85, 100, j_mid, RIGHT);
        }

        //double kl4 = calculate_slope_struct(95, 110, j_mid, RIGHT);
        int sumR = 0;
        int sumD = 0;
        int Break = 0;
        for (int i = 50; i <= 100; i++) {
            if (abs(my_road[i].connected[j_mid[i]].right - my_road[i + 2].connected[j_mid[i + 2]].right) >= 8) {
                Break = 1;
            }
        }

        ////////printf("右边界的个数（区分环岛回环与两点十字）= %d\n", sumR);
        for (int i = 30; i <= 110; i++) {
            if (my_road[i].connected[j_mid[i]].right >= right_side[i] - 3) {
                sumR++;
            }
        }
        for (int i = NEAR_LINE; i >= 100; i--) {
            if (my_road[i].connected[j_mid[i]].left <= left_side[i]) {
                sumD++;
            }
        }
        //////////printf("dv=%f\n", linear_judgement(40, 90, right_road));
        if (sumR <= 20  && Break == 0) {

            //////////printf("dp=%d", downPoint);
            //下方是直道，控制一下
            if (fabs(calculate_slope_struct(downPoint - 7, downPoint + 7, j_mid, RIGHT) - calculate_slope_struct(downPoint + 1, downPoint + 15, j_mid, LEFT)) < 0.5
                && downPoint < NEAR_LINE - 2 && 55 <= downPoint) {
                //寻找上方圆环
                int upPoint = 119;
                double kl = calculate_slope_struct(downPoint + 1, downPoint + 15, j_mid, LEFT);
                int leftRoad[CAMERA_H];
                leftRoad[downPoint + 1] = my_road[downPoint + 1].connected[j_mid[downPoint + 1]].left - 15;
                for (int i = downPoint; i >= downPoint - 70 && i>=0; i--) {

                    leftRoad[i] = kl * (i - downPoint) + my_road[downPoint].connected[j_mid[downPoint]].left - 15;
                    if (leftRoad[i] < left_side[i]) {
                        leftRoad[i] = left_side[i];
                    }
                    //   IMG[i][leftRoad[i]] = purple;
                    if ((my_road[i + 1].connected[j_mid[i + 1]].left <= leftRoad[i + 1] && my_road[i].connected[j_mid[i]].left > leftRoad[i])
                        || (my_road[i + 1].connected[j_mid[i + 1]].left < leftRoad[i + 1] && my_road[i].connected[j_mid[i]].left >= leftRoad[i])) {
                        upPoint = i;
                        break;
                    }
                }
                ////////printf("上端窄赛道突变点=%d\n", upPoint);
                ////////printf("右端赛道线性=%f\n", linear_judgement(40, 90, right_road));
                //////////printf("u=%d,d=%d\n", upPoint, downPoint);
                //根据找到的点，确定周围环岛点
                if (upPoint < downPoint && linear_judgement(30, 90, right_road) <= 60 && linear_judgement_struct(downPoint - 10,downPoint+5,j_mid,-RIGHT) > 18
                        && fabs(calculate_slope_struct(30,50,j_mid,RIGHT) - calculate_slope_struct(60,80,j_mid,RIGHT)) < 0.3) {
                    int sumU = 0;
                    for (int i = upPoint; i >= upPoint - 30 && i >= 0; i--) {
                        if (my_road[i].connected[j_mid[i]].width < my_road[downPoint + 2].connected[j_mid[downPoint + 2]].width + 15) {
                            sumU++;
                        }

                    }
                    ////////printf("窄赛道数量=%d\n", sumU);
                    if (sumU > 5) {
                        state = stateTIslandIn;
                    }
                    else {
                        TIslandWhere = 0;
                    }
                }

            }
        }
    }
}

////////////////////////////////////////////
//功能：进T字路口或者环岛补线
//输入：
//输出：
//备注：
///////////////////////////////////////////
void design_T_island_in() {

    uint8_t ctrl_distance=45;
    if (TIslandWhere == RIGHT) {

        int leftRoad[CAMERA_H];
        uint8_t j_mid[CAMERA_H];
        for (int i = NEAR_LINE; i >= 2; i--) {
            j_mid[i] = j_continue[i];
            for (int j = 1; j <= my_road[i].white_num; j++) {
                if (abs(my_road[i].connected[j].left - my_road[i + 1].connected[j_mid[i + 1]].left) < abs(my_road[i].connected[j_mid[i]].left - my_road[i + 1].connected[j_mid[i + 1]].left)
                    && my_road[i].connected[j].width > 15) {
                    j_mid[i] = j;
                    //  break;
                }

            }
            leftRoad[i] = my_road[i].connected[j_mid[i]].left;
        }



        uint8_t xMin = my_road[110].connected[j_mid[110]].right, yMin = 110;
        for (int i = 110; i > 2; i--) {
            if (xMin >= my_road[i].connected[j_mid[i]].right) {
                yMin = i;
                xMin = my_road[i].connected[j_mid[i]].right;
            }
        }

        double k = calculate_slope(80, 100, leftRoad);

        for (int i = 110; i >= 2; i--) {
            if (i >= 20) {
                right_line[i] = leftRoad[i] + ctrl_distance;
            }
            else {
                right_line[i] = my_road[i].connected[j_mid[i]].right;
            }
            //xMin - leftRoad[yMin] - 20;
            left_line[i] = leftRoad[i];
        }
    }
    else if (TIslandWhere == LEFT) {
        uint8_t j_mid[CAMERA_H];
        int rightRoad[CAMERA_H];
        j_mid[NEAR_LINE] = j_continue[NEAR_LINE];
        rightRoad[NEAR_LINE] = right_line[NEAR_LINE];
        for (int i = NEAR_LINE  - 1; i >= 2; i--) {
            j_mid[i] = j_continue[i];
            for (int j = 1; j <= my_road[i].white_num; j++) {
                if (abs(my_road[i].connected[j].right - my_road[i + 1].connected[j_mid[i + 1]].right) < abs(my_road[i].connected[j_mid[i]].right - my_road[i + 1].connected[j_mid[i + 1]].right)
                    && my_road[i].connected[j].width > 10) {
                    j_mid[i] = j;
                    //  break;
                }
            }
            rightRoad[i] = my_road[i].connected[j_mid[i]].right;
        }

        uint8_t xMin = my_road[110].connected[j_mid[110]].left, yMin = 110;
        for (int i = 110; i > 2; i--) {
            if (xMin <= my_road[i].connected[j_mid[i]].left) {
                yMin = i;
                xMin = my_road[i].connected[j_mid[i]].left;
            }
            if (my_road[i - 1].white_num == 0) {
                break;
            }
        }

        double k = calculate_slope(80, 100, rightRoad);

        for (int i = 110; i >= 2; i--) {
            if (i >= 20) {
                left_line[i] = rightRoad[i] - ctrl_distance;
            }
            else {
                left_line[i] = my_road[i].connected[j_mid[i]].left;
            }
            //+ xMin - rightRoad[yMin] ;
            right_line[i] = rightRoad[i];
        }
    }
}

////////////////////////////////////////////
//功能：环岛大小的判断
//输入：
//输出：
//备注：
///////////////////////////////////////////
void island_radius() {
    if (TIslandWhere == RIGHT) {
        int rightRoad[CAMERA_H];
        uint8_t j_mid[CAMERA_H];
        for (int i = NEAR_LINE; i >= 2; i--) {
            j_mid[i] = j_continue[i];
            for (int j = 1; j <= my_road[i].white_num; j++) {
                if (abs(my_road[i].connected[j].left - my_road[i + 1].connected[j_mid[i + 1]].left) < abs(my_road[i].connected[j_mid[i]].left - my_road[i + 1].connected[j_mid[i + 1]].left)
                    && my_road[i].connected[j].width > 15) {
                    j_mid[i] = j;
                    //  break;
                }

            }
            rightRoad[i] = my_road[i].connected[j_mid[i]].right;
        }
        int downPoint = 119;
        if (calculate_slope_struct(80, 95, j_mid, LEFT) <= 0) {
            for (int i = NEAR_LINE - 1; i >= 30; i--) {
                if (my_road[i - 1].connected[j_mid[i - 1]].right - my_road[i].connected[j_mid[i]].right > 4
                    && abs(my_road[i + 1].connected[j_mid[i + 1]].right - my_road[i].connected[j_mid[i]].right) <= 2
                    && my_road[i].connected[j_mid[i]].width < 40
                    && my_road[i + 1].connected[j_mid[i + 1]].width < 40
                    ) {
                    downPoint = i;
                    break;
                }
            }

        }
        else {
            int num = 110;
            downPoint = num;
            while (num >= 40 && my_road[num].connected[j_mid[num]].right <= right_side[num] - 1
                && abs(my_road[num - 1].connected[j_mid[num - 1]].right - my_road[num].connected[j_mid[num]].right) <= 4
                && abs(my_road[num + 1].connected[j_mid[num + 1]].right - my_road[num].connected[j_mid[num]].right) <= 4
                ) {
                if (my_road[num].connected[j_mid[num]].right <= my_road[downPoint].connected[j_mid[downPoint]].right + 1

                    ) {
                    downPoint = num;
                }

                num--;
            }
        }
        //uint8_t xMin = my_road[downPoint - 3].connected[j_mid[downPoint - 3]].right, yMin = downPoint - 3;
        if (downPoint == 119) {
            downPoint = 111;
        }
        uint8_t xMin = my_road[downPoint - 3].connected[j_mid[downPoint - 3]].right, yMin = downPoint - 3;
        int start = 0, end = 0;
        for (int i = downPoint - 3; i >= 30; i--) {
            if (xMin >= my_road[i].connected[j_mid[i]].right
                && abs(my_road[i].connected[j_mid[i]].right - my_road[i + 1].connected[j_mid[i + 1]].right) <= 1 && abs(my_road[i].connected[j_mid[i]].right - my_road[i - 1].connected[j_mid[i - 1]].right) <= 1
                ) {

                int is = i + 1, ie = i - 1;
                while (is < i + 10 && my_road[is].connected[j_mid[is]].right == my_road[i].connected[j_mid[i]].right) {
                    is++;
                }
                while (ie > i - 10 && my_road[ie].connected[j_mid[ie]].right == my_road[i].connected[j_mid[i]].right) {
                    ie--;
                }
                int flag = 0;
                for (int j = ie; j >= ie - 7; j--) {
                    if (my_road[j].connected[j_mid[j]].right < my_road[i].connected[j_mid[i]].right) {
                        flag = 1;
                        break;
                    }
                }
                for (int j = is; j <= is + 7; j++) {
                    if (my_road[j].connected[j_mid[j]].right < my_road[i].connected[j_mid[i]].right) {
                        flag = 1;
                        break;
                    }
                }
                if (flag == 0 //&& abs(my_road[is].connected[j_mid[is]].left-my_)
                    ) {
                    yMin = i;
                    xMin = my_road[i].connected[j_mid[i]].right;
                }
            }
            if (i <= downPoint - 40 && my_road[i].connected[j_mid[i]].right >= my_road[downPoint].connected[j_mid[downPoint]].right + 8) {
                break;
            }
        }
        /*start = yMin;
        while (start <= yMin + 20 && my_road[start].connected[j_mid[start]].right == xMin) {
            start++;
        }
        yMin = (start + yMin) / 2;
        xMin = my_road[yMin].connected[j_mid[yMin]].right;*/
        int dis = 0;
        double k = calculate_slope_struct(80, 100, j_mid, LEFT);
        if (fabs(k) < 0.2 && downPoint <= 110 && yMin < downPoint - 3) {
            dis = (int)((double)(downPoint - yMin) / (sqrt(1 - k * k)));
            if (midDownDistance == 0) {
                if (1) {
                    midDownDistance += dis;
                    midTimes++;
                }
            }
            else {
                if (abs(midDownDistance - dis) <= 15) {
                    midDownDistance = (midDownDistance * midTimes + dis) / (midTimes + 1);
                    midTimes++;
                }
            }
        }
        ////////////printf("mD=%d,midTimes=%d,downPoint=%d,ymin=%d\n", midDownDistance, midTimes, downPoint, yMin);
        //  ////////////printf("mD=%d,midTimes=%d,downPoint=%d,ymin=%d\n", midDownDistance, midTimes, downPoint, yMin);


    }
    else if (TIslandWhere == LEFT) {
        uint8_t j_mid[CAMERA_H];
        int leftRoad[CAMERA_H];
        for (int i = NEAR_LINE; i >= 2; i--) {
            j_mid[i] = j_continue[i];
            for (int j = 1; j <= my_road[i].white_num; j++) {
                if (abs(my_road[i].connected[j].right - my_road[i + 1].connected[j_mid[i + 1]].right) < abs(my_road[i].connected[j_mid[i]].right - my_road[i + 1].connected[j_mid[i + 1]].right)
                    && my_road[i].connected[j].width > 10) {
                    j_mid[i] = j;
                    //  break;
                }
            }
            leftRoad[i] = my_road[i].connected[j_mid[i]].left;
        }
        int downPoint = 119;
        if (calculate_slope_struct(80, 95, j_mid, RIGHT) >= 0) {
            for (int i = NEAR_LINE - 1; i >= 30; i--) {
                if (my_road[i - 1].connected[j_mid[i - 1]].left - my_road[i].connected[j_mid[i]].left < -4
                    && abs(my_road[i + 1].connected[j_mid[i + 1]].left - my_road[i].connected[j_mid[i]].left) <= 2
                    && my_road[i].connected[j_mid[i]].width < 40
                    && my_road[i + 1].connected[j_mid[i + 1]].width < 40
                    ) {
                    downPoint = i;
                    break;
                }
            }

        }
        else {

            int num = 110;
            downPoint = num;
            while (num >= 40 && my_road[num].connected[j_mid[num]].left >= left_side[num] + 1
                && abs(my_road[num - 1].connected[j_mid[num - 1]].left - my_road[num].connected[j_mid[num]].left) <= 4
                && abs(my_road[num + 1].connected[j_mid[num + 1]].left - my_road[num].connected[j_mid[num]].left) <= 4
                ) {
                if (my_road[num].connected[j_mid[num]].left >= my_road[downPoint].connected[j_mid[downPoint]].left - 1

                    ) {
                    downPoint = num;
                }

                num--;
            }
        }

        if (downPoint == 119) {
            downPoint = 111;
        }

        uint8_t xMin = my_road[downPoint - 3].connected[j_mid[downPoint - 3]].left, yMin = downPoint - 3;
        int start = 0, end = 0;
        for (int i = downPoint - 3; i >= 20; i--) {
            if (xMin <= my_road[i].connected[j_mid[i]].left && abs(my_road[i].connected[j_mid[i]].left - my_road[i + 1].connected[j_mid[i + 1]].left) <= 1 && abs(my_road[i].connected[j_mid[i]].left - my_road[i - 1].connected[j_mid[i - 1]].left) <= 1) {
                int is = i + 1, ie = i - 1;
                while (is < i + 10 && my_road[is].connected[j_mid[is]].left == my_road[i].connected[j_mid[i]].left) {
                    is++;
                }
                while (ie > i - 10 && my_road[ie].connected[j_mid[ie]].left == my_road[i].connected[j_mid[i]].left) {
                    ie--;
                }
                int flag = 0;
                for (int j = ie; j >= ie - 7; j--) {
                    if (my_road[j].connected[j_mid[j]].left > my_road[i].connected[j_mid[i]].left) {
                        flag = 1;
                        break;
                    }
                }
                for (int j = is; j <= is + 7; j++) {
                    if (my_road[j].connected[j_mid[j]].left > my_road[i].connected[j_mid[i]].left) {
                        flag = 1;
                        break;
                    }
                }
                if (flag == 0 //&& abs(my_road[is].connected[j_mid[is]].left-my_)
                    ) {
                    yMin = i;
                    xMin = my_road[i].connected[j_mid[i]].left;
                }
            }
            if (i <= downPoint - 40 && my_road[i].connected[j_mid[i]].left <= my_road[downPoint].connected[j_mid[downPoint]].left - 8) {
                break;
            }
        }
        /*start = yMin;
        while (start <= yMin + 20 && my_road[start].connected[j_mid[start]].left == xMin) {
            start++;
        }
        yMin = (start + yMin) / 2;
        xMin = my_road[yMin].connected[j_mid[yMin]].left;*/
        int dis = 0;
        double k = calculate_slope_struct(80, 100, j_mid, RIGHT);
        if (fabs(calculate_slope_struct(80, 100, j_mid, RIGHT)) < 0.2 && downPoint <= 110 && yMin < downPoint - 3) {
            dis = (int)((double)(downPoint - yMin) / (sqrt(1 - k * k)));
            if (midDownDistance == 0) {
                if (1) {
                    midDownDistance += dis;
                    midTimes++;
                }
            }
            else {
                if (abs(midDownDistance - dis) <= 15) {
                    midDownDistance = (midDownDistance * midTimes + dis) / (midTimes + 1);
                    midTimes++;
                }
            }
        }

        ////////////printf("mD=%d,midTimes=%d,downPoint=%d,ymin=%d\n", midDownDistance, midTimes, downPoint, yMin);

    }


}


////////////////////////////////////////////
//功能：进T字路口或者环岛
//输入：
//输出：
//备注：way == -1回环 way == 1 环岛
///////////////////////////////////////////
void T_or_island() {

    int sumD = 0;
    int sumU = 0;
    for (int i = NEAR_LINE; i >= 80; i--) {
        //  //////////printf("%d=%d", i, right_line[i] - left_line[i]);
        if (right_line[i] - left_line[i] >= 60 || ((left_line[i] <= left_side[i] + 1 && right_line[i] < right_side[i] - 1) || (left_line[i] > left_side[i] + 1 && right_line[i] >= right_side[i] - 1))) {
            //  //////////printf(",%d", i);
            sumD++;
        }
        //  //////////printf("\n");
    }

    int sumL = 0;
    for (int i = NEAR_LINE - 1; i >= NEAR_LINE - 3; i--) {
        if ((right_line[i] - left_line[i] > 55) || ((left_line[i] <= left_side[i] + 1 && right_line[i] < right_side[i] - 1) || (left_line[i] > left_side[i] + 1 && right_line[i] >= right_side[i] - 1))) {
            sumL++;
        }
    }

    if (sumD > 4 && sumL >= 2 ) {
        //如果上方没有赛道，我们认为是十字回环
        if (my_road[15].white_num == 0 && memory_IT() == -1) {
            state = stateTIn;
            TWhere = TIslandWhere;
            count_num_IT++;
            //wayIT = wayIT * -1;
        }
        else {
            if (TIslandWhere == RIGHT) {
                int dside[CAMERA_H];
                uint8_t j_mid[CAMERA_H];
                for (int i = NEAR_LINE; i >= 2; i--) {
                    j_mid[i] = j_continue[i];
                    for (int j = 1; j <= my_road[i].white_num; j++) {
                        if (abs(my_road[i].connected[j].left - my_road[i + 1].connected[j_mid[i + 1]].left) < abs(my_road[i].connected[j_mid[i]].left - my_road[i + 1].connected[j_mid[i + 1]].left)
                            && my_road[i].connected[j].width > 15) {
                            j_mid[i] = j;

                        }

                    }
                    dside[i] = my_road[i].connected[j_mid[i]].right - my_road[i].connected[j_mid[i]].left;
                }

                double kl1 = calculate_slope_struct(25, 40, j_mid, LEFT);
                double kl2 = calculate_slope_struct(50, 65, j_mid, -RIGHT);
                double kl3 = calculate_slope_struct(75, 90, j_mid, -RIGHT);

                if (fabs(kl1 - kl2) < 0.3 && fabs(kl1 - kl3) < 0.3 && fabs(kl2 - kl3) < 0.3 && memory_IT() == 1) {
                    //state = stateSTIsland;
                    state = stateIslandIng;
                    islandWhere = TIslandWhere;
                    TIslandWhere = 0;
                    count_num_IT++;
                    //wayIT = wayIT * -1;
                }
                else {
                    if (memory_IT() == -1) {
                        state = stateTIn;
                        TWhere = TIslandWhere;
                        TIslandWhere = 0;
                        count_num_IT++;
                        //wayIT = wayIT * -1;
                    }
                }
            }
            else if (TIslandWhere == LEFT) {
                uint8_t j_mid[CAMERA_H];
                int dside[CAMERA_H];
                int left[CAMERA_H];
                for (int i = NEAR_LINE; i >= 2; i--) {
                    j_mid[i] = j_continue[i];
                    for (int j = 1; j <= my_road[i].white_num; j++) {
                        if (abs(my_road[i].connected[j].right - my_road[i + 1].connected[j_mid[i + 1]].right) < abs(my_road[i].connected[j_mid[i]].right - my_road[i + 1].connected[j_mid[i + 1]].right)
                            && my_road[i].connected[j].width > 15) {
                            j_mid[i] = j;

                        }

                    }
                    dside[i] = my_road[i].connected[j_mid[i]].right - my_road[i].connected[j_mid[i]].left;
                    left[i] = my_road[i].connected[j_mid[i]].left;
                }

                ////////////printf("d=%f\n", variance(60, 80, dside));
                ////////////printf("l=%f,l=%f,r=%f\n", linear_judgement(45, 75, leftside),correlation_coefficient(45,75,left),calculate_radius(45,75,leftside));
                double kl1 = calculate_slope_struct(25, 40, j_mid, RIGHT);
                double kl2 = calculate_slope_struct(50, 65, j_mid, RIGHT);
                double kl3 = calculate_slope_struct(75, 90, j_mid, RIGHT);

                // //////////printf("dk1=%f,dk2=%f,dk3=%f\n", fabs(kl1 - kl2), fabs(kl1 - kl3), fabs(kl2 - kl3));
                //外边不直是回环
                if (fabs(kl1 - kl2) < 0.3 && fabs(kl1 - kl3) < 0.3 && fabs(kl2 - kl3) < 0.3 && memory_IT() == 1) {
                    //state = stateSTIsland;
                    state = stateIslandIng;
                    islandWhere = TIslandWhere;
                    TIslandWhere = 0;
                    count_num_IT++;
                    //wayIT = wayIT * -1;
                }
                else {
                    if (memory_IT() == -1) {
                        state = stateTIn;
                        TWhere = TIslandWhere;
                        TIslandWhere = 0;
                        count_num_IT++;
                        //wayIT = wayIT * -1;
                    }
                }
            }
        }
    }
}

////////////////////////////////////////////
//功能：环岛直线补线
//输入：
//输出：
//备注：
///////////////////////////////////////////
void design_island_ing() {
    uint8_t ctrl_distance=45;
    if (islandWhere == RIGHT) {

        int leftRoad[CAMERA_H];
        uint8_t j_mid[CAMERA_H];
        j_mid[NEAR_LINE] = j_continue[NEAR_LINE];
        leftRoad[NEAR_LINE] = my_road[NEAR_LINE].connected[j_mid[NEAR_LINE]].left;
        for (int i = NEAR_LINE - 1; i >= 2; i--) {
            j_mid[i] = j_continue[i];
            for (int j = 1; j <= my_road[i].white_num; j++) {
                if (abs(my_road[i].connected[j].left - my_road[i + 1].connected[j_mid[i + 1]].left) < abs(my_road[i].connected[j_mid[i]].left - my_road[i + 1].connected[j_mid[i + 1]].left)
                    && my_road[i].connected[j].width > 15) {
                    j_mid[i] = j;
                    //  break;
                }

            }
            leftRoad[i] = my_road[i].connected[j_mid[i]].left;
        }
        uint8_t xMin = my_road[110].connected[j_mid[110]].right, yMin = 110;
        for (int i = 110; i > 2; i--) {
            if (xMin >= my_road[i].connected[j_mid[i]].right) {
                yMin = i;
                xMin = my_road[i].connected[j_mid[i]].right;
            }
        }

        double k = calculate_slope(80, 100, leftRoad);

        for (int i = 110; i >= 50; i--) {

            right_line[i] = leftRoad[i] + ctrl_distance;//xMin - leftRoad[yMin] - 20;
            left_line[i] = leftRoad[i];
        }
    }
    else if (islandWhere == LEFT) {
        uint8_t j_mid[CAMERA_H];
        int rightRoad[CAMERA_H];
        j_mid[NEAR_LINE] = j_continue[NEAR_LINE];
        rightRoad[NEAR_LINE] = my_road[NEAR_LINE].connected[j_mid[NEAR_LINE]].right;
        for (int i = NEAR_LINE; i >= 2; i--) {
            j_mid[i] = j_continue[i];
            for (int j = 1; j <= my_road[i].white_num; j++) {
                if (abs(my_road[i].connected[j].right - my_road[i + 1].connected[j_mid[i + 1]].right) < abs(my_road[i].connected[j_mid[i]].right - my_road[i + 1].connected[j_mid[i + 1]].right)
                    && my_road[i].connected[j].width > 10) {
                    j_mid[i] = j;
                    //  break;
                }
            }
            rightRoad[i] = my_road[i].connected[j_mid[i]].right;
        }

        uint8_t xMin = my_road[110].connected[j_mid[110]].left, yMin = 110;
        for (int i = 110; i > 2; i--) {
            if (xMin <= my_road[i].connected[j_mid[i]].left) {
                yMin = i;
                xMin = my_road[i].connected[j_mid[i]].left;
            }
            if (my_road[i - 1].white_num == 0) {
                break;
            }
        }

        double k = calculate_slope(80, 100, rightRoad);

        for (int i = 110; i >= 50; i--) {
            left_line[i] = rightRoad[i] - ctrl_distance;//+ xMin - rightRoad[yMin] ;
            right_line[i] = rightRoad[i];
        }
    }
}

////////////////////////////////////////////
//功能：环岛直线补线
//输入：
//输出：
//备注：
///////////////////////////////////////////
void straightT_or_island() {
    ////////////printf("环岛还是回环：\n");
    if (1) {
        if (my_road[25].white_num == 0) {
            state = stateTIn;
            TWhere = TIslandWhere;
            TIslandWhere = 0;
        }
        else {
            int sumD = 0;
            for (int i = NEAR_LINE; i >= 100; i--) {
                //////////////printf("%d=%d\n", i, right_line[i] - left_line[i]);
                if (right_line[i] - left_line[i] < 48) {
                    sumD++;
                }
            }
            ////////////printf("下方赛道偏窄的个数：%d\n", sumD);
            if (sumD >= 5) {
                if (TIslandWhere == LEFT) {
                    int sumL = 0;
                    for (int i = NEAR_LINE - 1; i >= 95; i--) {
                        if (left_line[i] - left_side[i] > 1) {
                            sumL++;
                        }
                    }
                    ////////////printf("下方未被遮挡的赛道数：sumL=%d\n", sumL);
                    ////////////printf("车头的赛道宽度：%d\n", right_line[NEAR_LINE - 1] - left_line[NEAR_LINE - 1]);
                    if (sumL > 5 && right_line[NEAR_LINE - 1] - left_line[NEAR_LINE - 1] < 55) {
                        uint8_t j_mid1[CAMERA_H];
                        uint8_t j_mid2[CAMERA_H];
                        j_mid1[NEAR_LINE] = j_continue[NEAR_LINE];
                        j_mid2[NEAR_LINE] = j_continue[NEAR_LINE];
                        uint8_t dside[CAMERA_H];
                        for (int i = NEAR_LINE - 1; i >= 2; i--) {
                            j_mid1[i] = j_continue[i];
                            for (int j = 1; j <= my_road[i].white_num; j++) {
                                if (abs(my_road[i].connected[j].right - my_road[i + 1].connected[j_mid1[i + 1]].right) < abs(my_road[i].connected[j_mid1[i]].right - my_road[i + 1].connected[j_mid1[i + 1]].right)
                                    && my_road[i].connected[j].width > 15) {
                                    j_mid1[i] = j;

                                }

                            }
                            j_mid2[i] = j_continue[i];
                            for (int j = 1; j <= my_road[i].white_num; j++) {
                                if (abs(my_road[i].connected[j].left - my_road[i + 1].connected[j_mid1[i + 1]].left) < abs(my_road[i].connected[j_mid1[i]].left - my_road[i + 1].connected[j_mid1[i + 1]].left)
                                    && my_road[i].connected[j].width > 15) {
                                    j_mid2[i] = j;

                                }
                                //  ////////////printf("rl=%d,lr=%d\n", my_road[i].connected[j_mid1[i]].left,my_road[i].connected[j_mid2[i]].right);

                            }
                            dside[i] = my_road[i].connected[j_mid1[i]].right - my_road[i].connected[j_mid2[i]].left;
                        }
                        //先确定是不是长直边
                        double kR1 = calculate_slope_struct(30, 60, j_mid1, RIGHT);
                        double kR2 = calculate_slope_struct(60, 80, j_mid1, RIGHT);
                        double kR3 = calculate_slope_struct(00, 100, j_mid1, RIGHT);
                        double kL1 = calculate_slope_struct(30, 60, j_mid2, RIGHT);
                        double kL2 = calculate_slope_struct(60, 80, j_mid2, RIGHT);
                        double kL3 = calculate_slope_struct(80, 100, j_mid2, RIGHT);
                        if (fabs(kR1 - kR2) < 0.2 && fabs(kR1 - kR3) < 0.2 && fabs(kR2 - kR3) < 0.2) {
                            //找到环岛的突变点
                            //利用宽度变化
                            //环岛第二个匝口
                            int top = 119;
                        //  ////////////printf("%f,%f\n", calculate_slope_struct(44 - 13, 44 - 1, j_mid1, LEFT), calculate_slope_struct(44 - 13, 44 - 1, j_mid1, RIGHT));
                            for (int i = 90; i >= 10; i--) {
                                if (my_road[i].connected[j_mid1[i]].left - my_road[i + 1].connected[j_mid1[i + 1]].left > 6
                                    && my_road[i].connected[j_mid1[i]].width < 50
                                    && linear_judgement_struct(i - 13, i - 1, j_mid1, LEFT) < 10
                                    && abs(my_road[i].connected[j_mid1[i]].left - my_road[i - 1].connected[j_mid1[i - 1]].left) <= 4
                                    && abs(my_road[i].connected[j_mid1[i]].left - my_road[i - 2].connected[j_mid1[i - 2]].left) <= 4
                                    ) {
                                    top = i;
                                    break;
                                }
                            }
                            int check_line = 53;
                            ////////////printf(" linear_judgement_struct(34 - 13, 34 - 1, j_mid1, LEFT)=%f \n", linear_judgement_struct(check_line - 13, check_line - 1, j_mid1, LEFT));
                            ////////////printf("找到上突变点:topY=%d,topX=%d\n", top, my_road[top].connected[j_mid1[top]].left);
                            int end = 15;

                            if (top >= end && top < 119) {
                                int sumW = 0;
                                for (int i = top + 1; i <= top + 30; i++) {
                                    if (my_road[i].connected[j_mid1[i]].width > 45) {
                                        sumW++;
                                    }
                                }
                                ////////////printf(" 第二个匝道口宽赛道的赛道数：%d", sumW);
                                if (sumW >= 6) {
                                    state = stateIslandIng;
                                    islandWhere = TIslandWhere;
                                    TIslandWhere = 0;
                                }

                            }

                            //////////////printf("top=%d\n", top);

                        }
                        else {
                            ////////////printf("402");
                            //侧边不是直道，是回环
                            state = stateTIn;
                            TWhere = TIslandWhere;
                            TIslandWhere = 0;
                        }
                    }
                }
                else if (TIslandWhere == RIGHT) {
                    int sumL = 0;
                    for (int i = NEAR_LINE - 1; i >= 105; i--) {
                        if (right_line[i] - right_side[i] < -1) {
                            sumL++;
                        }
                    }
                    ////////////printf("flag1=%d,d=%d\n", sumL, right_line[NEAR_LINE - 1] - left_line[NEAR_LINE - 1]);
                    if (sumL > 5 && right_line[NEAR_LINE - 1] - left_line[NEAR_LINE - 1] < 30) {
                        uint8_t j_mid1[CAMERA_H];
                        uint8_t j_mid2[CAMERA_H];
                        j_mid1[NEAR_LINE] = j_continue[NEAR_LINE];
                        j_mid2[NEAR_LINE] = j_continue[NEAR_LINE];
                        uint8_t dside[CAMERA_H];
                        for (int i = NEAR_LINE - 1; i >= 2; i--) {
                            j_mid1[i] = j_continue[i];
                            for (int j = 1; j <= my_road[i].white_num; j++) {
                                if (abs(my_road[i].connected[j].left - my_road[i + 1].connected[j_mid1[i + 1]].left) < abs(my_road[i].connected[j_mid1[i]].left - my_road[i + 1].connected[j_mid1[i + 1]].left)
                                    && my_road[i].connected[j].width > 15) {
                                    j_mid1[i] = j;

                                }

                            }
                            j_mid2[i] = j_continue[i];
                            for (int j = 1; j <= my_road[i].white_num; j++) {
                                if (abs(my_road[i].connected[j].right - my_road[i + 1].connected[j_mid1[i + 1]].right) < abs(my_road[i].connected[j_mid1[i]].right - my_road[i + 1].connected[j_mid1[i + 1]].right)
                                    && my_road[i].connected[j].width > 15) {
                                    j_mid2[i] = j;

                                }
                                //  ////////////printf("rl=%d,lr=%d\n", my_road[i].connected[j_mid1[i]].left,my_road[i].connected[j_mid2[i]].right);

                            }
                            dside[i] = my_road[i].connected[j_mid1[i]].right - my_road[i].connected[j_mid2[i]].left;
                        }
                        //先确定是不是长直边
                        double kR1 = calculate_slope_struct(40, 65, j_mid1, LEFT);
                        double kR2 = calculate_slope_struct(70, 85, j_mid1, LEFT);
                        double kR3 = calculate_slope_struct(90, 105, j_mid1, LEFT);
                        double kL1 = calculate_slope_struct(40, 65, j_mid2, RIGHT);
                        double kL2 = calculate_slope_struct(70, 85, j_mid2, RIGHT);
                        double kL3 = calculate_slope_struct(90, 105, j_mid2, RIGHT);
                        if (fabs(kR1 - kR2) < 0.2 && fabs(kR1 - kR3) < 0.2 && fabs(kR2 - kR3) < 0.2) {
                            //找到环岛的突变点
                            //利用宽度变化
                            //环岛第二个匝口
                            int top = 119;
                            ////////////printf("%f,%f\n", calculate_slope_struct(44 - 13, 44 - 1, j_mid1, LEFT), calculate_slope_struct(44 - 13, 44 - 1, j_mid1, RIGHT));
                            for (int i = 90; i >= 10; i--) {
                                if (my_road[i].connected[j_mid1[i]].right - my_road[i + 1].connected[j_mid1[i + 1]].right > 4
                                    && my_road[i].connected[j_mid1[i]].width < 30
                                    && fabs(calculate_slope_struct(i - 13, i - 1, j_mid1, LEFT) - calculate_slope_struct(i - 13, i - 1, j_mid1, RIGHT)) < 0.25
                                    && abs(my_road[i].connected[j_mid1[i]].left - my_road[i].connected[j_mid1[i - 1]].left) <= 2
                                    && abs(my_road[i].connected[j_mid1[i]].left - my_road[i].connected[j_mid1[i - 2]].left) <= 2
                                    ) {
                                    top = i;
                                    break;
                                }
                            }
                            ////////////printf("top=%d\n", top);
                            int end = 50;
                            if (IslandRadius < 70) {
                                end = 50;
                            }
                            else if (IslandRadius >= 70) {
                                end = 25;
                            }
                            if (top != 119) {
                                int width[CAMERA_H];
                                for (int i = top - 5; i <= top + 20; i++) {
                                    width[i] = my_road[i].connected[j_mid2[i]].width;
                                }
                                //  ////////////printf("wv=%f\n", variance(top - 5, top + 20, width));
                            }

                            if (top >= end && top < 119) {
                                int sumW = 0;
                                for (int i = top + 1; i <= top + 30; i++) {
                                    if (my_road[i].connected[j_mid1[i]].width > 35) {
                                        sumW++;
                                    }
                                }
                                if (sumW >= 6) {
                                    state = stateIslandTurn;
                                    islandWhere = TIslandWhere;
                                    TIslandWhere = 0;
                                }

                            }

                            //////////////printf("top=%d\n", top);

                        }
                        else {
                            ////////////printf("402");
                            //侧边不是直道，是回环
                            state = stateTIn;
                            TWhere = TIslandWhere;
                            TIslandWhere = 0;
                        }
                    }
                }
            }
        }

    }
    else if (0) {

    }

}

////////////////////////////////////////////
//功能：环岛拐弯
//输入：
//输出：
//备注：
///////////////////////////////////////////
void island_turn() {

    int ctrl_upPoint=islandout_up.intVal;
    if(IslandRadius == islandParam6.intVal)
    {
        ctrl_upPoint = islandout_up.intVal;
    }
    else if(IslandRadius == bigParam8.intVal)
    {
        ctrl_upPoint = bigParam1.intVal;
    }
    if (islandWhere == RIGHT) {
        uint8_t j_mid[CAMERA_H];
        for (int i = NEAR_LINE; i >= 2; i--) {
            j_mid[i] = j_continue[i];
            for (int j = 1; j <= my_road[i].white_num; j++) {
                if (abs(my_road[i].connected[j].left - my_road[i + 1].connected[j_mid[i + 1]].left) < abs(my_road[i].connected[j_mid[i]].left - my_road[i + 1].connected[j_mid[i + 1]].left)
                    && my_road[i].connected[j].width > 20) {
                    j_mid[i] = j;

                }

            }
        }

        ////////////printf("车前方赛道宽度：%d\n", right_line[NEAR_LINE - 1] - left_line[NEAR_LINE - 1]);
        if (right_line[NEAR_LINE - 1] - left_line[NEAR_LINE - 1] <= 55 || (right_line[NEAR_LINE] - right_side[NEAR_LINE] < -1 && left_line[NEAR_LINE - 1] - left_side[NEAR_LINE - 1] > 1)) {

            int upPoint = 119;
            for (int i = 10; i <= 100; i++) {
                if (my_road[i].connected[j_mid[i]].width < 55 && my_road[i + 2].connected[j_mid[i + 2]].width >= 55
                    && my_road[i - 1].connected[j_mid[i - 1]].width < 55 && my_road[i + 3].connected[j_mid[i + 3]].width >= 55
                    && my_road[i].connected[j_mid[i]].right - my_road[i + 1].connected[j_mid[i + 1]].right < -6
                    && abs(my_road[i].connected[j_mid[i]].right - my_road[i - 1].connected[j_mid[i - 1]].right) <= 3
                    && linear_judgement_struct(i - 13, i - 1, j_mid, -LEFT) < 10
                    //&& fabs(calculate_slope_struct(i - 15, i - 1, j_mid, RIGHT) - calculate_slope_struct(i - 10, i + 3, j_mid, LEFT)) < 0.25
                    ) {
                    upPoint = i;
                    break;
                }
            }
            ////////////printf("上拐点：up=%d\n", upPoint);
            if (1) {
                int up = 20;
                if(IslandRadius == 70){
                    up = 36;
                }
                else if(IslandRadius == 80)
                {
                    up = 24;
                }
                else if(IslandRadius == 50)
                {
                    up = 34;
                }
                else if(IslandRadius == 100)
                {
                    up = 62;
                }
                if (up + ctrl_upPoint <= upPoint && upPoint <= 100) {
                    state = stateIslandTurn;
                }
            }


        }


    }
    else if (islandWhere == LEFT) {
        uint8_t j_mid[CAMERA_H];
        for (int i = NEAR_LINE; i >= 2; i--) {
            j_mid[i] = j_continue[i];
            for (int j = 1; j <= my_road[i].white_num; j++) {
                if (abs(my_road[i].connected[j].right - my_road[i + 1].connected[j_mid[i + 1]].right) < abs(my_road[i].connected[j_mid[i]].right - my_road[i + 1].connected[j_mid[i + 1]].right)
                    && my_road[i].connected[j].width > 20) {
                    j_mid[i] = j;

                }

            }
        }
        ////////////printf("车前方赛道宽度：%d\n", right_line[NEAR_LINE - 1] - left_line[NEAR_LINE - 1]);
        if (right_line[NEAR_LINE - 1] - left_line[NEAR_LINE - 1] <= 55 || (right_line[NEAR_LINE] - right_side[NEAR_LINE] < -1 && left_line[NEAR_LINE - 1] - left_side[NEAR_LINE - 1] > 1)) {
            int upPoint = 119;
            for (int i = 10; i <= 100; i++) {
                if (my_road[i].connected[j_mid[i]].width < 55 && my_road[i + 2].connected[j_mid[i + 2]].width >= 55
                    && my_road[i - 1].connected[j_mid[i - 1]].width < 55 && my_road[i + 3].connected[j_mid[i + 3]].width >= 55
                    && my_road[i].connected[j_mid[i]].left - my_road[i + 1].connected[j_mid[i + 1]].left > 6
                    && abs(my_road[i].connected[j_mid[i]].left - my_road[i - 1].connected[j_mid[i - 1]].left) <= 3
                    && linear_judgement_struct(i - 13, i - 1,j_mid,LEFT) < 10
                    //&& fabs(calculate_slope_struct(i - 15,i - 1,j_mid,LEFT)- calculate_slope_struct(i - 10, i + 3, j_mid, RIGHT)) < 0.25
                    ) {
                    upPoint = i;
                    break;
                }
            }
            ////////////printf("上拐点：up=%d\n", upPoint);
            if (1) {
                int up = 20;
                if(IslandRadius == 70){
                    up = 36;
                }
                else if(IslandRadius == 80)
                {
                    up = 24;
                }
                else if(IslandRadius == 50)
                {
                    up = 34;
                }
                else if(IslandRadius == 100)
                {
                    up = 62;
                }
                if (up + ctrl_upPoint<= upPoint && upPoint < 100) {
                    state = stateIslandTurn;
                }
            }

        }


    }

}
////////////////////////////////////////////
//功能：环岛拐弯补线
//输入：
//输出：
//备注：
///////////////////////////////////////////
void design_island_turn() {
    double dk = 0.3;
    double ctrl_dkRight = islandParam1.floatVal, ctrl_dkLeft = design_island_k.floatVal;

    if(IslandRadius == islandParam6.intVal)
    {
        ctrl_dkRight = islandParam1.floatVal;
        ctrl_dkLeft = design_island_k.floatVal;
    }

    else if(IslandRadius == bigParam8.intVal)
    {
        ctrl_dkRight = bigParam3.floatVal;
        ctrl_dkLeft = bigParam2.floatVal;
    }
    if (islandWhere == RIGHT) {

        uint8_t j_mid[CAMERA_H];
        uint8_t j_mid2[CAMERA_H];
        for (int i = NEAR_LINE - 1; i >= 2; i--) {
            j_mid[i] = j_continue[i];
            j_mid2[i] = j_continue[i];
            for (int j = 1; j <= my_road[i].white_num; j++) {
                if (abs(my_road[i].connected[j].left - my_road[i + 1].connected[j_mid[i + 1]].left) < abs(my_road[i].connected[j_mid[i]].left - my_road[i + 1].connected[j_mid[i + 1]].left)
                    && my_road[i].connected[j].width > 10) {
                    j_mid[i] = j;

                }
                if (abs(my_road[i].connected[j].right - my_road[i + 1].connected[j_mid2[i + 1]].right) < abs(my_road[i].connected[j_mid2[i]].right - my_road[i + 1].connected[j_mid2[i + 1]].right)
                    && my_road[i].connected[j].width > 10) {
                    j_mid2[i] = j;

                }
            }
        }
        int way = 2;


        if (way == 1) {
            //固定打角
            double k = (double)(10 - ((NEAR_LINE - 5))) / (right_side[10] - left_line[(NEAR_LINE - 5)]) - dk;

            for (int i = (NEAR_LINE - 5); i >= 2; i--) {
                left_line[i] = k * (i - ((NEAR_LINE - 5))) + left_line[(NEAR_LINE - 5)];
                right_line[i] = right_side[i];
            }
        }
        else if (way == 2) {
            int upPoint = 119;
            int road_width = 45;
            int jump = 15;
            if (last_rightupPoint == 0)
            {
                for (int i = 105; i >= 30; i--) {
                    if (
                        (abs(my_road[i].connected[j_mid[i]].width - road_width) <= 5
                            && abs(my_road[i - 1].connected[j_mid[i - 1]].width - road_width) <= 5
                            && abs(my_road[i - 2].connected[j_mid[i - 2]].width - road_width) <= 5
                            && my_road[i + 1].connected[j_mid[i + 1]].width - road_width >= 10)
                        && j_mid[i] <= 1
                        || (my_road[i].connected[j_mid[i]].width < 60 && my_road[i + 2].connected[j_mid[i + 2]].width >= 60
                            && my_road[i - 1].connected[j_mid[i - 1]].width < 60 && my_road[i + 3].connected[j_mid[i + 3]].width >= 60

                            && my_road[i + 1].connected[j_mid[i + 1]].right - my_road[i].connected[j_mid[i]].right > 10
                            && my_road[i + 2].connected[j_mid[i + 2]].right - my_road[i].connected[j_mid[i]].right  > 10
                            && abs(my_road[i].connected[j_mid[i]].right - my_road[i - 1].connected[j_mid[i - 1]].right) <= 5
                            && abs(my_road[i - 1].connected[j_mid[i - 1]].right - my_road[i - 2].connected[j_mid[i - 2]].right) <= 5)

                        //&& my_road[i].connected[j_mid[i]].left != my_road[i].connected[j_mid2[i]].left
                        ) {
                        upPoint = i;
                        last_rightupPoint = upPoint;
                        break;
                    }
                }
            }
            else if (last_rightupPoint <= 85)
            {
                int startpoint = last_rightupPoint - jump;
                int lastpoint = last_rightupPoint + jump;
                if (lastpoint > 105) lastpoint = 105;
                for (int i = lastpoint; i >= startpoint; i--) {
                    if (
                        (abs(my_road[i].connected[j_mid[i]].width - road_width) <= 5
                            && abs(my_road[i - 1].connected[j_mid[i - 1]].width - road_width) <= 5
                            && abs(my_road[i - 2].connected[j_mid[i - 2]].width - road_width) <= 5
                            && my_road[i + 1].connected[j_mid[i + 1]].width - road_width >= 10)
                        && j_mid[i] <= 1
                        || (my_road[i].connected[j_mid[i]].width < 60 && my_road[i + 2].connected[j_mid[i + 2]].width >= 60
                            && my_road[i - 1].connected[j_mid[i - 1]].width < 60 && my_road[i + 3].connected[j_mid[i + 3]].width >= 60

                            && my_road[i + 1].connected[j_mid[i + 1]].right - my_road[i].connected[j_mid[i]].right > 10
                            && my_road[i + 2].connected[j_mid[i + 2]].right - my_road[i].connected[j_mid[i]].right  > 10
                            && abs(my_road[i].connected[j_mid[i]].right - my_road[i - 1].connected[j_mid[i - 1]].right) <= 5
                            && abs(my_road[i - 1].connected[j_mid[i - 1]].right - my_road[i - 2].connected[j_mid[i - 2]].right) <= 5)

                        //&& my_road[i].connected[j_mid[i]].left != my_road[i].connected[j_mid2[i]].left
                        ) {
                        upPoint = i;
                        break;
                    }
                }


                if (upPoint == 119)
                {
                    float k = calculate_slope_uint(60, 100, left_line);
                 //   ////printf(" k = %f\n", k);
                    if (k < -0.15)
                    {
                        int count = 0;
                        for (int j = 109; j >= 89; j--)
                        {
                            if (right_line[j] = right_side[j]) count++;
                        }
                        if (count > 10)
                        {
                            int startPoint = 109;
                            for (int i = 109; i >= 50; i--)
                            {
                                if (right_line[i] <= right_side[i] - 3
                                    && right_line[i - 1] <= right_side[i - 1] - 3
                                    && right_line[i - 2] <= right_side[i - 2] - 3)
                                {
                                    startPoint = i;
                                    break;
                                }
                            }


                            int num = startPoint;
                            upPoint = num;
                            while (num >= 40 && my_road[num].connected[j_mid[num]].right <= right_side[num] - 1
                                //&& abs(my_road[num - 1].connected[j_mid[num - 1]].left - my_road[num].connected[j_mid[num]].left) <= 4
                                //&& abs(my_road[num + 1].connected[j_mid[num + 1]].left - my_road[num].connected[j_mid[num]].left) <= 4
                                ) {
                                if (my_road[num].connected[j_mid[num]].right <= my_road[upPoint].connected[j_mid[upPoint]].right
                                    //&& my_road[num].connected[j_mid[num]].right<right_side[num]-5

                                    ) {
                                    upPoint = num;
                                }

                                num--;
                            }
                            //if
                        }
                    }
                }
                if (upPoint != 119)last_rightupPoint = upPoint;
            }
            else if (last_rightupPoint > 85)
            {
                int startpoint = last_rightupPoint - jump;
                int lastpoint = last_rightupPoint + jump;
                if (lastpoint > 105) lastpoint = 105;
                for (int i = lastpoint; i >= startpoint; i--) {
                    if (
                        (abs(my_road[i].connected[j_mid[i]].width - road_width) <= 5
                            && abs(my_road[i - 1].connected[j_mid[i - 1]].width - road_width) <= 5
                            && abs(my_road[i - 2].connected[j_mid[i - 2]].width - road_width) <= 5
                            && my_road[i + 1].connected[j_mid[i + 1]].width - road_width >= 10)
                        && j_mid[i] <= 1
                        || (my_road[i].connected[j_mid[i]].width < 60 && my_road[i + 2].connected[j_mid[i + 2]].width >= 60
                            && my_road[i - 1].connected[j_mid[i - 1]].width < 60 && my_road[i + 3].connected[j_mid[i + 3]].width >= 60

                            && my_road[i + 1].connected[j_mid[i + 1]].right - my_road[i].connected[j_mid[i]].right > 10
                            && my_road[i + 2].connected[j_mid[i + 2]].right - my_road[i].connected[j_mid[i]].right  > 10
                            && abs(my_road[i].connected[j_mid[i]].right - my_road[i - 1].connected[j_mid[i - 1]].right) <= 5
                            && abs(my_road[i - 1].connected[j_mid[i - 1]].right - my_road[i - 2].connected[j_mid[i - 2]].right) <= 5)

                        //&& my_road[i].connected[j_mid[i]].left != my_road[i].connected[j_mid2[i]].left
                        ) {
                        upPoint = i;
                        break;
                    }
                }
                if (upPoint != 119) last_rightupPoint = upPoint;

            }
//            test_varible[14]=upPoint;

            /*
            for (int i = 105; i >= 30; i--) {
                if (
                    (abs(my_road[i].connected[j_mid[i]].width - road_width) <= 5
                        && abs(my_road[i - 1].connected[j_mid[i - 1]].width - road_width) <= 5
                        && abs(my_road[i - 2].connected[j_mid[i - 2]].width - road_width) <= 5
                        && my_road[i + 1].connected[j_mid[i + 1]].width - road_width >= 10)
                        && j_mid[i] >= 2
                    || (my_road[i].connected[j_mid[i]].width < 60 && my_road[i + 2].connected[j_mid[i + 2]].width >= 60
                        && my_road[i - 1].connected[j_mid[i - 1]].width < 60 && my_road[i + 3].connected[j_mid[i + 3]].width >= 60

                        && my_road[i + 1].connected[j_mid[i + 1]].right-my_road[i].connected[j_mid[i]].right > 10
                        && my_road[i + 2].connected[j_mid[i + 2]].right-my_road[i].connected[j_mid[i]].right  > 10
                        && abs(my_road[i].connected[j_mid[i]].right - my_road[i - 1].connected[j_mid[i - 1]].right) <= 5
                        && abs(my_road[i - 1].connected[j_mid[i - 1]].right - my_road[i - 2].connected[j_mid[i - 2]].right) <= 5)

                    //&& my_road[i].connected[j_mid[i]].left != my_road[i].connected[j_mid2[i]].left
                    ) {
                    upPoint = i;
                    break;
                }
            }
            if (upPoint != 119)
            {
                for (int i = 0; i < 188; i++)
                {
                    IMG[upPoint][i] = red;
                }
            }
            if (upPoint == 119)
            {
                float k = calculate_slope_uint(60, 100, left_line);
                ////printf(" k = %f\n", k);
                if (k <- 0.25)
                {
                    int count = 0;
                    for (int j = 109; j >= 89; j--)
                    {
                        if (right_line[j] = right_side[j]) count++;
                    }
                    if (count > 10)
                    {
                        int startPoint = 109;
                        for (int i = 109; i >= 50; i--)
                        {
                            if (right_line[i] <= right_side[i]-3
                                && right_line[i - 1] <= right_side[i - 1]-3
                                && right_line[i - 2] <= right_side[i - 2]-3)
                            {
                                startPoint = i;
                                break;
                            }
                        }


                        int num = startPoint;
                        upPoint = num;
                        while (num >= 40 && my_road[num].connected[j_mid[num]].right <= right_side[num] - 1
                            //&& abs(my_road[num - 1].connected[j_mid[num - 1]].left - my_road[num].connected[j_mid[num]].left) <= 4
                            //&& abs(my_road[num + 1].connected[j_mid[num + 1]].left - my_road[num].connected[j_mid[num]].left) <= 4
                            ) {
                            if (my_road[num].connected[j_mid[num]].right <= my_road[upPoint].connected[j_mid[upPoint]].right
                                //&& my_road[num].connected[j_mid[num]].right<right_side[num]-5

                                ) {
                                upPoint = num;
                            }

                            num--;
                        }
                        //if
                    }
                }
            }
            */

            if (upPoint != 119)
            {
                double k = (double)(my_road[upPoint].connected[j_mid[upPoint]].right - my_road[107].connected[j_mid[107]].left) / (upPoint - 107);
                if (k < -3) k = -3;
                if (IslandRadius == 50)
                {
                    k = k - 0.8;
                }
                else if (IslandRadius >= 60 && IslandRadius <= 70)
                {
                    k = k - 0.2;
                }
                else if (IslandRadius > 70)
                {
                    k = k - 0.2;
                }
                //////printf("k=%f\n", k);

                int count1 = 0;
                for (int i = upPoint; i >= 2; i--)
                {
                    int count2 = count1;
                    for (int j = 1; j <= my_road[i].white_num; j++) {

                        if (my_road[i].connected[j].left > my_road[upPoint].connected[j_mid[upPoint]].right
                            && my_road[i].connected[j].width >= 3) {
                            count1++;
                            break;
                        }

                    }
                    if (count2 == count1)break;
                }

                for (int i = upPoint; i >= upPoint - count1; i--)
                {
                    right_line[i] = my_road[i].connected[j_mid2[i]].right;
                }
                int min_line = upPoint - count1;

                for (int i = upPoint - count1 + 1; i <= 105; i++)
                {
                    if (right_line[i] > right_line[min_line]) min_line = i;
                }
                for (int i = min_line; i >= 2; i--)
                {
                    right_line[i] = right_line[min_line+2];
                }

                if (count1 >= 15)
                {
                    for (int i = upPoint; i >= upPoint - count1; i--)
                    {
                        left_line[i] = my_road[i].connected[j_mid2[i]].left;
                    }

                    /*
                    double k2 = calculate_slope_uint(upPoint - count1, upPoint, left_line);
                    if (k2 < -5) k2 = -5;
                    if (IslandRadius == 50)
                    {
                        k2 = k2 - 0.5;
                    }
                    else if (IslandRadius >= 60 && IslandRadius <= 70)
                    {
                        k2 = k2 - 0.2;
                    }
                    else if (IslandRadius > 70)
                    {
                        k2 = k2 - 0.2;
                    }*/
                    int j = 0;
                    for (j = upPoint - count1 - 1; j <= upPoint; j++)
                    {
                        if (left_line[j] > left_line[upPoint]) break;
                    }
                    for (int i = j; i >= 2; i--)
                    {
                        left_line[i] = left_line[j + 2];
                    }

                    for (int i = NEAR_LINE - 1; i > upPoint; i--)
                    {
                        left_line[i] = (k - ctrl_dkRight) * (i - 107) + my_road[107].connected[j_mid[107]].left;
                    }

                }
                if (count1 < 15)
                {
                    int flagt = 0;
                    for (int i = NEAR_LINE - 1; i > 2; i--)
                    {
                        left_line[i] = (k - ctrl_dkRight) * (i - 107) + my_road[107].connected[j_mid[107]].left;
                        if (left_line[i] > 187 && i < upPoint)
                        {
                            left_line[i] = 187;
                            flagt = 1;
                        }
                        if(flagt==1) left_line[i] = 187;
                    }
                }

            }
        }


    }
    else if (islandWhere == LEFT) {
        uint8_t j_mid[CAMERA_H];
        uint8_t j_mid2[CAMERA_H];

        for (int i = NEAR_LINE - 1; i >= 2; i--) {
            j_mid[i] = j_continue[i];
            j_mid2[i] = j_continue[i];
            for (int j = 1; j <= my_road[i].white_num; j++) {

                if (abs(my_road[i].connected[j].right - my_road[i + 1].connected[j_mid[i + 1]].right) < abs(my_road[i].connected[j_mid[i]].right - my_road[i + 1].connected[j_mid[i + 1]].right)
                    && my_road[i].connected[j].width > 10) {
                    j_mid[i] = j;

                }
                if (abs(my_road[i].connected[j].left - my_road[i + 1].connected[j_mid2[i + 1]].left) < abs(my_road[i].connected[j_mid2[i]].left - my_road[i + 1].connected[j_mid2[i + 1]].left)
                    && my_road[i].connected[j].width > 10) {
                    j_mid2[i] = j;

                }
            }
        }
        int way = 2;
        if (way == 1) {
            //固定打角
            double k = (double)(10 - (NEAR_LINE - 5)) / (left_side[10] - right_line[(NEAR_LINE - 5)]) + dk;

            for (int i = (NEAR_LINE - 5); i >= 2; i--) {
                right_line[i] = k * (i - (NEAR_LINE - 5)) + right_line[(NEAR_LINE - 5)];
                left_line[i] = left_side[i];
            }
        }
        else if (way == 2) {
            //连接顶点
            int upPoint = 119;
            int road_width=45;
            int jump = 15;
            if (last_leftupPoint == 0)
            {
                for (int i = 105; i >= 30; i--) {
                    if (
                        (abs(my_road[i].connected[j_mid[i]].width - road_width) <= 5
                            && abs(my_road[i - 1].connected[j_mid[i - 1]].width - road_width) <= 5
                            && abs(my_road[i - 2].connected[j_mid[i - 2]].width - road_width) <= 5
                            && my_road[i + 1].connected[j_mid[i + 1]].width - road_width >= 10
                            && j_mid[i] >= 2)
                        || (my_road[i].connected[j_mid[i]].width < 60 && my_road[i + 2].connected[j_mid[i + 2]].width >= 60
                            && my_road[i - 1].connected[j_mid[i - 1]].width < 60 && my_road[i + 3].connected[j_mid[i + 3]].width >= 60

                            && my_road[i].connected[j_mid[i]].left - my_road[i + 1].connected[j_mid[i + 1]].left > 10
                            && my_road[i].connected[j_mid[i]].left - my_road[i + 2].connected[j_mid[i + 2]].left > 10
                            && abs(my_road[i].connected[j_mid[i]].left - my_road[i - 1].connected[j_mid[i - 1]].left) <= 5
                            && abs(my_road[i - 1].connected[j_mid[i - 1]].left - my_road[i - 2].connected[j_mid[i - 2]].left) <= 5)

                        //&& my_road[i].connected[j_mid[i]].left != my_road[i].connected[j_mid2[i]].left
                        ) {
                        upPoint = i;
                        last_leftupPoint = upPoint;
                        break;
                    }
                }
            }
            else if(last_leftupPoint <=85)
            {
                int startpoint = last_leftupPoint - jump;
                int lastpoint = last_leftupPoint + jump;
                if (lastpoint > 105) lastpoint = 105;
                for (int i = lastpoint; i >= startpoint; i--) {
                    if (
                        (abs(my_road[i].connected[j_mid[i]].width - road_width) <= 5
                            && abs(my_road[i - 1].connected[j_mid[i - 1]].width - road_width) <= 5
                            && abs(my_road[i - 2].connected[j_mid[i - 2]].width - road_width) <= 5
                            && my_road[i + 1].connected[j_mid[i + 1]].width - road_width >= 10
                            && j_mid[i] >= 2)
                        || (my_road[i].connected[j_mid[i]].width < 60 && my_road[i + 2].connected[j_mid[i + 2]].width >= 60
                            && my_road[i - 1].connected[j_mid[i - 1]].width < 60 && my_road[i + 3].connected[j_mid[i + 3]].width >= 60

                            && my_road[i].connected[j_mid[i]].left - my_road[i + 1].connected[j_mid[i + 1]].left > 10
                            && my_road[i].connected[j_mid[i]].left - my_road[i + 2].connected[j_mid[i + 2]].left > 10
                            && abs(my_road[i].connected[j_mid[i]].left - my_road[i - 1].connected[j_mid[i - 1]].left) <= 5
                            && abs(my_road[i - 1].connected[j_mid[i - 1]].left - my_road[i - 2].connected[j_mid[i - 2]].left) <= 5)

                        //&& my_road[i].connected[j_mid[i]].left != my_road[i].connected[j_mid2[i]].left
                        ) {
                        upPoint = i;
                        break;
                    }
                }

                if (upPoint == 119)
                {
                    float k = calculate_slope_uint(60, 100, right_line);

                    if (k > 0.15)
                    {
                        int count = 0;
                        for (int j = 109; j >= 89; j--)
                        {
                            if (left_line[j] = left_side[j]) count++;
                        }
                        if (count > 10)
                        {
                            int startPoint = 109;
                            for (int i = 109; i >= 50; i--)
                            {
                                if (left_line[i] >= left_side[i] + 3
                                    && left_line[i - 1] >= left_side[i - 1] + 3
                                    && left_line[i - 2] >= left_side[i - 2] + 3)
                                {
                                    startPoint = i;
                                    break;
                                }
                            }


                            int num = startPoint;
                            upPoint = num;
                            while (num >= 40 && my_road[num].connected[j_mid[num]].left >= left_side[num] + 1
                                //&& abs(my_road[num - 1].connected[j_mid[num - 1]].left - my_road[num].connected[j_mid[num]].left) <= 4
                                //&& abs(my_road[num + 1].connected[j_mid[num + 1]].left - my_road[num].connected[j_mid[num]].left) <= 4
                                ) {
                                if (my_road[num].connected[j_mid[num]].left >= my_road[upPoint].connected[j_mid[upPoint]].left

                                    ) {
                                    upPoint = num;
                                }

                                num--;
                            }
                            //if
                        }
                    }
                }
                if(upPoint !=119)last_leftupPoint = upPoint;
            }
            else if (last_leftupPoint > 85)
            {
                int startpoint = last_leftupPoint - jump;
                int lastpoint = last_leftupPoint + jump;
                if (lastpoint > 105) lastpoint = 105;
                for (int i = lastpoint; i >= startpoint; i--) {
                    if (
                        (abs(my_road[i].connected[j_mid[i]].width - road_width) <= 5
                            && abs(my_road[i - 1].connected[j_mid[i - 1]].width - road_width) <= 5
                            && abs(my_road[i - 2].connected[j_mid[i - 2]].width - road_width) <= 5
                            && my_road[i + 1].connected[j_mid[i + 1]].width - road_width >= 10
                            && j_mid[i] >= 2)
                        || (my_road[i].connected[j_mid[i]].width < 60 && my_road[i + 2].connected[j_mid[i + 2]].width >= 60
                            && my_road[i - 1].connected[j_mid[i - 1]].width < 60 && my_road[i + 3].connected[j_mid[i + 3]].width >= 60

                            && my_road[i].connected[j_mid[i]].left - my_road[i + 1].connected[j_mid[i + 1]].left > 10
                            && my_road[i].connected[j_mid[i]].left - my_road[i + 2].connected[j_mid[i + 2]].left > 10
                            && abs(my_road[i].connected[j_mid[i]].left - my_road[i - 1].connected[j_mid[i - 1]].left) <= 5
                            && abs(my_road[i - 1].connected[j_mid[i - 1]].left - my_road[i - 2].connected[j_mid[i - 2]].left) <= 5)

                        //&& my_road[i].connected[j_mid[i]].left != my_road[i].connected[j_mid2[i]].left
                        ) {
                        upPoint = i;
                        break;
                    }
                }
                if(upPoint!=119) last_leftupPoint = upPoint;

            }
            /*
            for (int i = 105; i >= 30; i--) {
                if (
                    (abs(my_road[i].connected[j_mid[i]].width- road_width)<=5
                     &&abs(my_road[i-1].connected[j_mid[i-1]].width - road_width) <= 5
                     && abs(my_road[i - 2].connected[j_mid[i - 2]].width - road_width) <= 5
                     && my_road[i +1].connected[j_mid[i +1]].width - road_width >= 10
                     &&j_mid[i]>=2)
                    ||(my_road[i].connected[j_mid[i]].width < 60 && my_road[i + 2].connected[j_mid[i + 2]].width >= 60
                    && my_road[i - 1].connected[j_mid[i - 1]].width < 60 && my_road[i + 3].connected[j_mid[i + 3]].width >= 60

                    &&my_road[i].connected[j_mid[i]].left - my_road[i + 1].connected[j_mid[i + 1]].left > 10
                    && my_road[i].connected[j_mid[i]].left - my_road[i + 2].connected[j_mid[i + 2]].left > 10
                    && abs(my_road[i].connected[j_mid[i]].left - my_road[i - 1].connected[j_mid[i - 1]].left) <= 5
                    && abs(my_road[i-1].connected[j_mid[i-1]].left - my_road[i - 2].connected[j_mid[i - 2]].left) <= 5)

                    //&& my_road[i].connected[j_mid[i]].left != my_road[i].connected[j_mid2[i]].left
                    ) {
                    upPoint = i;
                    break;
                }
            }

            if (upPoint == 119)
            {
                float k = calculate_slope_uint(60, 100, right_line);
                ////printf(" k = %f\n", k);
                if (k > 0.25)
                {
                    int count = 0;
                    for (int j = 109; j >= 89; j--)
                    {
                        if (left_line[j] = left_side[j]) count++;
                    }
                    if (count > 10)
                    {
                        int startPoint = 109;
                        for (int i = 109; i >= 50; i--)
                        {
                            if (left_line[i] >= left_side[i]+3
                                && left_line[i - 1] >= left_side[i - 1]+3
                                && left_line[i - 2] >= left_side[i - 2]+3)
                            {
                                startPoint = i;
                                break;
                            }
                        }


                        int num = startPoint;
                        upPoint = num;
                        while (num >= 40 && my_road[num].connected[j_mid[num]].left >= left_side[num] + 1
                            //&& abs(my_road[num - 1].connected[j_mid[num - 1]].left - my_road[num].connected[j_mid[num]].left) <= 4
                            //&& abs(my_road[num + 1].connected[j_mid[num + 1]].left - my_road[num].connected[j_mid[num]].left) <= 4
                            ) {
                            if (my_road[num].connected[j_mid[num]].left >= my_road[upPoint].connected[j_mid[upPoint]].left

                                ) {
                                upPoint = num;
                            }

                            num--;
                        }
                        //if
                    }
                }
            }*/

            if (upPoint != 119)
            {
                double k = (double)(my_road[upPoint].connected[j_mid[upPoint]].left - my_road[107].connected[j_mid[107]].right) / (upPoint - 107);
                if (k > 3) k = 3;
                if (IslandRadius == 50)
                {
                    k = k + 0.8;
                }
                else if (IslandRadius >= 60 && IslandRadius <= 70)
                {
                    k = k + 0.2;
                }
                else if (IslandRadius > 70)
                {
                    k = k + 0.2;
                }
                //////printf("k=%f\n", k);

                int count1 = 0;
                for (int i = upPoint; i >= 2; i--)
                {
                    int count2 = count1;
                    for (int j = 1; j <= my_road[i].white_num; j++) {

                        if (my_road[i].connected[j].right  < my_road[upPoint].connected[j_mid[upPoint]].left
                            && my_road[i].connected[j].width >=3) {
                            count1++;
                            break;
                        }

                    }
                    if (count2 == count1)break;
                }


                for (int i = upPoint; i >= upPoint - count1; i--)
                {
                    left_line[i] = my_road[i].connected[j_mid2[i]].left;
                }
                int min_line = upPoint - count1;

                for (int i = upPoint - count1+1; i <=105; i++)
                {
                    if (left_line[i] < left_line[min_line]) min_line = i;
                }
                for (int i = min_line; i >= 2; i--)
                {
                    left_line[i] = left_line[min_line+2];
                }

                if (count1 >= 15)
                {
                    for (int i = upPoint; i >= upPoint - count1; i--)
                    {
                        right_line[i] = my_road[i].connected[j_mid2[i]].right;
                    }

                    double k2 = calculate_slope_uint(upPoint - count1, upPoint, right_line);
                    if (k2 > 5) k2 = 5;/*
                    if (IslandRadius == 50)
                {
                    k = k + 0.5;
                }
                else if (IslandRadius >= 60 && IslandRadius <= 70)
                {
                    k = k + 0.2;
                }
                else if (IslandRadius > 70)
                {
                    k = k + 0.2;
                }*/
                    int j = 0;
                    for (j = upPoint - count1 - 1; j <= upPoint; j++)
                    {
                        if (right_line[j] < right_line[upPoint]) break;
                    }
                    for (int i = j; i >= 2; i--)
                    {
                        right_line[i] = right_line[j+2];
                    }

                    for (int i = NEAR_LINE - 1; i > upPoint; i--)
                    {
                        right_line[i] = (k + ctrl_dkLeft) * (i - 107) + my_road[107].connected[j_mid[107]].right;
                    }

                }
                if (count1 < 15)
                {/*
                    if (IslandRadius == 50)
                    {
                        k = k + 0.5;
                    }
                    else if (IslandRadius >= 60 && IslandRadius <= 70)
                    {
                        k = k + 0.2;
                    }
                    else if (IslandRadius > 70)
                    {
                        k = k + 0.2;
                    }*/
                    for (int i = NEAR_LINE - 1; i > 2; i--)
                    {
                        right_line[i] = (k + ctrl_dkLeft) * (i - 107) + my_road[107].connected[j_mid[107]].right;
                        if (right_line[i] > right_line[i + 1] && i < upPoint) right_line[i] = right_line[i + 1];
                    }
                }
            }
        }
    }

}

////////////////////////////////////////////
//功能：环岛弯道
//输入：
//输出：
//备注：
///////////////////////////////////////////
void island_circle() {
    if (islandWhere == RIGHT) {
        uint8_t j_mid[CAMERA_H];
        j_mid[NEAR_LINE] = j_continue[NEAR_LINE];
        for (int i = NEAR_LINE - 1; i >= 2; i--) {
            j_mid[i] = j_continue[i];
            for (int j = 1; j <= my_road[i].white_num; j++) {
                if (abs(my_road[i].connected[j].right - my_road[i + 1].connected[j_mid[i + 1]].right) < abs(my_road[i].connected[j_mid[i]].right - my_road[i + 1].connected[j_mid[i + 1]].right)
                    && my_road[i].connected[j].width > 20) {
                    j_mid[i] = j;

                }

            }
        }
        if (1) {
            int upPoint = 119;
            for (int i = 110; i >= 50; i--) {
                if (my_road[i].connected[j_mid[i]].width < 65 && my_road[i + 2].connected[j_mid[i + 2]].width >= 55
                    && my_road[i - 1].connected[j_mid[i - 1]].width < 65 && my_road[i + 3].connected[j_mid[i + 3]].width >= 55
                    && my_road[i].connected[j_mid[i]].left - my_road[i + 1].connected[j_mid[i + 1]].left > 4) {
                    upPoint = i;
                    break;
                }
            }

            if (90 <= upPoint && upPoint <= NEAR_LINE && my_road[upPoint].connected[j_mid[upPoint]].left < 94) {
                state = stateIslandCircle;
                last_leftupPoint = 0;
                last_rightupPoint = 0;

            }

        }


    }
    else if (islandWhere == LEFT) {
        uint8_t j_mid[CAMERA_H];
        j_mid[NEAR_LINE] = j_continue[NEAR_LINE];
        for (int i = NEAR_LINE - 1; i >= 2; i--) {
            j_mid[i] = j_continue[i];
            for (int j = 1; j <= my_road[i].white_num; j++) {
                if (abs(my_road[i].connected[j].left - my_road[i + 1].connected[j_mid[i + 1]].left) < abs(my_road[i].connected[j_mid[i]].left - my_road[i + 1].connected[j_mid[i + 1]].left)
                    && my_road[i].connected[j].width > 20) {
                    j_mid[i] = j;

                }

            }
        }

        if (1) {
            int upPoint = 119;
            for (int i = 110; i >= 50; i--) {
                if (abs(my_road[i].connected[j_mid[i]].right - my_road[i - 1].connected[j_mid[i - 1]].right) <= 4
                    && abs(my_road[i].connected[j_mid[i]].right - my_road[i - 2].connected[j_mid[i - 2]].right) <= 6
                    && my_road[i].connected[j_mid[i]].right - my_road[i + 1].connected[j_mid[i + 1]].right < -6
                    && my_road[i].connected[j_mid[i]].right - my_road[i + 2].connected[j_mid[i + 2]].right < -6) {
                    upPoint = i;
                    break;
                }
            }
            if (90 <= upPoint && upPoint <= NEAR_LINE && my_road[upPoint].connected[j_mid[upPoint]].right > 94) {
                state = stateIslandCircle;
                last_leftupPoint = 0;
                last_rightupPoint = 0;
            }

        }


    }
    if (my_road[50].white_num == 0) {
        state = stateIslandCircle;
        last_leftupPoint = 0;
        last_rightupPoint = 0;
    }

}

int if_smooth_flag = 0;
//////////////////////////////////////////////
////功能：大角度弯道修正
////输入：
////输出：
////备注：
/////////////////////////////////////////////
void roof(void)
{
    uint8_t i, i_start, i_end;
    uint8_t my_roof = MISS, Ldir = 0, Rdir = 0;
    uint8_t max_width = 0, max_width_num = 0;
    uint8_t roof_line = 1;

    //寻找第一个非miss行
    for (i = 1; i <= 90; i++)
    {
        if (left_line[i] != MISS || right_line[i] != MISS)
        {
            roof_line = i;
            break;
        }
    }
    if (roof_line <= 60)
    {
        return;
    }

    //////////////printf("roof line:%d\n", roof_line);
    uint8_t left_min = 255, left_min_line = 119;
    uint8_t right_min = 255, right_min_line = 119;
    if (state == stateIslandCircle || state == stateTIn) {
        for (int i = roof_line; i <= roof_line + 20; i++) {
            if (right_line[i] - left_line[i] > 23) {
                left_min_line = i;
                break;
            }
        }
        for (int i = roof_line; i <= left_min_line; i++) {
            left_line[i] = MISS;
        }

    }

    //////////////printf("圆弧顶修正: 左%d %d  右%d %d\n", left_min, left_min_line, right_min, right_min_line);
}

////////////////////////////////////////////
//功能：出环岛拐弯
//输入：
//输出：
//备注：
///////////////////////////////////////////
void island_out() {
    int dx = 0;
    int ctrl_xmax=islandParam4.intVal,ctrl_xmin=islandParam3.intVal;
    if(IslandRadius == islandParam6.intVal)
    {
        ctrl_xmax=islandParam4.intVal;
        ctrl_xmin=islandParam3.intVal;
    }
    else if(IslandRadius == bigParam8.intVal)
    {
        ctrl_xmax=bigParam6.intVal;
        ctrl_xmin=bigParam5.intVal;
    }
    if (1) {
        if (islandWhere == RIGHT) {

            int xMax = 0;
            int yMax = NEAR_LINE;
            int start = NEAR_LINE;
            while (start >= 40 && left_line[start] >= left_line[NEAR_LINE] - 10) {
                if (my_road[start - 1].white_num != 0) {
                    if (left_line[start] >= xMax - 1 && left_line[start] > left_side[start]  + 1) {
                        xMax = left_line[start];
                        yMax = start;
                    }
                }
                else {
                    break;
                }
                start--;
            }

            int xmax = 120;
            if(IslandRadius == 70){
                xmax = 108;
            }
            else if(IslandRadius == 80)
            {
                xmax = 90;
            }
            else if(IslandRadius == 50)
            {
                xmax = 106;
            }
            else if(IslandRadius == 100)
            {
                xmax = 96;
            }
            // ////printf("xMax=%d,y=%d\n", xMax,yMax);d
            if (left_line[yMax - 15] != MISS && ((calculate_slope_uint(yMax - 18, yMax - 1, left_line) > 0 &&  calculate_slope_uint(yMax + 2, yMax + 18, left_line) <= 0 )|| left_line[yMax] - left_line[yMax - 3] > 6)) {
                if (((xMax < xmax - ctrl_xmax && yMax > 40 && yMax < 95) || (xMax < xmax + 5 && yMax >= 95 && yMax < 109))) {
                    state = stateIslandOut;
                }
            }

        }
        else if (islandWhere == LEFT) {
            int xMin = 188;
            int yMin = 109;
            int start = NEAR_LINE;
            while (start >= 40 && right_line[start] <= right_line[NEAR_LINE] + 10) {
                if (my_road[start - 1].white_num != 0 && right_line[start] < right_side[start] - 1) {
                    if (right_line[start] <= xMin + 1) {
                        xMin = right_line[start];
                        yMin = start;
                    }
                }
                else {
                    break;
                }
                start--;
            }
            //  ////printf("yMin=%d,xMin=%d\n", yMin, xMin);
                /*for (int i = NEAR_LINE; i >= 20; i--) {
                    if (my_road[i - 1].white_num != 0) {
                        if (right_line[i] <= xMin) {
                            xMin = right_line[i];
                            yMin = i;
                        }
                    }
                    else {
                        break;
                    }
                }*/

            int xmin = 80;
            if(IslandRadius == 70){
                xmin = 90;
            }
            else if(IslandRadius == 80)
            {
                xmin = 104;
            }
            else if(IslandRadius == 50)
            {
                xmin = 84;
            }
            else if(IslandRadius == 100)
            {
                xmin = 95;
            }
            if (left_line[yMin - 15] != MISS) {
                if (((xMin > xmin + ctrl_xmin && yMin > 40 && yMin < 95)  || (xMin > xmin - 5 && yMin >= 95&& yMin < 109))&& ((calculate_slope_uint(yMin - 18, yMin - 1, right_line) < 0 &&  calculate_slope_uint(yMin + 2, yMin + 18, right_line) >= 0 )|| right_line[yMin] - right_line[yMin - 3] < -6)) {
                    state = stateIslandOut;
                }
            }
        }
    }
}

////////////////////////////////////////////
//功能：环岛拐弯调整
//输入：
//输出：
//备注：
///////////////////////////////////////////
void design_island_circle() {
    int i = NEAR_LINE;
    int distance = 50;

    if (islandWhere == LEFT) {
        uint8_t j_mid[CAMERA_H];
        j_mid[NEAR_LINE] = j_continue[NEAR_LINE];
        for (int i = NEAR_LINE - 1; i >= 2; i--) {
            j_mid[i] = j_continue[i];
            for (int j = 1; j <= my_road[i].white_num; j++) {
                if (abs(my_road[i].connected[j].left - my_road[i + 1].connected[j_mid[i + 1]].left) < abs(my_road[i].connected[j_mid[i]].left - my_road[i + 1].connected[j_mid[i + 1]].left)
                    && my_road[i].connected[j].width > 20) {
                    j_mid[i] = j;

                }

            }
            if (my_road[i].connected[j_mid[i]].left <= my_road[i + 1].connected[j_mid[i + 1]].right && my_road[i].connected[j_mid[i]].right >= my_road[i + 1].connected[j_mid[i + 1]].left && left_line[i+1] != MISS && right_line[i + 1]!=MISS
                && my_road[i].connected[j_mid[i]].width > 30
                ){
                left_line[i] = my_road[i].connected[j_mid[i]].left;
                right_line[i] = my_road[i].connected[j_mid[i]].right;
            }
            else {
                left_line[i] = MISS;
                right_line[i] = MISS;
            }

        }
    }
    else if (islandWhere == RIGHT) {
        uint8_t j_mid[CAMERA_H];
        j_mid[NEAR_LINE] = j_continue[NEAR_LINE];
        for (int i = NEAR_LINE - 1; i >= 2; i--) {
            j_mid[i] = j_continue[i];
            for (int j = 1; j <= my_road[i].white_num; j++) {
                if (abs(my_road[i].connected[j].right - my_road[i + 1].connected[j_mid[i + 1]].right) < abs(my_road[i].connected[j_mid[i]].right - my_road[i + 1].connected[j_mid[i + 1]].right)
                    && my_road[i].connected[j].width > 20) {
                    j_mid[i] = j;

                }

            }
            if (my_road[i].connected[j_mid[i]].left <= my_road[i+1].connected[j_mid[i+1]].right && my_road[i].connected[j_mid[i]].right >= my_road[i + 1].connected[j_mid[i + 1]].left && left_line[i + 1] != MISS && right_line[i + 1] != MISS
                && my_road[i].connected[j_mid[i]].width > 30
                ) {
                left_line[i] = my_road[i].connected[j_mid[i]].left;
                right_line[i] = my_road[i].connected[j_mid[i]].right;
            }
            else {
                left_line[i] = MISS;
                right_line[i] = MISS;
            }

        }
    }
//    if (islandWhere == LEFT) {
//        for(int i=100;i>= 40;i--){
//            if(right_line[i] > right_line[i + 1]  && my_road[i].white_num!=0 ){
//                right_line[i] = right_line[i + 1];
//            }
//        }
//     }
//    else if (islandWhere == RIGHT) {
//        for(int i=100;i>= 40;i--){
//            if(left_line[i] < left_line[i + 1]  && my_road[i].white_num!=0){
//                left_line[i] = left_line[i + 1];
//            }
//        }
//    }

//    int a=0;
//    while (i >= 1 && left_line[i] != MISS && right_line[i] != MISS) {
//        if (islandWhere == LEFT) {
//            a= right_line[i] - distance;
//            if(a<=left_side[i]){
//                left_line[i]=left_side[i];
//            }else{
//                left_line[i]=a;
//            }
//        }
//        else if (islandWhere == RIGHT) {
//            a = left_line[i] + distance;
//            if(a>=right_side[i]){
//                right_line[i]=right_side[i];
//            }else{
//                right_line[i]=a;
//            }
//        }
//        i--;
//    }

}

////////////////////////////////////////////
//功能：出环岛补线
//输入：
//输出：
//备注：
///////////////////////////////////////////
void design_island_out() {
    double dk = islandParam5.floatVal;
    if(IslandRadius == islandParam6.intVal)
    {
        dk = islandParam5.floatVal;
    }
    else if(IslandRadius == bigParam8.intVal)
    {
        dk = bigParam7.floatVal;
    }
    if (islandWhere == RIGHT) {
        int up = 10;
        if(IslandRadius == 70){
            up = 5;
        }
        else if(IslandRadius == 80)
        {
            up = 5;
        }
        else if(IslandRadius == 50)
        {
            up = 8;
        }
        else if(IslandRadius == 100)
        {
            up = 3;
        }


        int xMax = 0;
        int yMax = NEAR_LINE;
        int start = NEAR_LINE;
        if (left_line[NEAR_LINE] != left_side[NEAR_LINE]) {

            while (start >= 50 && left_line[start] >= left_line[NEAR_LINE] - 10) {
                if (my_road[start - 1].white_num != 0) {
                    if (left_line[start] >= xMax) {
                        xMax = left_line[start];
                        yMax = start;
                    }
                }
                else {
                    break;
                }
                start--;
            }
        }

        if (yMax <= 105) {
            double k = (double)(right_side[up] - left_line[yMax]) / (up - yMax) + 0.3;

            for (int i = NEAR_LINE - 1; i >= 2; i--) {
                if (i <= yMax) {
                    left_line[i] = (k - dk) * (i - yMax) + left_line[yMax];
                }
                if (right_line[i + 1] == right_side[i + 1]) {
                    right_line[i] = right_side[i];
                }
                else {
                    if (right_line[i] < right_line[i + 1]) {
                        right_line[i] = right_line[i + 1];
                    }
                }
                //right_line[i] = right_side[i];
            }
        }
        else {
            double k = (double)(right_side[up] - left_line[NEAR_LINE]) / (up - NEAR_LINE) + 0.3;

            for (int i = NEAR_LINE - 1; i >= 2; i--) {
                left_line[i] = (k - dk) * (i - NEAR_LINE) + left_line[NEAR_LINE];
                if (right_line[i + 1] == right_side[i + 1]) {
                    right_line[i] = right_side[i];
                }
                else {
                    if (right_line[i] < right_line[i + 1]) {
                        right_line[i] = right_line[i + 1];
                    }
                }
                //right_line[i] = right_side[i];
            }
        }



    }
    else if (islandWhere == LEFT) {
        int up = 10;
        if(IslandRadius == 70){
            up = 5;
        }
        else if(IslandRadius == 80)
        {
            up = 5;
        }
        else if(IslandRadius == 50)
        {
            up = 8;
        }
        else if(IslandRadius == 100)
        {
            up = 3;
        }


        int xMin = 188;
        int yMin = 110;
        int start = 110;
        if (right_line[NEAR_LINE] != right_side[NEAR_LINE]) {
            while (start >= 50 && right_line[start] <= right_line[NEAR_LINE] + 10) {
                if (my_road[start - 1].white_num != 0) {
                    if (right_line[start] <= xMin) {
                        xMin = right_line[start];
                        yMin = start;
                    }
                }
                else {
                    break;
                }
                start--;
            }
        }

        ////////////printf("ym=%d\n", yMin);
        if (yMin <= 105) {
            double k = (double)(left_side[up] - right_line[yMin]) / (up - yMin) - 0.3;
            for (int i = NEAR_LINE - 1; i >= 2; i--) {
                if (i <= yMin) {
                    right_line[i] = (k + dk) * (i - yMin) + right_line[yMin];
                }
                //left_line[i] = left_side[i];
                if (left_side[i + 1] == left_line[i + 1]) {
                    left_line[i] = left_side[i];
                }else {
                    if (left_line[i] > left_line[i + 1]) {
                        left_line[i] = left_line[i + 1];
                    }
                }
            }
        }
        else {
            double k = (double)(left_side[up] - right_line[NEAR_LINE]) / (up - NEAR_LINE) - 0.3;
            for (int i = NEAR_LINE - 1; i >= 2; i--) {
                right_line[i] = (k + dk) * (i - NEAR_LINE) + right_line[NEAR_LINE];
                //left_line[i] = left_side[i];
                if (left_side[i + 1] == left_line[i + 1]) {
                    left_line[i] = left_side[i];
                }
                else {
                    if (left_line[i] > left_line[i + 1]) {
                        left_line[i] = left_line[i + 1];
                    }
                }
            }
        }

    }


}

////////////////////////////////////////////
//功能：出环岛直线
//输入：
//输出：
//备注：
///////////////////////////////////////////
void island_straight() {
    int flag = 0;
    if (my_road[30].white_num != 0) {
        if (islandWhere == RIGHT) {
            //////////////printf("jl=%f\n", linear_judgement(70, 90, left_line));
            if (calculate_slope_uint(50, 70, left_line) > -1.5 && calculate_slope_uint(80, 100, left_line) > -1.5
                && calculate_slope_uint(50, 70, left_line) <= 0 && calculate_slope_uint(80, 100, left_line) <= 0
                && linear_judgement(70, 90, left_line) < 200) {
                flag = 1;
            }

            if (fabs(calculate_slope_uint(50, 70, left_line) - calculate_slope_uint(80, 100, left_line)) > 0.3
                ) {
                flag = 0;
            }

        }
        else if (islandWhere == LEFT) {


            if (calculate_slope_uint(50, 70, right_line) < 1.5 && calculate_slope_uint(80, 100, right_line) < 1.5
                && calculate_slope_uint(50, 70, right_line) >= -0.1 && calculate_slope_uint(80, 100, right_line) >= -0.1
                && linear_judgement(70, 90, right_line) < 200) {
                flag = 1;
            }
            if (fabs(calculate_slope_uint(50, 70, right_line) - calculate_slope_uint(80, 100, right_line)) > 0.3
                ) {
                flag = 0;
            }
        }
    }


    if (flag == 1) {
        state = stateIslandFinal;
    }
}

////////////////////////////////////////////
//功能：出环岛直线补线
//输入：
//输出：
//备注：
///////////////////////////////////////////
void design_island_straight() {
    if (islandWhere == RIGHT) {

        int leftRoad[CAMERA_H];
        uint8_t j_mid[CAMERA_H];
        for (int i = NEAR_LINE; i >= 2; i--) {
            j_mid[i] = j_continue[i];
            for (int j = 1; j <= my_road[i].white_num; j++) {
                if (abs(my_road[i].connected[j].left - my_road[i + 1].connected[j_mid[i + 1]].left) < abs(my_road[i].connected[j_mid[i]].left - my_road[i + 1].connected[j_mid[i + 1]].left)
                    && my_road[i].connected[j].width > 15) {
                    j_mid[i] = j;
                    //  break;
                }

            }
            leftRoad[i] = my_road[i].connected[j_mid[i]].left;
        }
        uint8_t xMin = right_line[110], yMin = 110;
        for (int i = 110; i > 2; i--) {
            if (xMin >= right_line[i]) {
                yMin = i;
                xMin = right_line[i];
            }
        }

        double k = calculate_slope(80, 100, leftRoad);

        for (int i = 110; i >= 50; i--) {

            right_line[i] = leftRoad[i] + 45;
            left_line[i] = leftRoad[i];
        }
    }
    else if (islandWhere == LEFT) {
        uint8_t j_mid[CAMERA_H];
        int rightRoad[CAMERA_H];
        for (int i = NEAR_LINE; i >= 2; i--) {
            j_mid[i] = j_continue[i];
            for (int j = 1; j <= my_road[i].white_num; j++) {
                if (abs(my_road[i].connected[j].right - my_road[i + 1].connected[j_mid[i + 1]].right) < abs(my_road[i].connected[j_mid[i]].right - my_road[i + 1].connected[j_mid[i + 1]].right)
                    && my_road[i].connected[j].width > 15) {
                    j_mid[i] = j;
                    //  break;
                }
            }
            rightRoad[i] = my_road[i].connected[j_mid[i]].right;
        }

        uint8_t xMin = left_line[110], yMin = 110;
        for (int i = 110; i > 2; i--) {
            if (xMin <= left_line[i]) {
                yMin = i;
                xMin = left_line[i];
            }
            if (my_road[i - 1].white_num == 0) {
                break;
            }
        }

        double k = calculate_slope(80, 100, rightRoad);

        for (int i = 110; i >= 50; i--) {
            left_line[i] = rightRoad[i] - 45;
            right_line[i] = rightRoad[i];
        }
    }
}

/////////////////////////////////////////////
//功能：结束环岛
//输入：
//输出：
//备注：
///////////////////////////////////////////
void island_final() {

    int sumD = 0;
    for (int i = NEAR_LINE; i >= 95; i--) {
        if (right_line[i] - left_line[i] > 50) {
            sumD++;
        }
    }
    int sumU = 0;
    for (int i = 100; i >= 85; i--) {
        if (right_line[i] - left_line[i] < 55) {
            sumU++;
        }
    }
    if (sumD > 4 && sumU > 6) {
        if (islandWhere == RIGHT) {
            uint8_t j_mid[CAMERA_H];
            j_mid[NEAR_LINE] = j_continue[NEAR_LINE];
            for (int i = NEAR_LINE - 1; i >= 2; i--) {
                j_mid[i] = j_continue[i];
                for (int j = 1; j <= my_road[i].white_num; j++) {
                    if (abs(my_road[i].connected[j].left - my_road[i + 1].connected[j_mid[i + 1]].left) < abs(my_road[i].connected[j_mid[i]].left - my_road[i + 1].connected[j_mid[i + 1]].left)
                        && my_road[i].connected[j].width > 20) {
                        j_mid[i] = j;

                    }

                }
            }
            int upPoint = 119;
            for (int i = 105; i >= 70; i--) {
                if (my_road[i].connected[j_mid[i]].width < 55 && my_road[i + 2].connected[j_mid[i + 2]].width >= 55
                    && my_road[i - 1].connected[j_mid[i - 1]].width < 55 && my_road[i + 3].connected[j_mid[i + 3]].width >= 55
                    && my_road[i].connected[j_mid[i]].right - my_road[i + 1].connected[j_mid[i + 1]].right < -6
                    && abs(my_road[i].connected[j_mid[i]].right - my_road[i - 1].connected[j_mid[i - 1]].right) <= 3
                    && linear_judgement_struct(i - 13, i - 1, j_mid, LEFT) < 10
                    //&& fabs(calculate_slope_struct(i - 15,i - 1,j_mid,LEFT)- calculate_slope_struct(i - 10, i + 3, j_mid, RIGHT)) < 0.25
                    ) {
                    upPoint = i;
                    break;
                }
            }



            if (fabs(calculate_slope_uint(upPoint - 13, upPoint + 2, left_line) - calculate_slope_uint(upPoint - 15, upPoint - 1, right_line)) < 0.3
                && calculate_slope_uint(upPoint - 13, upPoint + 2, left_line) > -0.6
                && upPoint >= 80 && upPoint <= 105) {
                //flagIT = islandWhere * state;
                state = stateStart;
                islandWhere = 0;

            }
        }
        else if (islandWhere == LEFT) {
            uint8_t j_mid[CAMERA_H];
            for (int i = NEAR_LINE; i >= 2; i--) {
                j_mid[i] = j_continue[i];
                for (int j = 1; j <= my_road[i].white_num; j++) {
                    if (abs(my_road[i].connected[j].right - my_road[i + 1].connected[j_mid[i + 1]].right) < abs(my_road[i].connected[j_mid[i]].right - my_road[i + 1].connected[j_mid[i + 1]].right)
                        && my_road[i].connected[j].width > 20) {
                        j_mid[i] = j;

                    }

                }
            }
            int upPoint = 119;
            for (int i = 105; i >= 70; i--) {
                if (my_road[i].connected[j_mid[i]].width < 55 && my_road[i + 2].connected[j_mid[i + 2]].width >= 55
                    && my_road[i - 1].connected[j_mid[i - 1]].width < 55 && my_road[i + 3].connected[j_mid[i + 3]].width >= 55
                    && my_road[i].connected[j_mid[i]].left - my_road[i + 1].connected[j_mid[i + 1]].left > 6
                    && abs(my_road[i].connected[j_mid[i]].left - my_road[i - 1].connected[j_mid[i - 1]].left) <= 3
                    && linear_judgement_struct(i - 13, i - 1, j_mid, LEFT) < 10
                    //&& fabs(calculate_slope_struct(i - 15,i - 1,j_mid,LEFT)- calculate_slope_struct(i - 10, i + 3, j_mid, RIGHT)) < 0.25
                    ) {
                    upPoint = i;
                    break;
                }
            }
            if (fabs(calculate_slope_uint(upPoint - 15, upPoint - 1, left_line) - calculate_slope_uint(upPoint - 13, upPoint + 2, right_line)) < 0.3
                && calculate_slope_uint(upPoint - 13, upPoint + 2, right_line) < 0.6
                && upPoint >= 80 && upPoint <= 105) {
                //flagIT = islandWhere * state;
                state = stateStart;
                islandWhere = 0;

            }
        }

    }
}
////////////////////////////////////////////
//功能：入T字口结束
//输入：
//输出：
//备注：
///////////////////////////////////////////
void cross_T_in_over() {

    //猜想，如果顶端没有白条，是不是可以认为已经路过路口？跑车考证这个想法
    if (my_road[20].white_num == 0) {
        state = stateStart;
        TFlag = 1;
    }
    else if (my_road[10].white_num != 0) {
        if (TWhere == RIGHT) {
            uint8_t j_mid[CAMERA_H];
            for (int i = NEAR_LINE; i >= 2; i--) {
                j_mid[i] = j_continue[i];
                for (int j = 1; j <= my_road[i].white_num; j++) {
                    if (abs(my_road[i].connected[j].left - my_road[i + 1].connected[j_mid[i + 1]].left) < abs(my_road[i].connected[j_mid[i]].left - my_road[i + 1].connected[j_mid[i + 1]].left)
                        && my_road[i].connected[j].width > 15) {
                        j_mid[i] = j;
                        //  break;
                    }

                }
            }

            if (my_road[70].connected[j_mid[70]].width < 35) {
                //寻找拐点
                int upPoint = 119;
                if (calculate_slope_struct(90, 105, j_mid, LEFT) < 0) {
                    int num = 70;
                    upPoint = num;
                    while (num <= 110 && my_road[num].connected[j_mid[num]].right <= right_side[num] - 1) {
                        if (my_road[num].connected[j_mid[num]].right <= my_road[upPoint].connected[j_mid[upPoint]].right + 1
                            ) {
                            upPoint = num;
                        }
                        num++;
                    }


                }
                else {
                    int start = 70;

                    for (int i = start; i <= 110; i++) {
                        if (my_road[i + 1].connected[j_mid[i + 1]].right - my_road[i].connected[j_mid[i]].right > 4
                            && abs(my_road[i - 1].connected[j_mid[i - 1]].right - my_road[i].connected[j_mid[i]].right) <= 2
                            && my_road[i].connected[j_mid[i]].width < 35
                            && my_road[i - 1].connected[j_mid[i - 1]].width < 35
                            ) {
                            upPoint = i;
                            break;
                        }
                    }
                }

                if (80 <= upPoint && upPoint <= 110 && my_road[upPoint + 2].connected[j_mid[upPoint + 2]].width > 36
                    ) {
                    state = stateStart;
                    TFlag = 1;
                }
            }

        }
        else if (TWhere == LEFT) {
            uint8_t j_mid[CAMERA_H];
            for (int i = NEAR_LINE; i >= 2; i--) {
                j_mid[i] = j_continue[i];
                for (int j = 1; j <= my_road[i].white_num; j++) {
                    if (abs(my_road[i].connected[j].right - my_road[i + 1].connected[j_mid[i + 1]].right) < abs(my_road[i].connected[j_mid[i]].right - my_road[i + 1].connected[j_mid[i + 1]].right)
                        && my_road[i].connected[j].width > 15) {
                        j_mid[i] = j;

                    }
                }
            }

            if (my_road[70].connected[j_mid[70]].width < 35) {

                int upPoint = 119;
                if (calculate_slope_struct(90, 105, j_mid, RIGHT) >= 0) {
                    int num = 70;
                    upPoint = num;
                    while (num <= 110 && my_road[num].connected[j_mid[num]].left >= left_side[num] + 1) {
                        if (my_road[num].connected[j_mid[num]].left >= my_road[upPoint].connected[j_mid[upPoint]].left - 1
                            ) {
                            upPoint = num;
                        }
                        num++;
                    }

                }
                else {
                    int start = 70;
                    for (int i = start; i <= 110; i++) {
                        if (my_road[i + 1].connected[j_mid[i + 1]].left - my_road[i].connected[j_mid[i]].left < -4
                            && abs(my_road[i - 1].connected[j_mid[i - 1]].right - my_road[i].connected[j_mid[i]].right) <= 2
                            && my_road[i].connected[j_mid[i]].width < 35
                            && my_road[i - 1].connected[j_mid[i - 1]].width < 35
                            ) {
                            upPoint = i;
                            break;
                        }
                    }
                }
                if (80 <= upPoint && upPoint <= 110 && my_road[upPoint + 2].connected[j_mid[upPoint + 2]].width > 36
                    ) {
                    state = stateStart;
                    TFlag = 1;
                }
            }

        }


    }

}

////////////////////////////////////////////
//功能：出T字口开始
//输入：
//输出：
//备注：
///////////////////////////////////////////
void design_cross_T_circle() {

    if (TWhere == RIGHT) {

        uint8_t j_mid[CAMERA_H];
        j_mid[NEAR_LINE] = j_continue[NEAR_LINE];
        for (int i = NEAR_LINE - 1; i >= 2; i--) {
            j_mid[i] = j_continue[i];
            for (int j = 1; j <= my_road[i].white_num; j++) {
                if (abs(my_road[i].connected[j].left - my_road[i + 1].connected[j_mid[i + 1]].left) < abs(my_road[i].connected[j_mid[i]].left - my_road[i + 1].connected[j_mid[i + 1]].left)
                    && my_road[i].connected[j].width > 15) {
                    j_mid[i] = j;
                    //  break;
                }

            }
            left_line[i] = my_road[i].connected[j_mid[i]].left;
            right_line[i] = my_road[i].connected[j_mid[i]].right;
        }
        //////////////printf("dv=%f\n", linear_judgement(80, 100, left_line));
        double dv = linear_judgement(70, 90, left_line);
        double dv2=linear_judgement(50,70,left_line);
        if (dv < 10 && dv2 < 20) {
            for (int i = 70; i <= 90; i++) {
                right_line[i] = left_line[i] + 45;
            }
        }

    }
    else if (TWhere == LEFT) {

        uint8_t j_mid[CAMERA_H];
        j_mid[NEAR_LINE] = j_continue[NEAR_LINE];
        for (int i = NEAR_LINE - 1; i >= 2; i--) {
            j_mid[i] = j_continue[i];
            for (int j = 1; j <= my_road[i].white_num; j++) {
                if (abs(my_road[i].connected[j].right - my_road[i + 1].connected[j_mid[i + 1]].right) < abs(my_road[i].connected[j_mid[i]].right - my_road[i + 1].connected[j_mid[i + 1]].right)
                    && my_road[i].connected[j].width > 15) {
                    j_mid[i] = j;

                }
            }
            left_line[i] = my_road[i].connected[j_mid[i]].left;
            right_line[i] = my_road[i].connected[j_mid[i]].right;
        }
        //////////////printf("dv=%f\n", linear_judgement(80, 100, right_line));
        double dv = linear_judgement(70, 90, right_line);
        double dv2=linear_judgement(50,70,right_line);
        if (dv < 10 && dv2 < 20) {
            for (int i = 70; i <= 90; i++) {
                left_line[i] = right_line[i] - 45;
            }
        }
    }


}

////////////////////////////////////////////
//功能：出T字口开始
//输入：
//输出：
//备注：
///////////////////////////////////////////
void cross_T_out_start() {
    ////////////printf("出回环开始：\n");
    int ctrl_xmax = cross_circle_param2.intVal,ctrl_xmin=cross_circle_param3.intVal;
    if (TWhere == RIGHT) {
        int xMax = 0;
        int yMax = 100;
        double k = calculate_slope_uint(90, 105, left_line);
        ////////////printf("底端斜率:%f\n", k);
        if (fabs(k) < 0.12) {
            if (my_road[70].white_num != 0) {
                int leftDownPoint = 119;
                int rightDownPoint = 119;
                for (int i = NEAR_LINE - 1; i >= 40; i--) {
                    if (my_road[i - 2].white_num != 0) {

                        if (left_line[i - 1] - left_line[i] < -4 && left_line[i - 2] - left_line[i] < -4
                            && abs(left_line[i + 1] - left_line[i]) <= 2 && abs(left_line[i + 2] - left_line[i]) <= 2
                            && right_line[i - 4] - left_line[i - 4] > right_line[i] - left_line[i] + 5
                            && left_line[i] - left_side[i] > 2
                            ) {
                            leftDownPoint = i;
                            break;
                        }

                    }
                    else {
                        break;
                    }
                }
                for (int i = NEAR_LINE - 1; i >= 40; i--) {
                    if (my_road[i - 2].white_num != 0) {
                        if (right_line[i - 1] - right_line[i] > 4 && right_line[i - 2] - right_line[i] > 4
                            && abs(right_line[i + 1] - right_line[i]) <= 2 && abs(right_line[i + 2] - right_line[i]) <= 2
                            && right_line[i - 4] - left_line[i - 4] > right_line[i] - left_line[i] + 5
                            && right_line[i] - right_side[i] < -2
                            ) {
                            rightDownPoint = i;
                            break;
                        }

                    }
                    else {
                        break;
                    }
                }

                if (abs(leftDownPoint - rightDownPoint) <= 6
                    && fabs(calculate_slope_uint(leftDownPoint + 1, leftDownPoint + 14, left_line) - calculate_slope_uint(rightDownPoint + 1, rightDownPoint + 14, right_line)) < 0.2
                    && fabs(calculate_slope_uint(leftDownPoint + 1, leftDownPoint + 14, left_line) - k) < 0.2
                    && fabs(calculate_slope_uint(rightDownPoint + 1, rightDownPoint + 14, right_line) - k) < 0.2
                    ) {
                    yMax = leftDownPoint;
                    xMax = left_line[leftDownPoint];

                    if (yMax < 100 && yMax >= 50) {
                        state = stateTOut;
                    }
                }
            }
        }
        else {
            ////////////printf("倾斜状态：%d\n", my_road[85].white_num);
        //  ////////////printf("")
            if (my_road[85].white_num != 0) {

                for (int i = NEAR_LINE; i >= 30; i--) {
                    if (my_road[i - 1].white_num != 0) {
                        if (left_line[i] >= xMax && abs(left_line[i - 1] - left_line[i]) < 4 && abs(left_line[i + 1] - left_line[i]) < 4
                            && right_line[i] - left_line[i] > 45
                            ) {
                            xMax = left_line[i];
                            yMax = i;
                        }
                    }
                    else {
                        break;
                    }
                }
                ////////////printf("突变点寻找:yMax=%d,xMax=%d\n", yMax, xMax);
                int flag = 1;
                for (int i = yMax; i >= yMax - 18; i--) {
                    if (my_road[i].white_num == 0) {
                        flag = 0;
                    }
                }
                ////////////printf("是否找错：flag=%d\n", flag);
                if (flag == 1) {
                    int change = 119;
                    for (int i = 110; i > yMax; i--) {
                        if (right_line[i - 2] - right_line[i] > 4 && abs(right_line[i] - right_line[i + 1]) <= 2 && abs(right_line[i] - right_line[i + 2]) <= 2
                            ) {
                            change = i;
                            break;
                        }
                    }
                    ////////////printf("另一突变点:%d\n", change);
                    ////////////printf("极值点状况：%f\n", calculate_slope_uint(yMax - 18, yMax - 1, left_line) * calculate_slope_uint(yMax + 2, yMax + 18, left_line));
                    ////////////printf("跳变点上方赛道宽度：%d\n", right_line[change - 2] - left_line[change - 2]);
                    if (calculate_slope_uint(yMax - 18, yMax - 1, left_line) * calculate_slope_uint(yMax + 2, yMax + 18, left_line) <= 0) {
                        if (xMax-ctrl_xmax < 94 && yMax >= 40  && yMax <= 110
                            && change >= yMax && change <= NEAR_LINE && right_line[change - 2] - left_line[change - 2] > 45) {
                            state = stateTOut;
                        }
                    }
                }

            }
        }


    }
    else if (TWhere == LEFT) {
        int xMin = 188;
        int yMin = 100;

        double k = calculate_slope_uint(90, 105, right_line);
        if (fabs(k) < 0.12) {
            if (my_road[70].white_num != 0) {
                int leftDownPoint = 119;
                int rightDownPoint = 119;
                for (int i = NEAR_LINE - 1; i >= 40; i--) {
                    if (my_road[i - 2].white_num != 0) {

                        if (left_line[i - 1] - left_line[i] < -4 && left_line[i - 2] - left_line[i] < -4
                            && abs(left_line[i + 1] - left_line[i]) <= 2 && abs(left_line[i + 2] - left_line[i]) <= 2
                            && right_line[i - 4] - left_line[i - 4] > right_line[i] - left_line[i] + 5
                            && left_line[i] - left_side[i] > 2
                            ) {
                            leftDownPoint = i;
                            break;
                        }

                    }
                    else {
                        break;
                    }
                }
                for (int i = NEAR_LINE - 1; i >= 40; i--) {
                    if (my_road[i - 2].white_num != 0) {
                        if (right_line[i - 1] - right_line[i] > 4 && right_line[i - 2] - right_line[i] < -4
                            && abs(right_line[i + 1] - right_line[i]) <= 2 && abs(right_line[i + 2] - right_line[i]) <= 2
                            && right_line[i - 4] - left_line[i - 4] > right_line[i] - left_line[i] + 5
                            && right_line[i] - right_side[i] < -2
                            ) {
                            rightDownPoint = i;
                            break;
                        }

                    }
                    else {
                        break;
                    }
                }

                if (abs(leftDownPoint - rightDownPoint) <= 4
                    && fabs(calculate_slope_uint(leftDownPoint + 1, leftDownPoint + 14, left_line) - calculate_slope_uint(rightDownPoint + 1, rightDownPoint + 14, right_line)) < 0.2
                    && fabs(calculate_slope_uint(leftDownPoint + 1, leftDownPoint + 14, left_line) - k) < 0.2
                    && fabs(calculate_slope_uint(rightDownPoint + 1, rightDownPoint + 14, right_line) - k) < 0.2
                    ) {
                    yMin = rightDownPoint;
                    xMin = right_line[leftDownPoint];

                    if (yMin < 100 && yMin >= 50) {
                        state = stateTOut;
                    }
                }
            }
        }
        else {
            for (int i = NEAR_LINE; i >= 20; i--) {
                if (my_road[i - 1].white_num != 0) {
                    if (right_line[i] <= xMin) {
                        xMin = right_line[i];
                        yMin = i;
                    }
                }
                else {
                    break;
                }
            }
            int flag = 1;
            for (int i = yMin; i >= yMin - 18; i--) {
                if (my_road[i].white_num == 0) {
                    flag = 0;
                }
            }
            if (flag == 1) {
                int change = 119;
                for (int i = 110; i > yMin; i--) {
                    if (left_line[i - 2] - left_line[i] < -4 && abs(left_line[i] - left_line[i + 1]) <= 2 && abs(left_line[i] - left_line[i + 2]) <= 2
                        ) {
                        change = i;
                    }
                }
                //  ////////////printf("x=%d,y=%d\n", xMin, yMin);
                if (calculate_slope_uint(yMin - 18, yMin - 1, right_line) * calculate_slope_uint(yMin + 2, yMin + 18, right_line) < 0) {
                    if (xMin + ctrl_xmin>= 94 && yMin >= 40 && yMin <= 110
                        && right_line[change - 2] - left_line[change - 2] > 45) {
                        state = stateTOut;
                    }
                }
            }

        }
    }

    //if (my_road[60].white_num != 0) {
    //  if (TWhere == RIGHT) {

    //      int xMax = 0;
    //      int yMax = 100;

    //      for (int i = NEAR_LINE; i >= 50; i--) {
    //          if (my_road[i - 1].white_num != 0) {
    //              if (left_line[i] >= xMax && abs(left_line[i - 1] - left_line[i]) < 4 && abs(left_line[i + 1] - left_line[i]) < 4
    //                  && right_line[i] - left_line[i] > 40
    //                  ) {
    //                  xMax = left_line[i];
    //                  yMax = i;
    //              }
    //          }
    //          else {
    //              break;
    //          }
    //      }
    //      int change = 119;
    //      for (int i = 110; i > yMax; i--) {
    //          if (right_line[i - 2] - right_line[i] > 4 && abs(right_line[i] - right_line[i + 1]) <= 2 && abs(right_line[i] - right_line[i + 2]) <= 2
    //              ) {
    //              change = i;
    //          }
    //      }

    //      if (calculate_slope_uint(yMax - 18, yMax - 1, left_line) * calculate_slope_uint(yMax + 2, yMax + 18, left_line) < 0) {
    //          if (xMax < 94 && yMax >= 80 && yMax <= 110
    //              && change >= yMax && right_line[change - 2] - left_line[change - 2] > 25) {
    //              state = stateTOut;
    //          }
    //      }

    //  }
    //  else if (TWhere == LEFT) {
    //      int xMin = 188;
    //      int yMin = 100;

    //      for (int i = NEAR_LINE; i >= 20; i--) {
    //          if (my_road[i - 1].white_num != 0) {
    //              if (right_line[i] <= xMin) {
    //                  xMin = right_line[i];
    //                  yMin = i;
    //              }
    //          }
    //          else {
    //              break;
    //          }
    //      }
    //      int change = 119;
    //      for (int i = 110; i > yMin; i--) {
    //          if (left_line[i - 2] - left_line[i] < -4 && abs(left_line[i] - left_line[i + 1]) <= 2 && abs(left_line[i] - left_line[i + 2]) <= 2
    //              ) {
    //              change = i;
    //          }
    //      }
    //  //  ////////////printf("x=%d,y=%d\n", xMin, yMin);
    //      if (calculate_slope_uint(yMin - 18, yMin - 1, right_line) * calculate_slope_uint(yMin + 2, yMin + 18, right_line) < 0) {
    //          if (xMin >= 94 && yMin >= 80 && yMin <= 110
    //              && right_line[change - 2] - left_line[change - 2] > 25) {
    //              state = stateTOut;
    //          }
    //      }
    //  }
    //}
}

//int tCro/ssStatus;
////////////////////////////////////////////
//功能：出T字口补线
//输入：
//输出：
//备注：
///////////////////////////////////////////
void design_cross_T_out() {
    double dk = cross_circle_param5.floatVal;
    int width = cross_circle_param4.intVal;
    if (TWhere == RIGHT) {

        for (int i = NEAR_LINE - 1; i >= 2 && left_line[i] != MISS; i--) {
            if (left_line[i + 1] == left_side[i + 1] && i<= 95) left_line[i] = left_side[i];

            right_line[i] = left_line[i] + width + dk * (i - NEAR_LINE);
        }

    }
    else if (TWhere == LEFT) {
        for (int i = NEAR_LINE - 1; i >= 2 && left_line[i] != MISS; i--) {
            if (right_line[i + 1] == right_side[i + 1] && i<=95) right_line[i] = right_side[i];
            left_line[i] = right_line[i] - width - dk * (i - NEAR_LINE);
        }
    }

//    double dk = 0;
//    int lookahead_line = 60;
//    if (TWhere == RIGHT) {
//        int leftPoint = 119;
//        int rightPoint = 119;
//        int mid[CAMERA_H];
//        for (int i = NEAR_LINE; i >= 100; i--) {
//            mid[i] = (left_line[i] + right_line[i]) / 2;
//        }
//
//        double kMid = calculate_slope(100, NEAR_LINE, mid);
//        int direction;
//        double kRange = 0.15;
//        if (fabs(kMid) <= kRange) {
//            direction = 0;
//        }
//        else if (kMid > kRange) {
//            direction = LEFT;
//        }
//        else if (kMid < -1 * kRange) {
//            direction = RIGHT;
//        }
//
//        for (int i = 99; i >= 1; i--) {
//            mid[i] = kMid * (i - 100) + mid[100];
//            if (mid[i] <= left_side[i]) {
//                mid[i] = left_side[i];
//            }
//            if (mid[i] >= right_line[i]) {
//                mid[i] = right_side[i];
//            }
//            //IMG[i][mid[i]] = purple;
//        }
//
//
//
//        uint8_t j_mid[CAMERA_H];
//
//        for (int i = NEAR_LINE; i >= 1; i--) {
//            j_mid[i] = j_continue[i];
//            for (int j = 1; j <= my_road[i].white_num; j++) {
//                if (abs((my_road[i].connected[j].left + my_road[i].connected[j].right) / 2 - mid[i]) < abs((my_road[i].connected[j_mid[i]].left + my_road[i].connected[j_mid[i]].right) / 2 - mid[i])
//                    && my_road[i].connected[j].width > 20) {
//                    j_mid[i] = j;
//                }
//            }
//
//        }
//        uint8_t jumpLine = 119;
//        for (int i = NEAR_LINE - 2; i >= 40; i--) {
//            if (my_road[i - 2].connected[j_mid[i - 2]].width - my_road[i].connected[j_mid[i]].width >= 4
//                && my_road[i - 1].connected[j_mid[i - 1]].width - my_road[i].connected[j_mid[i]].width >= 3
//                && abs(my_road[i + 1].connected[j_mid[i + 1]].width - my_road[i].connected[j_mid[i]].width) <= 3
//                && abs(my_road[i + 2].connected[j_mid[i + 2]].width - my_road[i].connected[j_mid[i]].width) <= 3
//                && my_road[i].connected[j_mid[i]].width < 55
//                && my_road[i].connected[j_mid[i]].right < right_side[i] - 2 && my_road[i].connected[j_mid[i]].left > left_side[i] + 2
//                && my_road[i - 1].white_num != 0
//                ) {
//                jumpLine = i;
//                break;
//            }
//            if (my_road[i].connected[j_mid[i]].left == left_side[i] || my_road[i].connected[j_mid[i]].right == right_side[i]) {
//                break;
//            }
//        }
//        //  printf("jl=%d\n", jumpLine);
//        if (50 <= jumpLine) {
//            if (direction == 0) {
//                int dy = 10;
//                if (my_road[jumpLine - 10].connected[j_mid[jumpLine - 10]].right + 1 >= my_road[jumpLine].connected[j_mid[jumpLine]].right
//                    && my_road[jumpLine - 10].connected[j_mid[jumpLine - 10]].left - 1 <= my_road[jumpLine].connected[j_mid[jumpLine]].left) {
//                    leftPoint = jumpLine;
//                    rightPoint = jumpLine;
//                }
//            }
//            else if (direction == LEFT) {
//                leftPoint = jumpLine;
//                int i = jumpLine;
//                if (jumpLine + 5 > NEAR_LINE) {
//                    i = NEAR_LINE;
//                }
//                rightPoint = i;
//                while (i >= jumpLine - 30 && my_road[i].connected[j_mid[i]].right <= right_side[i] - 3 && my_road[i].connected[j_mid[i]].right <= my_road[NEAR_LINE].connected[j_mid[NEAR_LINE]].right + 15) {
//                    if (my_road[i].connected[j_mid[i]].right <= my_road[rightPoint].connected[j_mid[rightPoint]].right) {
//                        rightPoint = i;
//                    }
//
//                    i--;
//                }
//
//            }
//            else if (direction == RIGHT) {
//                rightPoint = jumpLine;
//                int i = jumpLine;
//                if (i >= NEAR_LINE) {
//                    i = NEAR_LINE;
//                }
//                leftPoint = i;
//                while (i >= jumpLine - 30 && my_road[i].connected[j_mid[i]].left >= left_side[i] + 5 && my_road[i].connected[j_mid[i]].left > my_road[NEAR_LINE].connected[j_mid[NEAR_LINE]].left - 15) {
//                    if (my_road[i].connected[j_mid[i]].left >= my_road[leftPoint].connected[j_mid[leftPoint]].left) {
//                        leftPoint = i;
//                    }
//
//                    i--;
//                }
//            }
//        }
//        //printf("ld=%d,rd=%d\n", leftPoint, rightPoint);
//
//        if (leftPoint >= 110) {
//            leftPoint = 110;
//        }
//        else if (leftPoint < 65) {
//            leftPoint = 65;
//        }
//        if (rightPoint >= 110) {
//            rightPoint = 110;
//        }
//        else if (rightPoint < 50) {
//            rightPoint = 50;
//        }
//        uint8_t yupL = leftPoint;
//        uint8_t yupR = leftPoint;
//        uint8_t xup = left_line[leftPoint];
//
//        int yMin = 110;
//        if (leftPoint <= rightPoint) {
//            yMin = leftPoint;
//        }
//        else {
//            yMin = rightPoint;
//        }
//
//        for (int i = yMin; i >= yMin - 60 && i>=0 ; i--) {
//            if (my_road[i].white_num != 0) {
//                if (left_line[i] <= xup && left_line[i - 1] > xup && i < yupL) {
//                    yupL = i;
//                }
//
//            }
//            else {
//                break;
//            }
//            if (my_road[i].white_num != 0) {
//                if (right_line[i] >= xup && right_line[i - 1] < xup && i < yupR) {
//                    yupR = i;
//                }
//            }
//            else {
//                break;
//            }
//        }
//
//        uint8_t yup = leftPoint;
//        if (yupL < yupR) {
//            yup = yupL;
//        }
//        else {
//            yup = yupR;
//        }
//
//
//        //printf("y=%d,x=%d\n", yup, xup);
//        double k = (double)(xup - right_line[rightPoint]) / (yup - rightPoint);
//        if (left_line[leftPoint] > 90 && (rightPoint > leftPoint + 20 || leftPoint <= lookahead_line)) {
//            k = 0;
//        }
//
//        if (k == 0)//直走
//        {
//            tCrossStatus = 0;
//        }
//
//        else if (k != 0)
//        {
//            tCrossStatus = 1;
//        }
//        for (int i = rightPoint; i >= 2; i--) {
//            right_line[i] = (k + dk) * (i - rightPoint) + right_line[rightPoint];
//            if ((left_line[i] > left_line[i + 1] || left_line[i] == MISS) && i <= leftPoint) {
//                left_line[i] = left_line[i + 1];
//            }
//        }
//
//    }
//
//
//
//
//
//    else if (TWhere == LEFT) {
//        int leftPoint = 119;
//        int rightPoint = 119;
//        int mid[CAMERA_H];
//        for (int i = NEAR_LINE; i >= 100; i--) {
//            mid[i] = (left_line[i] + right_line[i]) / 2;
//        }
//
//        double kMid = calculate_slope(100, NEAR_LINE, mid);
//        int direction;
//        double kRange = 0.15;
//        if (fabs(kMid) <= kRange) {
//            direction = 0;
//        }
//        else if (kMid > kRange) {
//            direction = LEFT;
//        }
//        else if (kMid < -1 * kRange) {
//            direction = RIGHT;
//        }
//
//        for (int i = 99; i >= 1; i--) {
//            mid[i] = kMid * (i - 100) + mid[100];
//            if (mid[i] <= left_side[i]) {
//                mid[i] = left_side[i];
//            }
//            if (mid[i] >= right_line[i]) {
//                mid[i] = right_side[i];
//            }
//            //IMG[i][mid[i]] = purple;
//        }
//
//
//
//        uint8_t j_mid[CAMERA_H];
//
//        for (int i = NEAR_LINE; i >= 1; i--) {
//            j_mid[i] = j_continue[i];
//            for (int j = 1; j <= my_road[i].white_num; j++) {
//                if (abs((my_road[i].connected[j].left + my_road[i].connected[j].right) / 2 - mid[i]) < abs((my_road[i].connected[j_mid[i]].left + my_road[i].connected[j_mid[i]].right) / 2 - mid[i])
//                    && my_road[i].connected[j].width > 20) {
//                    j_mid[i] = j;
//                }
//            }
//
//        }
//        uint8_t jumpLine = 119;
//        for (int i = NEAR_LINE - 2; i >= 50; i--) {
//            if (my_road[i - 2].connected[j_mid[i - 2]].width - my_road[i].connected[j_mid[i]].width >= 4
//                && my_road[i - 1].connected[j_mid[i - 1]].width - my_road[i].connected[j_mid[i]].width >= 3
//                && abs(my_road[i + 1].connected[j_mid[i + 1]].width - my_road[i].connected[j_mid[i]].width) <= 3
//                && abs(my_road[i + 2].connected[j_mid[i + 2]].width - my_road[i].connected[j_mid[i]].width) <= 3
//                && my_road[i].connected[j_mid[i]].width < 55
//                && my_road[i].connected[j_mid[i]].right < right_side[i] - 2 && my_road[i].connected[j_mid[i]].left > left_side[i] + 2
//                && my_road[i - 1].white_num != 0
//                ) {
//                jumpLine = i;
//                break;
//            }
//            if (my_road[i].connected[j_mid[i]].left == left_side[i] || my_road[i].connected[j_mid[i]].right == right_side[i]) {
//                break;
//            }
//        }
//        //printf("jl=%d", jumpLine);
//        if (50 <= jumpLine) {
//            if (direction == 0) {
//                int dy = 10;
//                if (my_road[jumpLine - 10].connected[j_mid[jumpLine - 10]].right + 1 >= my_road[jumpLine].connected[j_mid[jumpLine]].right
//                    && my_road[jumpLine - 10].connected[j_mid[jumpLine - 10]].left - 1 <= my_road[jumpLine].connected[j_mid[jumpLine]].left) {
//                    leftPoint = jumpLine;
//                    rightPoint = jumpLine;
//                }
//            }
//            else if (direction == LEFT) {
//                leftPoint = jumpLine;
//                int i = jumpLine;
//                if (jumpLine + 5 > NEAR_LINE) {
//                    i = NEAR_LINE;
//                }
//                rightPoint = i;
//                while (i >= jumpLine - 30 && my_road[i].connected[j_mid[i]].right <= right_side[i] - 3 && my_road[i].connected[j_mid[i]].right <= my_road[NEAR_LINE].connected[j_mid[NEAR_LINE]].right + 15) {
//                    if (my_road[i].connected[j_mid[i]].right <= my_road[rightPoint].connected[j_mid[rightPoint]].right) {
//                        rightPoint = i;
//                    }
//
//                    i--;
//                }
//
//            }
//            else if (direction == RIGHT) {
//                rightPoint = jumpLine;
//                int i = jumpLine;
//                if (i >= NEAR_LINE) {
//                    i = NEAR_LINE;
//                }
//                leftPoint = i;
//                while (i >= jumpLine - 30 && my_road[i].connected[j_mid[i]].left >= left_side[i] + 5 && my_road[i].connected[j_mid[i]].left > my_road[NEAR_LINE].connected[j_mid[NEAR_LINE]].left - 15) {
//                    if (my_road[i].connected[j_mid[i]].left >= my_road[leftPoint].connected[j_mid[leftPoint]].left) {
//                        leftPoint = i;
//                    }
//
//                    i--;
//                }
//            }
//        }
//        //  printf("ld=%d,rd=%d\n", leftPoint, rightPoint);
//
//        if (leftPoint >= 110) {
//            leftPoint = 110;
//        }
//        else if (leftPoint < 50) {
//            leftPoint = 50;
//        }
//        if (rightPoint >= 110) {
//            rightPoint = 110;
//        }
//        else if (leftPoint < 65) {
//            rightPoint = 65;
//        }
//        uint8_t yupL = rightPoint;
//        uint8_t yupR = rightPoint;
//        uint8_t xup = right_line[rightPoint];
//        int yMin = 110;
//        if (leftPoint <= rightPoint) {
//            yMin = leftPoint;
//        }
//        else {
//            yMin = rightPoint;
//        }
//        for (int i = yMin; i >= yMin - 60; i--) {
//            if (my_road[i].white_num != 0) {
//                if (left_line[i] <= xup && left_line[i - 1] > xup && i < yupL) {
//                    yupL = i;
//                }
//
//            }
//            else {
//                break;
//            }
//            if (my_road[i].white_num != 0) {
//                if (right_line[i] >= xup && right_line[i - 1] < xup && i < yupR) {
//                    yupR = i;
//                }
//            }
//            else {
//                break;
//            }
//        }
//
//        uint8_t yup = rightPoint;
//        if (yupL < yupR) {
//            yup = yupL;
//        }
//        else {
//            yup = yupR;
//        }
//
//        double k = (double)(xup - left_line[leftPoint]) / (yup - leftPoint);
//        if (right_line[rightPoint] < 100 && (rightPoint + 20 < leftPoint || rightPoint <= lookahead_line)){
//            k = 0;
//        }
//        if (k == 0)//直走
//        {
//            tCrossStatus = 0;
//        }
//
//        else if (k != 0)
//        {
//            tCrossStatus = 1;
//        }
//
//        for (int i = leftPoint; i >= 2; i--) {
//            left_line[i] = (k - dk) * (i - leftPoint) + left_line[leftPoint];
//            if ((right_line[i] < right_line[i + 1] || right_line[i] == MISS) && i <= rightPoint) {
//                right_line[i] = right_line[i + 1];
//            }
//        }
//
//
//
//    }

}

////////////////////////////////////////////
//功能：出T字口结束
//输入：
//输出：
//备注：
///////////////////////////////////////////
void cross_T_out_over() {
    ////////////printf("退出回环:\n");
    int flag = 0;
    int sumM = 0;
    for (int i = 105; i >= 65; i--) {
        if (my_road[i].white_num != 0) {
            if (right_line[i] - left_line[i] > 70) {
                //  ////////////printf(">=%d\n", i);
                sumM++;
            }
        }
        else {
            break;
        }
    }
    if (sumM > 10) {
        flag = 1;
    }
    ////////////printf("宽赛道个数:%d\n", sumM);
    if (flag == 0) {

        if (TWhere == LEFT) {
            int flag2 = 0;
            int ymin = NEAR_LINE;
            for (int i = NEAR_LINE; i >= 90; i--) {
                if (left_line[i] <= left_line[ymin]) {
                    ymin = i;
                }

            }


            //  ////////////printf("ym=%d\n", ymin);
            if (ymin >= 105) {
                int start = ymin;
                int sumC = 0;
                for (int i = start; i >= start - 15; i--) {
                    if (left_line[i] < left_line[i + 1] - 1 || left_line[i] > left_line[i + 1] + 5) {
                        sumC++;

                    }
                }
                if (sumC >= 3) {
                    flag2 = 1;
                }
                //////////////printf("%f,%f,%f,%f,%f\n", calculate_slope_uint(start - 15, start - 7, left_line), calculate_slope_uint(start - 7, start - 1, left_line), calculate_slope_uint(start - 13, start, left_line), calculate_slope_uint(start - 10, start - 1, right_line), calculate_slope_uint(start - 11, start - 1, left_line));
                if (fabs(calculate_slope_uint(start - 20, start - 5, left_line) - calculate_slope_uint(start - 13, start - 1, left_line)) < 0.25
                    && calculate_slope_uint(start - 13, start, left_line) > -2.5 && calculate_slope_uint(start - 13, start, left_line) <= 0
                    && flag2 == 0) {
                    if (fabs(calculate_slope_uint(start - 11, start - 1, right_line) - calculate_slope_uint(start - 11, start - 1, left_line)) < 0.25) {
                    //  flagIT = state * TWhere;
                        state = 0;
                        TWhere = 0;

                    }
                    else {
                        //出来内直道过短，看到的是边界
                        int sumR = 0;
                        for (int i = NEAR_LINE; i >= 85; i--) {
                            if (my_road[i].white_num != 0) {
                                if (right_line[i] >= right_side[i] - 1) {
                                    sumR++;
                                }
                            }
                            else {
                                break;
                            }
                        }
                        ////////////printf("lk=%f\n", calculate_slope_uint(start - 13, start, left_line));
                        if (sumR >= 15 && calculate_slope_uint(start - 13, start, left_line) < -1 && calculate_slope_uint(start - 13, start, left_line) > -2.3) {
                            //flagIT = state * TWhere;
                            state = 0;
                            TWhere = 0;

                        }

                    }

                }
            }

        }
        else if (TWhere == RIGHT) {

            int flag2 = 0;

            int ymax = NEAR_LINE;
            for (int i = NEAR_LINE; i >= 70; i--) {
                if (right_line[i] >= right_line[ymax]) {
                    ymax = i;
                }
                if (right_line[i] <= right_line[NEAR_LINE] - 10) {
                    break;
                }

            }
            ////////////printf("最右边点：%d=%d\n", ymax, right_line[ymax]);
            if (ymax >= 105) {

                int start = ymax;
                int sumC = 0;
                for (int i = start; i >= start - 20; i--) {
                    if (right_line[i] > right_line[i + 1] + 1 || right_line[i] < right_line[i + 1] - 5) {
                        sumC++;

                    }
                }
                if (sumC >= 2) {
                    flag2 = 1;
                }
                ////////////printf("出来是直道连续性：%d\n", flag2);
                ////////////printf("线性控制：%f\n", linear_judgement(start - 20, start - 1, right_line));
                ////////////printf("斜率范围：%f \n", calculate_slope_uint(start - 13, start, right_line));
                if (linear_judgement(start - 20,start - 1,right_line) < 15
                    && calculate_slope_uint(start - 13, start, right_line) < 2.5
                    && calculate_slope_uint(start - 13, start, right_line) >= 0
                    && flag2 == 0) {
                    ////////////printf("平行判定:%f\n", fabs(calculate_slope_uint(start - 11, start - 1, left_line) - calculate_slope_uint(start - 11, start - 1, right_line)));
                    if (fabs(calculate_slope_uint(start - 11, start - 1, left_line) - calculate_slope_uint(start - 11, start - 1, right_line)) < 0.3) {
                        //flagIT = state * TWhere;
                        state = 0;
                        TWhere = 0;

                    }
                    else {
                        //出来内直道过短，看到的是边界
                        int sumR = 0;
                        for (int i = NEAR_LINE; i >= 85; i--) {
                            if (my_road[i].white_num != 0) {
                                if (left_line[i] <= left_side[i] + 1) {
                                    sumR++;
                                }
                            }
                            else {
                                break;
                            }
                        }
                        ////////////printf("赛道丢失数量:%d\n", sumR);
                        ////////////printf("斜率限制=%f\n", calculate_slope_uint(start - 13, start, right_line));
                        if (sumR >= 15 && calculate_slope_uint(start - 13, start, right_line) > 1 && calculate_slope_uint(start - 13, start, right_line) < 3) {
                            //flagIT = state * TWhere;
                            state = 0;
                            TWhere = 0;
                            TIslandWhere = 0;

                        }

                    }

                }
            }



        }
    }



}

////////////////////////////////////////////
//功能：进三叉
//输入：
//输出：
//备注：
///////////////////////////////////////////
void folk_road_in() {
    //////printf("\n三叉判定\n");
    uint8_t j_left[CAMERA_H];
    uint8_t j_right[CAMERA_H];
    double k_delta = 0.2;

    j_left[NEAR_LINE] = j_continue[NEAR_LINE];
    j_right[NEAR_LINE] = j_continue[NEAR_LINE];
    uint8_t leftroad[CAMERA_H];
    uint8_t rightroad[CAMERA_H];
    for (int i = NEAR_LINE - 1; i >= FAR_LINE; i--) {
        j_left[i] = j_continue[i];
        j_right[i] = j_continue[i];
        for (int j = 1; j <= my_road[i].white_num; j++) {
            if (abs(my_road[i].connected[j].left - my_road[i + 1].connected[j_left[i + 1]].left) <= abs(my_road[i].connected[j_left[i]].left - my_road[i + 1].connected[j_left[i + 1]].left)
                && my_road[i].connected[j].width > 20) {
                j_left[i] = j;
            }
            if (abs(my_road[i].connected[j].right - my_road[i + 1].connected[j_right[i + 1]].right) <= abs(my_road[i].connected[j_right[i]].right - my_road[i + 1].connected[j_right[i + 1]].right)
                && my_road[i].connected[j].width > 20) {
                j_right[i] = j;
            }
            leftroad[i] = my_road[i].connected[j_left[i]].left;
            rightroad[i] = my_road[i].connected[j_right[i]].right;
        }
        //////printf("%d:%d,%d\n", i, my_road[i].connected[j_left[i]].right, my_road[i].connected[j_right[i]].left);

    }


    if ((linear_judgement_struct(30, 95, j_left, LEFT) < 50)
        || (linear_judgement_struct(30, 95, j_right, RIGHT) < 50)
        ) {

    }
    else {

        uint8_t mid[CAMERA_H];
        for (int i = NEAR_LINE; i >= 90; i--) {
            mid[i] = (left_line[i] + right_line[i]) / 2;
        }
        //////printf("km=%f\n", calculate_slope_uint(95, 110, mid));

        //寻找顶点
        uint8_t top = 119;


        for (int i = 30; i <= 95; i++) {
            if (my_road[i - 1].connected[j_right[i - 1]].left - my_road[i - 1].connected[j_left[i - 1]].right < 20 && my_road[i - 1].connected[j_right[i - 1]].left - my_road[i - 1].connected[j_left[i - 1]].right >= 2
                && my_road[i].connected[j_right[i]].left - my_road[i].connected[j_left[i]].right < 20 && my_road[i].connected[j_right[i]].left - my_road[i].connected[j_left[i]].right >= 1
                && my_road[i + 1].connected[j_right[i + 1]].left - my_road[i + 1].connected[j_left[i + 1]].right < 0
                && my_road[i + 2].connected[j_right[i + 2]].left - my_road[i + 2].connected[j_left[i + 2]].right < 0
                && my_road[i - 1].connected[j_right[i - 1]].left - my_road[i - 1].connected[j_left[i - 1]].right > 0
                && my_road[i - 2].connected[j_right[i - 2]].left - my_road[i - 2].connected[j_left[i - 2]].right > 0
                && my_road[i - 7].connected[j_left[i - 7]].right < my_road[i - 7].connected[j_right[i - 7]].left
                && my_road[i - 5].connected[j_right[i - 5]].left - my_road[i].connected[j_right[i]].left < 25
                && my_road[i - 5].connected[j_right[i - 5]].left - my_road[i].connected[j_right[i]].left >= -1
                && my_road[i - 5].connected[j_left[i - 5]].right - my_road[i].connected[j_left[i]].right > -25
                && my_road[i - 5].connected[j_left[i - 5]].right - my_road[i].connected[j_left[i]].right <= 1) {
                top = i;
                break;
            }

        }
        //////printf("top=%d\n", top);
        if (top != 119) {

            int dSumL = 0;
            double dAverL = 0;
            int dSumR = 0;
            double dAverR = 0;
            for (int i = NEAR_LINE - 5; i >= top + 10; i--) {

                dSumL += my_road[i].connected[j_left[i]].left - my_road[i + 1].connected[j_left[i + 1]].left;
                dAverL = (double)dSumL / (NEAR_LINE - 1 - i);

                dSumR += my_road[i].connected[j_right[i]].right - my_road[i + 1].connected[j_right[i + 1]].right;
                dAverR = (double)dSumR / (NEAR_LINE - 1 - i);
                // ////printf("%d:L:d=%d,da=%f, d-da=%f   R:d=%d,da=%f,d-da=%f \n", i, my_road[i - 1].connected[j_left[i - 1]].left - my_road[i].connected[j_left[i]].left, dAverL, my_road[i - 1].connected[j_left[i - 1]].left - my_road[i].connected[j_left[i]].left - dAverL, my_road[i - 1].connected[j_right[i - 1]].right - my_road[i].connected[j_right[i]].right, dAverR, my_road[i - 1].connected[j_right[i - 1]].right - my_road[i].connected[j_right[i]].right - dAverR);

            }

            uint8_t minR = 119;
            uint8_t minL = 119;
            double cosMinR;
            double cosMinL;
            //cosMinR = -1;

            if (top != 119) {

                for (int i = NEAR_LINE - 5; i >= top + 7; i--) {
                    //////printf("%d:l=%f,r=%f\n", i, linear_judgement(i, NEAR_LINE - 5, leftroad), linear_judgement(i, NEAR_LINE - 5, rightroad));
                    if (linear_judgement(i, NEAR_LINE - 5, leftroad) > 20) {
                        minL = i + 4;
                        break;
                    }
                    /*if (cos_angle(i - 5, i, i + 5, my_road[i - 5].connected[j_right[i - 5]].right, my_road[i].connected[j_right[i]].right, my_road[i + 5].connected[j_right[i + 5]].right) <= -0.4
                        && cos_angle(i - 5, i, i + 5, my_road[i - 5].connected[j_right[i - 5]].right, my_road[i].connected[j_right[i]].right, my_road[i + 5].connected[j_right[i + 5]].right) > -0.85) {
                        if (cos_angle(i - 5, i, i + 5, my_road[i - 5].connected[j_right[i - 5]].right, my_road[i].connected[j_right[i]].right, my_road[i + 5].connected[j_right[i + 5]].right) > cosMinR) {
                            cosMinR = cos_angle(i - 5, i, i + 5, my_road[i - 5].connected[j_right[i - 5]].right, my_road[i].connected[j_right[i]].right, my_road[i + 5].connected[j_right[i + 5]].right);
                            minR = i;
                        }
                    }
                    if (right_line[i - 5] >= right_side[i - 5] - 3) {
                        break;
                    }*/
                    //  ////printf("R:cos%d=%f\n", i, cos_angle(i - 5, i, i + 5, my_road[i - 5].connected[j_right[i - 5]].right, my_road[i].connected[j_right[i]].right, my_road[i + 5].connected[j_right[i + 5]].right));
                }
            }

            //cosMinL = -1;
            if (top != 119) {

                for (int i = NEAR_LINE - 5; i >= top + 7; i--) {
                    if (linear_judgement(i, NEAR_LINE - 5, rightroad) > 20) {
                        minR = i + 4;
                        break;
                    }
                    //      if (cos_angle(i - 5, i, i + 5, my_road[i - 5].connected[j_left[i - 5]].left, my_road[i].connected[j_left[i]].left, my_road[i + 5].connected[j_left[i + 5]].left) <= -0.4
                    //          && cos_angle(i - 5, i, i + 5, my_road[i - 5].connected[j_left[i - 5]].left, my_road[i].connected[j_left[i]].left, my_road[i + 5].connected[j_left[i + 5]].left) > -0.85) {
                    //          if (cos_angle(i - 5, i, i + 5, my_road[i - 5].connected[j_left[i - 5]].left, my_road[i].connected[j_left[i]].left, my_road[i + 5].connected[j_left[i + 5]].left) > cosMinL) {
                    //              cosMinL = cos_angle(i - 5, i, i + 5, my_road[i - 5].connected[j_left[i - 5]].left, my_road[i].connected[j_left[i]].left, my_road[i + 5].connected[j_left[i + 5]].left);
                    //              minL = i;
                    //          }
                    //      }
                    //      if (left_line[i - 5] <= left_side[i - 5] + 3) {
                    //          break;
                    //      }
                    ////        ////printf("L:cos%d=%f\n", i, cos_angle(i - 5, i, i + 5, my_road[i - 5].connected[j_left[i - 5]].left, my_road[i].connected[j_left[i]].left, my_road[i + 5].connected[j_left[i + 5]].left));
                }
            }

            //////printf("top=%d,minl=%d,minR=%d\n", top, minL, minR);

            if (minL < NEAR_LINE - 2 && minR < NEAR_LINE - 2) {

                //先保证两个角找的是准的
                //////printf("dk=%f\n", calculate_slope_struct(top - 7, top - 1, j_left, RIGHT)* calculate_slope_struct(top - 7, top - 1, j_right, LEFT));
                if (fabs(calculate_slope_struct(minL + 1, minL + 15, j_left, LEFT) - calculate_slope_struct(minR + 1, minR + 15, j_right, RIGHT)) < 0.5
                    && calculate_slope_struct(minL - 13, minL - 1, j_left, LEFT) * calculate_slope_struct(minR - 13, minR - 1, j_right, RIGHT) < 0
                    && calculate_slope_struct(top - 7, top - 1, j_left, RIGHT) * calculate_slope_struct(top - 7, top - 1, j_right, LEFT) < 0) {

                    //区分十字
                    int flag1 = 0;
                    if (1) {
                        for (int i = 0; i <= 7; i++) {
                            if (my_road[top - i].connected[j_left[top - i]].right == my_road[top - i].connected[j_right[top - i]].right) {
                                flag1 = -1;
                                break;
                            }
                        }

                        //  ////printf("k1=%f,k2=%f,k3=%f,k4=%f\n", calculate_slope_struct(top - 13, top - 2, j_left, RIGHT), calculate_slope_struct(top - 13, top - 2, j_right, LEFT) ,calculate_slope_struct(minR + 1, minR + 13, j_right, RIGHT), calculate_slope_struct(minL + 1, minL + 13, j_left, LEFT));
                        //  ////printf("dk1=%f,dk2=%f,dk3=%f,dk4=%f\n", fabs(calculate_slope_struct(top - 13, top - 2, j_left, RIGHT) - calculate_slope_struct(minR + 1, minR + 13, j_right, RIGHT)), fabs(calculate_slope_struct(top - 13, top - 2, j_right, LEFT) - calculate_slope_struct(minL + 1, minL + 13, j_left, LEFT)), fabs(calculate_slope_struct(top - 13, top - 2, j_right, LEFT) - calculate_slope_struct(minR + 1, minR + 13, j_right, RIGHT)), fabs(calculate_slope_struct(top - 13, top - 2, j_left, RIGHT) - calculate_slope_struct(minL + 1, minL + 13, j_left, LEFT)));
                        if ((fabs(calculate_slope_struct(top - 13, top - 2, j_left, RIGHT) - calculate_slope_struct(minL + 1, minL + 13, j_left, LEFT)) > 0.7
                            || fabs(calculate_slope_struct(top - 13, top - 2, j_left, RIGHT) - calculate_slope_struct(minL - 13, minL - 1, j_left, LEFT)) < 0.35)
                            && (fabs(calculate_slope_struct(top - 13, top - 2, j_right, LEFT) - calculate_slope_struct(minR + 1, minR + 13, j_right, RIGHT)) > 0.7
                                || fabs(calculate_slope_struct(top - 13, top - 2, j_left, RIGHT) - calculate_slope_struct(minR - 13, minR - 1, j_right, RIGHT)) < 0.35)
                            //  && fabs(calculate_slope_struct(top - 17, top - 2, j_left, RIGHT) - calculate_slope_struct(minL - 13, minL - 1, j_left, LEFT)) <0.25
                            && calculate_slope_struct(top - 7, top, j_left, RIGHT) * calculate_slope_struct(top - 7, top - 0, j_right, LEFT) < 0
                            && flag1 == 0
                            ) {
                            flag1 = 1;
                            //////printf("top=%f,%f\n", calculate_slope_struct(top - 15, top - 2, j_left, RIGHT), calculate_slope_struct(minR + 1, minR + 15, j_right, RIGHT));
                        }
                    }
                    else {
                        //////printf("k1=%f,k2=%f\n", calculate_slope_struct(top - 17, top - 2, j_right, LEFT), calculate_slope_struct(minL + 1, minL + 15, j_left, LEFT));
                        if (fabs(calculate_slope_struct(top - 15, top - 2, j_right, LEFT) - calculate_slope_struct(minL + 1, minL + 15, j_left, LEFT)) > 0.6
                            && fabs(calculate_slope_struct(top - 15, top - 2, j_left, RIGHT) - calculate_slope_struct(minR + 1, minR + 15, j_right, RIGHT)) > 0.6
                            //  && fabs(calculate_slope_struct(top - 17, top - 2, j_right, LEFT) - calculate_slope_struct(minR - 13, minR - 1, j_right, RIGHT)) < 0.25
                            && calculate_slope_struct(top - 10, top - 2, j_left, RIGHT) * calculate_slope_struct(top - 10, top - 2, j_right, LEFT) < 0
                            ) {
                            flag1 = 1;
                        }
                    }
                    //////printf("flag=%d", flag1);
                    if (flag1 == 1 && top >= 20 && minR >= 40 && minL >= 40
                        ) {
                        int mid[CAMERA_H];
                        int min = minR;
                        if (minL > minR) {
                            min = minL;
                        }
                        for (int i = NEAR_LINE; i >= min + 1; i--) {
                            mid[i] = (left_line[i] + right_line[i]) / 2;
                        }
                        double k = calculate_slope(min + 2, NEAR_LINE - 1, mid);

                        int rightRoad[CAMERA_H];
                        int leftRoad[CAMERA_H];

                        for (int i = minL; i >= top - 40 && i >= 0; i--) {
                            leftRoad[i] = k * (i - minL) + left_line[minL];
                            if (leftRoad[i] <= left_side[i]) leftRoad[i] = left_side[i];
                            else if (leftRoad[i] >= right_side[i]) leftRoad[i] = right_side[i];
                            //IMG[i][leftRoad[i]] = purple;
                        }
                        for (int i = minR; i >= top - 40 && i >= 0; i--) {
                            rightRoad[i] = k * (i - minR) + right_line[minR];
                            if (rightRoad[i] <= left_side[i]) rightRoad[i] = left_side[i];
                            else if (rightRoad[i] >= right_side[i]) rightRoad[i] = right_side[i];
                            //IMG[i][rightRoad[i]] = purple;
                        }

                        //两直线内几乎没有赛道

                        int sumN = 0;
                        for (int i = top - 5; i >= top - 40 && i >= 0; i--) {
                            int sumB = 0;
                            for (int j = leftRoad[i] + 1; j < rightRoad[i]; j++) {
                                if (IMG[i][j] == white) {
                                    for (int m = 1; m <= my_road[i].white_num; m++) {
                                        if (my_road[i].connected[m].left <= j && j <= my_road[i].connected[m].right) {
                                            sumB++;
                                        }
                                    }
                                }
                            }
                            if (sumB <= 4 && rightRoad[i] > leftRoad[i]) {
                                sumN++;
                            }
                        }
                        if (sumN >= 15) {
                            //////printf("11\n");
                            state = stateFolkRoadIn;
                        }


                    }


                }
            }

        }
        else {
            int direction = 0;
            uint8_t jumpLine = 119;
            for (int i = NEAR_LINE; i >= 50; i--) {
                if (left_line[i] - left_line[i - 2] >= 6
                    && abs(left_line[i] - left_line[i + 1]) <= 3
                    && abs(right_line[i] - right_line[i - 1]) <= 2
                    ) {
                    direction = LEFT;
                    jumpLine = i;
                    break;
                }
                else if (right_line[i] - right_line[i - 2] <= -6
                    && abs(right_line[i] - right_line[i + 1]) <= 3
                    && abs(left_line[i] - left_line[i - 1]) <= 3
                    ) {
                    direction = RIGHT;
                    jumpLine = i;
                    break;
                }
            }
            //////printf("三叉倾斜方向=%d\n", direction);
            uint8_t minL = 119, minR = 119;
            if (direction == LEFT) {
                minL = jumpLine;
                for (int i = jumpLine; i >= jumpLine - 50; i--) {
                    if (my_road[i].connected[j_right[i]].left - my_road[i + 1].connected[j_right[i + 1]].left > 10
                        && abs(my_road[i].connected[j_right[i]].left - my_road[i - 1].connected[j_right[i - 1]].left) <= 6
                        && my_road[i].connected[j_right[i]].left - my_road[i + 2].connected[j_right[i + 2]].left > 10
                        && my_road[i].connected[j_right[i]].left - my_road[i + 3].connected[j_right[i + 3]].left > 10
                        && abs(my_road[i].connected[j_right[i]].left - my_road[i - 2].connected[j_right[i - 2]].left) <= 6
                        && my_road[i].connected[j_right[i]].width < 65
                        ) {
                        top = i;
                        break;
                    }

                }
                //////printf("top=%d\n", top);
                uint8_t max = minL;
                for (int i = minL; i >= top; i--) {
                    if (my_road[i].connected[j_right[i]].right < my_road[max].connected[j_right[max]].right) {
                        max = i;
                    }
                }
                minR = max;

                int sumLD = 0;
                for (int i = minL; i <= minL + 25 && i<=NEAR_LINE; i++) {
                    if (my_road[i].connected[j_left[i]].left <= left_side[i] + 2) {
                        sumLD++;
                    }
                }

                //////printf("top=%d,minL=%d,minR=%d\n", top, minL, minR);
                //////printf("右下斜率=%f,右上斜率=%f,top斜率=%f\n", calculate_slope_struct(minR + 1, minR + 14, j_right, RIGHT), calculate_slope_struct(minR - 14, minR - 1, j_right, RIGHT), calculate_slope_struct(top - 14, top - 1, j_right, LEFT));
                if (calculate_slope_struct(minR + 1, minR + 14, j_right, RIGHT) >= 0 && calculate_slope_struct(minR - 14, minR - 1, j_right, RIGHT) <= 0
                    && fabs(calculate_slope_struct(minR - 14, minR - 1, j_right, RIGHT) - calculate_slope_struct(top - 14, top - 1, j_right, LEFT)) < 0.6
                    && fabs(calculate_slope_struct(minR + 1, minR + 14, j_right, RIGHT) - calculate_slope_struct(top - 14, top - 1, j_right, LEFT)) > 1
                    && 0 >= calculate_slope_struct(top - 14, top - 1, j_right, LEFT) && calculate_slope_struct(top - 14, top - 1, j_right, LEFT) >= -1.5
                    && top >= 40 && minL >= 50 && minR >= 60
                    && my_road[top].connected[j_right[top]].left > 45
                    && top < minR && minR < minL
                    && sumLD <= 7
                    ) {

                    double k = calculate_slope_struct(minR + 2, minR + 15, j_right, RIGHT);

                    int rightRoad[CAMERA_H];
                    int leftRoad[CAMERA_H];

                    for (int i = minL; i >= top - 40 && i >= 0; i--) {
                        leftRoad[i] = k * (i - minL) + left_line[minL];
                        if (leftRoad[i] <= left_side[i]) leftRoad[i] = left_side[i];
                        else if (leftRoad[i] >= right_side[i]) leftRoad[i] = right_side[i];
                        IMG[i][leftRoad[i]] = purple;
                    }
                    for (int i = minR; i >= top - 40 && i >= 0; i--) {
                        rightRoad[i] = k * (i - minR) + right_line[minR];
                        if (rightRoad[i] <= left_side[i]) rightRoad[i] = left_side[i];
                        else if (rightRoad[i] >= right_side[i]) rightRoad[i] = right_side[i];
                        IMG[i][rightRoad[i]] = purple;
                    }
                    int sumN = 0;
                    for (int i = top - 5; i >= top - 40 && i >= 0; i--) {
                        int sumB = 0;
                        for (int j = leftRoad[i] + 1; j < rightRoad[i]; j++) {
                            if (IMG[i][j] == white) {
                                for (int m = 1; m <= my_road[i].white_num; m++) {
                                    if (my_road[i].connected[m].left <= j && j <= my_road[i].connected[m].right) {
                                        sumB++;
                                    }
                                }
                            }
                        }
                        if (sumB <= 4 && rightRoad[i] > leftRoad[i]) {
                            sumN++;
                        }
                    }
                    if (sumN >= 20) {
                        state = stateFolkRoadIn;
                    }

                }

            }
            else if (direction == RIGHT) {
                minR = jumpLine;
                for (int i = jumpLine; i >= jumpLine - 60 && i>=0 ; i--) {
                    if (my_road[i].connected[j_left[i]].right - my_road[i + 1].connected[j_left[i + 1]].right < -8
                        && abs(my_road[i].connected[j_left[i]].right - my_road[i - 1].connected[j_left[i - 1]].right) <= 6
                        && my_road[i].connected[j_left[i]].right - my_road[i + 2].connected[j_left[i + 2]].right < -8
                        && my_road[i].connected[j_left[i]].right - my_road[i + 3].connected[j_left[i + 3]].right < -8
                        && abs(my_road[i].connected[j_left[i]].right - my_road[i - 2].connected[j_left[i - 2]].right) <= 6
                        && my_road[i].connected[j_left[i]].width < 65
                        ) {
                        top = i;
                        break;
                    }

                }
                //////printf("top=%d\n", top);
                uint8_t max = minL;
                for (int i = minR; i >= top; i--) {
                    if (my_road[i].connected[j_left[i]].left > my_road[max].connected[j_left[max]].left) {
                        max = i;
                    }
                }
                minL = max;
                int sumRD = 0;
                for (int i = minR; i <= minR + 25 && i<=NEAR_LINE; i++) {
                    if (my_road[i].connected[j_right[i]].right >= right_side[i] - 2) {
                        sumRD++;
                    }
                }
                //////printf("top=%d,minL=%d,minR=%d\n", top, minL, minR);//////printf("sum=%d\n", sumRD);
                //////printf("左下斜率=%f,坐上斜率=%f,top斜率=%f\n", calculate_slope_struct(minL + 1, minL + 14, j_left, LEFT), calculate_slope_struct(minL - 14, minL - 1, j_left, LEFT), calculate_slope_struct(top - 14, top - 1, j_left, RIGHT));
                if (calculate_slope_struct(minL + 1, minL + 14, j_left, LEFT) <= 0 && calculate_slope_struct(minL - 14, minL - 1, j_left, LEFT) >= 0
                    && ((fabs(calculate_slope_struct(minL - 14, minL - 1, j_left, LEFT) - calculate_slope_struct(top - 14, top - 1, j_left, RIGHT)) < 0.6))
                    && fabs(calculate_slope_struct(minL + 1, minL + 14, j_left, LEFT) - calculate_slope_struct(top - 14, top - 1, j_left, RIGHT)) > 1
                    && 0 <= calculate_slope_struct(top - 14, top - 1, j_left, RIGHT) && calculate_slope_struct(top - 14, top - 1, j_left, RIGHT) <= 1.5
                    && top >= 25 && minR >= 50 && minL >= 40
                    && my_road[top].connected[j_left[top]].right < 130
                    && top < minL && minL < minR
                    && sumRD <= 7
                    ) {

                    double k = calculate_slope_struct(minL + 2, minL + 15, j_right, LEFT);

                    int rightRoad[CAMERA_H];
                    int leftRoad[CAMERA_H];

                    for (int i = minL; i >= top - 40 && i >= 0; i--) {
                        leftRoad[i] = k * (i - minL) + left_line[minL];
                        if (leftRoad[i] <= left_side[i]) leftRoad[i] = left_side[i];
                        else if (leftRoad[i] >= right_side[i]) leftRoad[i] = right_side[i];
                        IMG[i][leftRoad[i]] = purple;
                    }
                    for (int i = minR; i >= top - 40 && i >= 0; i--) {
                        rightRoad[i] = k * (i - minR) + right_line[minR];
                        if (rightRoad[i] <= left_side[i]) rightRoad[i] = left_side[i];
                        else if (rightRoad[i] >= right_side[i]) rightRoad[i] = right_side[i];
                        IMG[i][rightRoad[i]] = purple;
                    }
                    int sumN = 0;
                    for (int i = top - 5; i >= top - 40 && i >= 0; i--) {
                        int sumB = 0;
                        for (int j = leftRoad[i]; j <= rightRoad[i]; j++) {
                            if (IMG[i][j] == white) {
                                for (int m = 1; m <= my_road[i].white_num; m++) {
                                    if (my_road[i].connected[m].left <= j && j <= my_road[i].connected[m].right) {
                                        sumB++;

                                    }
                                }
                            }
                        }
                        if (sumB <= 4 && rightRoad[i] > leftRoad[i]) {
                            sumN++;
                            //////printf("i=%d\n", i);
                        }
                    }
                    //////printf("sumN=%d\n", sumN);
                    if (sumN >= 20) {
                        state = stateFolkRoadIn;
                    }

                }
            }


        }
    }

}
////////////////////////////////////////////
//功能：进三叉补线
//输入：
//输出：
//备注：
///////////////////////////////////////////
void design_folk_road() {
    //////printf("\n三叉判定\n");
    uint8_t j_left[CAMERA_H];
    uint8_t j_right[CAMERA_H];
    double k_delta = 0;
    int width = 40;
    j_left[NEAR_LINE] = j_continue[NEAR_LINE];
    j_right[NEAR_LINE] = j_continue[NEAR_LINE];
    uint8_t leftroad[CAMERA_H];
    uint8_t rightroad[CAMERA_H];
    for (int i = NEAR_LINE - 1; i >= FAR_LINE; i--) {
        j_left[i] = j_continue[i];
        j_right[i] = j_continue[i];
        for (int j = 1; j <= my_road[i].white_num; j++) {
            if (abs(my_road[i].connected[j].left - my_road[i + 1].connected[j_left[i + 1]].left) <= abs(my_road[i].connected[j_left[i]].left - my_road[i + 1].connected[j_left[i + 1]].left)
                && my_road[i].connected[j].width > 20) {
                j_left[i] = j;
            }
            if (abs(my_road[i].connected[j].right - my_road[i + 1].connected[j_right[i + 1]].right) <= abs(my_road[i].connected[j_right[i]].right - my_road[i + 1].connected[j_right[i + 1]].right)
                && my_road[i].connected[j].width > 20) {
                j_right[i] = j;
            }
            leftroad[i] = my_road[i].connected[j_left[i]].left;
            rightroad[i] = my_road[i].connected[j_right[i]].right;
        }

    }
    int up_move = 5;

    for (int i = NEAR_LINE - up_move - 1; i >= 4; i--) {
        left_line[i] = leftroad[i + up_move];
        right_line[i] = rightroad[i + up_move];
    }

    for (int i = 0; i < up_move; i++) {
        left_line[NEAR_LINE - i] = left_line[NEAR_LINE - up_move];
    }
    for (int i = 0; i < up_move; i++) {
        right_line[NEAR_LINE - i] = right_line[NEAR_LINE - up_move];
    }


    for (int i = NEAR_LINE; i >= 10; i--) {
        if (FolkRoadWhere == LEFT) {
            right_line[i] = left_line[i] + width + k_delta * (i - NEAR_LINE);
            if (i <= NEAR_LINE - 1 && right_line[i] > right_line[i + 1]) right_line[i] = right_line[i + 1];

        }else if (FolkRoadWhere == RIGHT) {
            left_line[i] = right_line[i] - width - k_delta*(i-NEAR_LINE);
            if (i <= NEAR_LINE - 1 && left_line[i] < left_line[i + 1]) left_line[i] = left_line[i + 1];
        }
    }

}
////////////////////////////////////////////
//功能：出三叉
//输入：
//输出：
//备注：
///////////////////////////////////////////
void folk_road_out() {
    //////printf("出三叉判据：k1=%f,k2=%f\n", calculate_slope_uint(70, 90, left_line), calculate_slope_uint(80, 100, right_line));

    if (1) {
        if (FolkRoadWhere == RIGHT) {
            int jumpPoint = 119;
            for (int i = NEAR_LINE - 2; i >= 50; i--) {
                if (left_line[i] - left_line[i + 1] > 5 && left_line[i] - left_line[i + 2] > 5 && fabs(left_line[i] - left_line[i - 1]) < 4 && fabs(left_line[i] - left_line[i - 2]) < 5) {
                    jumpPoint = i;
                    break;
                }
            }

            if (jumpPoint >= 90 && jumpPoint <= NEAR_LINE
                && fabs(calculate_slope_uint(jumpPoint - 15, jumpPoint - 2, left_line) - calculate_slope_uint(jumpPoint - 15, jumpPoint - 2, right_line)) < 0.5
                && calculate_slope_uint(jumpPoint - 15, jumpPoint - 2, left_line) > -1.5 && calculate_slope_uint(jumpPoint - 15, jumpPoint - 2, right_line) > -1.5
                && linear_judgement(jumpPoint - 15, jumpPoint - 2, left_line) < 20 && linear_judgement(jumpPoint - 15, jumpPoint - 2, right_line) < 20
                && right_line[NEAR_LINE - 2] - left_line[NEAR_LINE - 2] > 45

                ) {
                state = 0;
            }
        }
        else if (FolkRoadWhere == LEFT) {
            int jumpPoint = 119;
            for (int i = NEAR_LINE - 2; i >= 50; i--) {
                if (right_line[i] - right_line[i + 1] < -5 && right_line[i] - right_line[i + 2] < -5 && fabs(right_line[i] - right_line[i - 1]) < 4 && fabs(right_line[i] - right_line[i - 2]) < 5) {
                    jumpPoint = i;
                    break;
                }
            }
            if (jumpPoint >= 90 && jumpPoint <= NEAR_LINE
                && fabs(calculate_slope_uint(jumpPoint - 15, jumpPoint - 2, right_line) - calculate_slope_uint(jumpPoint - 11, jumpPoint + 3, left_line)) < 0.5
                && calculate_slope_uint(jumpPoint - 15, jumpPoint - 2, right_line) < 1.5 && calculate_slope_uint(jumpPoint - 11, jumpPoint + 3, left_line) < 1.5
                && linear_judgement(jumpPoint - 15, jumpPoint - 2, right_line) < 20 && linear_judgement(jumpPoint - 11, jumpPoint + 3, left_line) < 20
                && right_line[NEAR_LINE - 2] - left_line[NEAR_LINE - 2] > 45
                ) {
                state = 0;
            }
        }

    }
}


////////////////////////////////////////////
//功能：识别车库离开
//输入：
//输出：
//备注：
///////////////////////////////////////////
void carpark_out()
{
    int flag = 0;
    for (int i = 55; i < 105; i++)
    {
        if (my_road[i + 1].white_num > 4 && my_road[i].white_num > 4 && my_road[i - 1].white_num > 4 && my_road[i - 2].white_num > 3)
        {
            flag = 1;

            if (flag == 1)
            {
                break;
            }

        }
    }

    for (int j = 80; j < 95; j++)
    {
        if (my_road[j].connected[j_continue[j]].width > 50)
        {
            flag = 1;
        }
    }
    //    }
    if (flag == 0) {
        state = 0;

        //carParkTimes += 1;

    }
}

////////////////////////////////////////////
//功能：车库补线
//输入：
//输出：
//备注：
///////////////////////////////////////////
void design_carpark()
{
    //int down_delta = 3, up_delta = 3;
    //int down_jump_point, up_jump_point;
    //float slope, k_left, k_right;
    //float kLeftUp, kRightUp;
    //int i, j;
    //int right_side[105];
    //int connected = 0;
    uint8_t j_mid[CAMERA_H];
    for (int i = NEAR_LINE; i >= 2; i--) {
        j_mid[i] = j_continue[i];
        for (int j = 1; j <= my_road[i].white_num; j++) {
            if (abs(my_road[i].connected[j].right - my_road[i + 1].connected[j_mid[i + 1]].right) < abs(my_road[i].connected[j_mid[i]].right - my_road[i + 1].connected[j_mid[i + 1]].right)
                && my_road[i].connected[j].width > 1
                ) {
                j_mid[i] = j;

            }

        }
    }


    for (int fixLine = 5; fixLine < 105; fixLine++)
    {
        if (rightPark == 1)
        {
            left_line[fixLine] = my_road[fixLine].connected[1].left;

        }
        else if (leftPark == 1)
        {
            right_line[fixLine] = my_road[fixLine].connected[j_mid[fixLine]].right;
        }
    }


    for (int miss_x = 5; miss_x < 105; miss_x++)
    {

        if (rightPark == 1)
        {
            right_line[miss_x] = left_line[miss_x] + 42;


        }
        else if (leftPark == 1)
        {
            left_line[miss_x] = right_line[miss_x] - 42;

        }

    }
}

void protection() {
    int count1 = 0;
    uint8_t* pmap;
    pmap = fullBuffer + 65 * 188;
    for (int i = 0; i < 20; i++)
    {
        pmap = pmap + 50;
        for (int j = 50; j < 138; j++)
        {
            if (*(pmap) < presentTHRE.intVal)
            {
                count1++;
            }
            pmap++;
            //////////////printf("%d  ", *(pmap));
        }
        pmap = pmap + 50;
    }
    //////////////printf("count1=%d  ", count1);
    if (count1 >= 88 * 16) stopFlag = 1;

}



//////////////////////////////////////////
//功能：车库识别
//输入：
//输出：
//备注：
///////////////////////////////////////////
void carpark_in()
{
    //printf("\n斑马线判断\n");
    // rightPark = 1, leftPark = 0;
    uint8_t j_left[CAMERA_H], j_right[CAMERA_H];
    j_right[NEAR_LINE] = j_continue[NEAR_LINE];
    j_left[NEAR_LINE] = j_continue[NEAR_LINE];
    for (int i = NEAR_LINE - 1; i >= 2; i--) {
        j_right[i] = my_road[i].white_num;
        j_left[i] = 1;
        for (int j = my_road[i].white_num; j >= 1; j--) {
            if (abs(my_road[i].connected[j].right - my_road[i + 1].connected[j_right[i + 1]].right) < abs(my_road[i].connected[j_right[i]].right - my_road[i + 1].connected[j_right[i + 1]].right)) {
                j_right[i] = j;
            }
            if (abs(my_road[i].connected[j].left - my_road[i + 1].connected[j_left[i + 1]].left) <= abs(my_road[i].connected[j_left[i]].left - my_road[i + 1].connected[j_left[i + 1]].left)) {
                j_left[i] = j;
            }

        }
        ////printf("%d,l=%d,r=%d\n", i, my_road[i].connected[j_left[i]].left, my_road[i].connected[j_right[i]].right);
    }
    if (rightPark == 1 && leftPark == 0) {
        //找到车库
        int downPoint = 119;
        int upPoint = 119;
        int flag = 0;
        int min;
        if (calculate_slope_struct(90, 105, j_left, LEFT) <= 0) {
            for (int i = 110; i > 60; i--) {
                if (right_line[i] - right_line[i - 1] < -4 && right_line[i] - right_line[i - 2] < -4
                    && abs(right_line[i] - right_line[i + 1]) <= 3 && abs(right_line[i] - right_line[i + 1]) <= 4) {
                    downPoint = i;
                    break;
                }
            }

            int start = downPoint - 50;
            upPoint = start;
            while (start <= downPoint - 5 && my_road[start].connected[j_right[start]].right < my_road[downPoint - 50].connected[j_right[downPoint - 50]].right + 10
                && my_road[start].connected[j_right[start]].right < right_side[start] - 1) {
                if (my_road[start].connected[j_right[start]].right < my_road[upPoint].connected[j_right[upPoint]].right) {
                    upPoint = start;
                }
                start++;
            }
            min = my_road[upPoint].connected[j_right[upPoint]].right;
            if (downPoint < 110 && upPoint <= 110 && upPoint >= 60 && downPoint > 60
                && fabs(calculate_slope_struct(downPoint + 1, downPoint + 15, j_right, RIGHT) - calculate_slope_struct(upPoint - 15, upPoint - 1, j_right, RIGHT)) < 0.25
                && fabs(calculate_slope_struct(downPoint + 1, downPoint + 15, j_left, LEFT) - calculate_slope_struct(upPoint - 15, upPoint - 1, j_left, LEFT)) < 0.25
                ) {
                flag = 1;
            }
        }
        else {
            int start = 110;
            downPoint = 110;

            while (start >= 60 && my_road[start].connected[j_right[start]].right <= my_road[110].connected[j_right[110]].right + 10
                && my_road[start].connected[j_right[start]].right < right_side[start] - 1) {
                if (my_road[start].connected[j_right[start]].right < my_road[downPoint].connected[j_right[downPoint]].right) {
                    downPoint = start;
                }
                start--;
            }

            for (int i = downPoint - 50; i < downPoint; i++) {
                if (my_road[i].connected[j_left[i]].right - my_road[i + 1].connected[j_left[i + 1]].right < -4 && my_road[i].connected[j_left[i]].right - my_road[i + 2].connected[j_left[i + 2]].right < -4
                    && abs(my_road[i].connected[j_left[i]].right - my_road[i - 1].connected[j_left[i - 1]].right) <= 3 && abs(my_road[i].connected[j_left[i]].right - my_road[i - 2].connected[j_left[i - 2]].right) <= 4) {
                    upPoint = i;
                    break;
                }
            }
            if (downPoint < 110 && upPoint <= 110 && upPoint >= 50 && downPoint > 60
                && fabs(calculate_slope_struct(downPoint + 1, downPoint + 15, j_right, RIGHT) - calculate_slope_struct(upPoint - 15, upPoint - 1, j_left, RIGHT)) < 0.25
                && fabs(calculate_slope_struct(downPoint + 1, downPoint + 15, j_left, LEFT) - calculate_slope_struct(upPoint - 15, upPoint - 1, j_left, LEFT)) < 0.25) {
                flag = 1;
            }
            min = my_road[downPoint].connected[j_right[downPoint]].right;
        }

        //printf("down=%d,up=%d\n", downPoint, upPoint);
        ////printf("dl=%f,dr=%f", fabs(calculate_slope_struct(downPoint + 1, downPoint + 15, j_left, LEFT) - calculate_slope_struct(upPoint - 15, upPoint - 1, j_left, LEFT)), fabs(calculate_slope_struct(downPoint + 1, downPoint + 15, j_right, RIGHT) - calculate_slope_struct(upPoint - 15, upPoint - 1, j_right, RIGHT)));
        if (flag == 1
            ) {
                uint8_t counter = 0;
                uint8_t num_black[CAMERA_H] = { 0 };
                uint8_t short_count = 0, mid_count = 0, long_count = 0;
                for (uint8_t i = upPoint - 5; i <= downPoint + 5; i++)
                {
                    uint8_t jEnd = my_road[i].white_num;
                    if (jEnd < 7 && jEnd >= 5) {
                        for (int j = 1; j < jEnd; j++) {
                            if (my_road[i].connected[j + 1].left - my_road[i].connected[j].right <= 5 && my_road[i].connected[j + 1].left - my_road[i].connected[j].right >= 1 && my_road[i].connected[j+1].left <= min
                                && (my_road[i].connected[j + 1].width <= 6 || my_road[i].connected[j].width <= 6)) {
                                counter++;
                            }
                        }
                        if (counter >= 4)
                        {
                            mid_count++;
                            num_black[i] = 2;
                        }
                    }
                    else if (jEnd < 5 && jEnd >= 3) {
                        for (int j = 1; j < jEnd; j++) {
                            if (my_road[i].connected[j + 1].left - my_road[i].connected[j].right <= 5 && my_road[i].connected[j + 1].left - my_road[i].connected[j].right >= 1 && my_road[i].connected[j + 1].left <= min
                                && (my_road[i].connected[j + 1].width <= 6 || my_road[i].connected[j].width <= 6)) {
                                counter++;
                            }
                        }
                        if (counter >= 2)
                        {
                            short_count++;
                            num_black[i] = 1;
                        }

                    }
                    else if (jEnd >= 7) {
                        for (int j = 1; j < jEnd; j++) {
                            if (my_road[i].connected[j + 1].left - my_road[i].connected[j].right <= 5 && my_road[i].connected[j + 1].left - my_road[i].connected[j].right >= 1 && my_road[i].connected[j + 1].left <= min
                                && (my_road[i].connected[j + 1].width <= 6 || my_road[i].connected[j].width <= 6)) {
                                counter++;
                            }
                        }
                        if (counter >= 6)
                        {
                            long_count++;
                            num_black[i] = 3;
                        }
                    }
                }
                //printf("l=%d,s=%d,m=%d\n", long_count, short_count, mid_count);
                if (long_count >= 5) {
                    state = stateParkIn;
                }
                else if (long_count > 0) {
                    if (mid_count >= 4) {
                        int flagUp = 0, flagDown = 0;
                        for (uint8_t i = upPoint - 5; i <= downPoint + 5; i++) {

                            if (num_black[i] == 3) {
                                for (int j = i; j >= upPoint - 5; j--) {
                                    if (num_black[j] == 2) {
                                        flagUp++;
                                    }
                                }
                                for (int j = i; j <= downPoint + 5; j++) {
                                    if (num_black[j] == 2) {
                                        flagDown++;
                                    }
                                }
                                //printf("%d,up=%d,down=%d\n", i, flagUp, flagDown);
                            }
                            if (flagUp >= 1 && flagDown >= 1 && flagUp + flagDown >= 4) {
                                state = stateParkIn;
                                break;
                            }
                        }


                    }
                }
                else {
                    if (mid_count >= 8 && short_count >= 4) {
                        int flagUp = 0, flagDown = 0;
                        for (uint8_t i = upPoint - 5; i <= downPoint + 5; i++) {

                            if (num_black[i] == 2) {
                                for (int j = i; j >= upPoint - 5; j--) {
                                    if (num_black[j] == 1) {
                                        flagUp++;
                                    }
                                }
                                for (int j = i; j <= downPoint + 5; j++) {
                                    if (num_black[j] == 1) {
                                        flagDown++;
                                    }
                                }
                                //printf("%d,up=%d,down=%d\n", i, flagUp, flagDown);
                            }
                            if (flagUp >= 1 && flagDown >= 1 && flagUp + flagDown >= 4) {
                                state = stateParkIn;
                                break;
                            }
                        }
                    }
                    else if (mid_count >= 2 && short_count >= 6) {
                        int flagUp = 0, flagDown = 0;
                        for (uint8_t i = upPoint - 5; i <= downPoint + 5; i++) {

                            if (num_black[i] == 2) {
                                for (int j = i; j >= upPoint - 5; j--) {
                                    if (num_black[j] == 1) {
                                        flagUp++;
                                    }
                                }
                                for (int j = i; j <= downPoint + 5; j++) {
                                    if (num_black[j] == 1) {
                                        flagDown++;
                                    }
                                }
                                //printf("%d,up=%d,down=%d\n", i, flagUp, flagDown);
                            }
                            if (flagUp >= 1 && flagDown >= 1 && flagUp + flagDown >= 6) {
                                state = stateParkIn;
                                break;
                            }
                        }

                    }
                    else if (short_count >= 10) {
                        state = stateParkIn;
                    }
                }

        }
    }
        else if (rightPark == 0 && leftPark == 1) {
            //找到车库
            //printf("左车库\n");
            int downPoint = 119;
            int upPoint = 119;
            int flag = 0;
            int max;
            //printf("跳变方式=%f\n", calculate_slope_struct(85, 100, j_right, RIGHT));
            if (calculate_slope_struct(85, 100, j_right, RIGHT) >= 0) {
                for (int i = 105; i > 50; i--) {
                    if (left_line[i] - left_line[i - 1] > 5 && left_line[i] - left_line[i - 2] > 5
                        && abs(left_line[i] - left_line[i + 1]) <= 3 && abs(left_line[i] - left_line[i + 2]) <= 4) {
                        downPoint = i;
                        break;
                    }
                }

                int start = downPoint - 60;
                upPoint = start;
                while (start <= downPoint - 5
                    && my_road[start].connected[j_left[start]].left > my_road[downPoint - 60].connected[j_left[downPoint - 60]].left - 10
                    && my_road[start].connected[j_left[start]].left > left_side[start] + 1) {
                    if (my_road[start].connected[j_left[start]].left >= my_road[upPoint].connected[j_left[upPoint]].left) {
                        upPoint = start;
                    }
                    start++;
                }
                if (downPoint < 105 && upPoint <= 105 && upPoint >= 30 && downPoint > 30
                    && fabs(calculate_slope_struct(downPoint - 15, downPoint - 1, j_right, RIGHT) - calculate_slope_struct(upPoint + 1, upPoint + 15, j_right, RIGHT)) < 0.3
                    && fabs(calculate_slope_struct(downPoint + 1, downPoint + 15, j_left, LEFT) - calculate_slope_struct(upPoint - 15, upPoint - 1, j_left, LEFT)) < 0.3

                    ) {
                    flag = 1;
                }
                max = my_road[upPoint].connected[j_left[upPoint]].left;
            }
            else {
                int start = 110;
                downPoint = 110;
                while (start >= 60 && my_road[start].connected[j_left[start]].left >= my_road[110].connected[j_left[110]].left - 10
                    && my_road[start].connected[j_left[start]].left > left_side[start] + 1) {
                    if (my_road[start].connected[j_left[start]].left >= my_road[downPoint].connected[j_left[downPoint]].left) {
                        downPoint = start;
                    }
                    start--;
                }
                for (int i = downPoint - 50; i < downPoint; i++) {
                    if (my_road[i].connected[j_right[i]].left - my_road[i + 1].connected[j_right[i + 1]].left > 4 && my_road[i].connected[j_right[i]].left - my_road[i + 2].connected[j_right[i + 2]].left > 4
                        && abs(my_road[i].connected[j_right[i]].left - my_road[i - 1].connected[j_right[i - 1]].left) <= 3 && abs(my_road[i].connected[j_right[i]].left - my_road[i - 2].connected[j_right[i - 2]].left) <= 4) {
                        upPoint = i;
                        break;
                    }

                }
                if (downPoint < 110 && upPoint <= 110 && upPoint >= 50 && downPoint > 60
                    && fabs(calculate_slope_struct(downPoint + 1, downPoint + 15, j_right, RIGHT) - calculate_slope_struct(upPoint - 15, upPoint - 1, j_right, RIGHT)) < 0.25
                    && fabs(calculate_slope_struct(downPoint + 1, downPoint + 15, j_left, LEFT) - calculate_slope_struct(upPoint - 15, upPoint - 1, j_right, LEFT)) < 0.25
                    ) {
                    flag = 1;
                }
                max = my_road[downPoint].connected[j_left[downPoint]].left;
            }
            //printf("下跳变点=%d,上跳变点=%d\n", downPoint, upPoint);
            //printf("平行，大小限幅=%d\n", flag);

            if (flag == 1
                ) {
                uint8_t counter = 0;
                uint8_t num_black[CAMERA_H] = { 0 };
                uint8_t short_count = 0, mid_count = 0, long_count = 0;
                for (uint8_t i = upPoint - 5; i <= downPoint + 5; i++)
                {
                    uint8_t jEnd = my_road[i].white_num;
                    if (jEnd < 7 && jEnd >= 5) {
                        for (int j = 1; j < jEnd; j++) {
                            if (my_road[i].connected[j + 1].left - my_road[i].connected[j].right <= 5 && my_road[i].connected[j + 1].left - my_road[i].connected[j].right >= 1 && my_road[i].connected[j].right >= max
                                && (my_road[i].connected[j + 1].width <= 6 || my_road[i].connected[j].width <= 6)) {
                                counter++;
                            }
                        }
                        if (counter >= 4)
                        {
                            mid_count++;
                            num_black[i] = 2;
                        }
                    }
                    else if (jEnd < 5 && jEnd >= 3) {
                        for (int j = 1; j < jEnd; j++) {
                            if (my_road[i].connected[j + 1].left - my_road[i].connected[j].right <= 5 && my_road[i].connected[j + 1].left - my_road[i].connected[j].right >= 1 && my_road[i].connected[j].right >= max
                                && (my_road[i].connected[j + 1].width <= 6 || my_road[i].connected[j].width <= 6)) {
                                counter++;
                            }
                        }
                        if (counter >= 2)
                        {
                            short_count++;
                            num_black[i] = 1;
                        }

                    }
                    else if (jEnd >= 7) {
                        for (int j = 1; j < jEnd; j++) {
                            if (my_road[i].connected[j + 1].left - my_road[i].connected[j].right <= 5 && my_road[i].connected[j + 1].left - my_road[i].connected[j].right >= 1 && my_road[i].connected[j].right >= max
                                && (my_road[i].connected[j + 1].width <= 6 || my_road[i].connected[j].width <= 6)) {
                                counter++;
                            }
                        }
                        if (counter >= 6)
                        {
                            long_count++;
                            num_black[i] = 3;
                        }
                    }
                }
                //printf("l=%d,s=%d,m=%d\n", long_count, short_count, mid_count);
                if (long_count >= 5) {
                    state = stateParkIn;
                }
                else if (long_count > 0) {
                    if (mid_count >= 4) {
                        int flagUp = 0, flagDown = 0;
                        for (uint8_t i = upPoint - 5; i <= downPoint + 5; i++) {

                            if (num_black[i] == 3) {
                                for (int j = i; j >= upPoint - 5; j--) {
                                    if (num_black[j] == 2) {
                                        flagUp++;
                                    }
                                }
                                for (int j = i; j <= downPoint + 5; j++) {
                                    if (num_black[j] == 2) {
                                        flagDown++;
                                    }
                                }
                                //printf("%d,up=%d,down=%d\n", i, flagUp, flagDown);
                            }
                            if (flagUp >= 1 && flagDown >= 1 && flagUp + flagDown >= 4) {
                                state = stateParkIn;
                                break;
                            }
                        }


                    }
                }
                else {
                    if (mid_count >= 8 && short_count >= 4) {
                        int flagUp = 0, flagDown = 0;
                        for (uint8_t i = upPoint - 5; i <= downPoint + 5; i++) {

                            if (num_black[i] == 2) {
                                for (int j = i; j >= upPoint - 5; j--) {
                                    if (num_black[j] == 1) {
                                        flagUp++;
                                    }
                                }
                                for (int j = i; j <= downPoint + 5; j++) {
                                    if (num_black[j] == 1) {
                                        flagDown++;
                                    }
                                }
                                //printf("%d,up=%d,down=%d\n", i, flagUp, flagDown);
                            }
                            if (flagUp >= 1 && flagDown >= 1 && flagUp + flagDown >= 4) {
                                state = stateParkIn;
                                break;
                            }
                        }
                    }
                    else if (mid_count >= 2 && short_count >= 6) {
                        int flagUp = 0, flagDown = 0;
                        for (uint8_t i = upPoint - 5; i <= downPoint + 5; i++) {

                            if (num_black[i] == 2) {
                                for (int j = i; j >= upPoint - 5; j--) {
                                    if (num_black[j] == 1) {
                                        flagUp++;
                                    }
                                }
                                for (int j = i; j <= downPoint + 5; j++) {
                                    if (num_black[j] == 1) {
                                        flagDown++;
                                    }
                                }
                                //printf("%d,up=%d,down=%d\n", i, flagUp, flagDown);
                            }
                            if (flagUp >= 1 && flagDown >= 1 && flagUp + flagDown >= 6) {
                                state = stateParkIn;
                                break;
                            }
                        }

                    }
                    else if (short_count >= 10) {
                        state = stateParkIn;
                    }
                }
            }
        }
}
////////////////////////////////////////////
//功能：开始入库的标志
//输入：
//输出：
//备注：
///////////////////////////////////////////
int sign_carPark_in() {
    //我们用扫线的方式来确定什么时候开始拐

    int flagBM = 0;
    int sumB = 0, sumB_max = 0;
    int sum_black = 0;
    uint8_t blackNum[CAMERA_H] = { 0 };
    double aveBlack = 0;
    double max_aveBlack = 0;
    int start_black = 119, end_black = 119;
    for (int i = NEAR_LINE; i >= 30; i--) {
        for (int j = 1; j < my_road[i].white_num; j++) {
            if (my_road[i].connected[j + 1].left - my_road[i].connected[j].right >= 1 && my_road[i].connected[j + 1].left - my_road[i].connected[j].right <= 5) {
                blackNum[i]++;
            }
        }

        if (blackNum[i] >= 2 && flagBM == 0) {
            flagBM = 1;
            sumB++;
            sum_black += blackNum[i];
            start_black = i;
        }
        else if (flagBM == 1 && blackNum[i] >= 2) {
            sumB++;
            sum_black += blackNum[i];
        }
        else {

            flagBM = 0;
            if (sumB > sumB_max) {
                sumB_max = sumB;
                if (sumB != 0) {
                    aveBlack = (double)sum_black / sumB;
                }
                end_black = i;
            }
            sum_black = 0;
            sumB = 0;

        }


    }
    ////////////printf("park:%f,%d,e=%d\n", aveBlack, sumB_max, end_black);
    return end_black;


}

////////////////////////////////////////////
//功能：开始入库的标志
//输入：
//输出：
//备注：
///////////////////////////////////////////
void design_carpark_turn() {

    int roof_black_line = sign_carPark_in();
//    test_varible[15]=
    if (roof_black_line >= 30 && roof_black_line <= NEAR_LINE&&carparkflag==0) {
        flagSee++;
        uint8_t j_mid[CAMERA_H];
        uint8_t j_mid2[CAMERA_H];
        if (rightPark == 1 && leftPark == 0) {
            j_mid[NEAR_LINE] = 1;
            for (int i = NEAR_LINE - 1; i > 2; i--) {
                j_mid[i] = 1;
                for (int j = 1; j <= my_road[i].white_num; j++) {
                    if (abs(my_road[i].connected[j].left - my_road[i + 1].connected[j_mid[i + 1]].left) < abs(my_road[i].connected[j_mid[i]].left - my_road[i + 1].connected[j_mid[i + 1]].left)) {
                        j_mid[i] = j;
                    }
                }

            }
            for (int i = NEAR_LINE; i >= 2; i--)
            {
                left_line[i] = my_road[i].connected[j_mid[i]].left;
            }
            double kd = calculate_slope_struct(40, 90, j_mid, LEFT);
            //////printf("kd=%f\n", kd);

            int upPoint = 119;
            int start = roof_black_line;
            while (start >= roof_black_line - 10 && my_road[start].connected[j_mid[start]].right < 94) start--;
            //////printf("start=%d\n", start);
            if (kd >= 0) {

                for (int i = start; i >= roof_black_line - 40; i--) {
                    if ((my_road[i].connected[j_mid[i]].right - my_road[i + 3].connected[j_mid[i + 3]].right < -8
                        && my_road[i].connected[j_mid[i]].right - my_road[i + 2].connected[j_mid[i + 2]].right < -8
                        && abs(my_road[i].connected[j_mid[i]].right - my_road[i - 1].connected[j_mid[i - 1]].right) <= 6
                        && abs(my_road[i].connected[j_mid[i]].right - my_road[i - 2].connected[j_mid[i - 2]].right) <= 6
                        && my_road[i].connected[j_mid[i]].width < 60)
                        ||(abs(my_road[i].connected[j_mid[i]].right - my_road[i - 1].connected[j_mid[i - 1]].right) <= 4
                            && abs(my_road[i].connected[j_mid[i]].right - my_road[i - 2].connected[j_mid[i - 2]].right) <= 4
                            && abs(my_road[i].connected[j_mid[i]].right - my_road[i - 3].connected[j_mid[i - 3]].right) <= 4
                            && abs(my_road[i].connected[j_mid[i]].right - my_road[i - 4].connected[j_mid[i - 4]].right) <= 4
                            && my_road[i].connected[j_mid[i]].width < 60
                            && my_road[i].connected[j_mid[i]].right - my_road[i + 3].connected[j_mid[i + 3]].right < -3)
                        ) {
                        upPoint = i;
                        break;
                    }
                }


            }
            else {
                for (int i = start; i >= roof_black_line - 40; i--) {
                    if ((my_road[i].connected[j_mid[i]].right - my_road[i + 3].connected[j_mid[i + 3]].right < -8
                        && my_road[i].connected[j_mid[i]].right - my_road[i + 2].connected[j_mid[i + 2]].right < -8
                        && abs(my_road[i].connected[j_mid[i]].right - my_road[i - 1].connected[j_mid[i - 1]].right) <= 6
                        && abs(my_road[i].connected[j_mid[i]].right - my_road[i - 2].connected[j_mid[i - 2]].right) <= 6
                        && my_road[i].connected[j_mid[i]].width < 60)
                        || (abs(my_road[i].connected[j_mid[i]].right - my_road[i - 1].connected[j_mid[i - 1]].right) <= 4
                            && abs(my_road[i].connected[j_mid[i]].right - my_road[i - 2].connected[j_mid[i - 2]].right) <= 4
                            && abs(my_road[i].connected[j_mid[i]].right - my_road[i - 3].connected[j_mid[i - 3]].right) <= 4
                            && abs(my_road[i].connected[j_mid[i]].right - my_road[i - 4].connected[j_mid[i - 4]].right) <= 4
                            && my_road[i].connected[j_mid[i]].width < 60
                            && my_road[i].connected[j_mid[i]].right - my_road[i + 3].connected[j_mid[i + 3]].right < -3)
                        ) {
                        upPoint = i;
                        break;
                    }
                }
                if (upPoint == 119)
                {
                    j_mid2[NEAR_LINE] = my_road[NEAR_LINE].white_num;
                    for (int i = NEAR_LINE - 1; i > 2; i--) {
                        j_mid2[i] = my_road[i].white_num;
                        for (int j = 1; j <= my_road[i].white_num; j++) {
                            if (abs(my_road[i].connected[j].right - my_road[i + 1].connected[j_mid2[i + 1]].right) <= abs(my_road[i].connected[j_mid2[i]].right - my_road[i + 1].connected[j_mid2[i + 1]].right)) {
                                j_mid2[i] = j;
                            }
                        }

                    }

                    for (int i = NEAR_LINE; i >= 2; i--)
                    {
                        right_line[i] = my_road[i].connected[j_mid2[i]].right;
                    }

                    int count = 0;
                    int startPoint = roof_black_line + 40;
                    if (startPoint > NEAR_LINE)startPoint = NEAR_LINE;
                    for (int j = startPoint; j >= roof_black_line - 10; j--)
                    {
                        if (abs(right_line[j] - right_side[j])<=3) count++;
                    }
                    //////printf("count=%d", count);
                    if (count > 2)
                    {
                        //int startPoint = roof_black_line +40;
                        for (int i = startPoint; i >= 40; i--)
                        {
                            if (right_line[i] <= right_side[i] - 3
                                && right_line[i - 1] <= right_side[i - 1] - 3
                                && right_line[i - 2] <= right_side[i - 2] - 3
                                && right_line[i+1] > right_side[i+1] - 3
                                && right_line[i + 2] > right_side[i + 2] - 3)
                            {
                                startPoint = i;
                                break;
                            }
                        }
                        //////printf("startPoint=%d\n", startPoint);

                        int num = startPoint;
                        upPoint = startPoint;
                        while (num >= 40 && right_line[num] <= right_side[num] - 1
                            //&& abs(my_road[num - 1].connected[j_mid[num - 1]].left - my_road[num].connected[j_mid[num]].left) <= 4
                            //&& abs(my_road[num + 1].connected[j_mid[num + 1]].left - my_road[num].connected[j_mid[num]].left) <= 4
                            ) {
                            if (right_line[num] <= right_line[upPoint]
                                //&& my_road[num].connected[j_mid[num]].right<right_side[num]-5

                                ) {
                                upPoint = num;
                            }

                            num--;

                        }
                        if (upPoint == startPoint)
                        {
                            upPoint = 119;
                        }
                    }
                }

            }
            int x=search_line.intVal;
            double k;
            if (upPoint < x|| roof_black_line<x+10)
            {
                for (int i = NEAR_LINE; i >= 30; i--)
                {
                    left_line[i] = my_road[i].connected[1].left;
                    right_line[i] = left_line[i] + 45;
                }
            }
            else if (upPoint >= x|| roof_black_line>=x+10)
            {
                if (upPoint < 90|| roof_black_line<100) {
                    k = (double)(my_road[upPoint].connected[j_mid[upPoint]].right - my_road[NEAR_LINE].connected[j_mid[NEAR_LINE]].left) / (upPoint - NEAR_LINE);
                }
                else {
                    k = calculate_slope_uint(70, 90, right_side);
                }

                if (my_road[80].white_num != 0) {
                    for (int i = NEAR_LINE; i >= 20; i--) {
                        left_line[i] = k * (i - NEAR_LINE) + my_road[NEAR_LINE].connected[j_mid[NEAR_LINE]].left;
                        if (left_line[i] > 187)left_line[i] = 187;
                        right_line[i] = right_side[i];
                    }
                }
            }




        }
        else if (rightPark == 0 && leftPark == 1) {
        //int upPoint_x = 0;

            j_mid[NEAR_LINE] = my_road[NEAR_LINE].white_num;
            for (int i = NEAR_LINE - 1; i > 2; i--) {
                j_mid[i] = my_road[i].white_num;
                for (int j = 1; j <= my_road[i].white_num; j++) {
                    if (abs(my_road[i].connected[j].right - my_road[i + 1].connected[j_mid[i + 1]].right) <= abs(my_road[i].connected[j_mid[i]].right - my_road[i + 1].connected[j_mid[i + 1]].right)) {
                        j_mid[i] = j;
                    }
                }

            }
            for (int i = NEAR_LINE; i >= 2; i--)
            {
                right_line[i] = my_road[i].connected[j_mid[i]].right;
            }
            double kd = calculate_slope_struct(40, 90, j_mid, RIGHT);
            //////printf("kd=%f\n", kd);

            int upPoint = 119;
            int start = roof_black_line;
            while (start >= roof_black_line - 10 && my_road[start].connected[j_mid[start]].left > 94) start--;
            //////printf("start=%d\n", start);
            if (kd <= 0) {

                for (int i = start; i >= roof_black_line - 40; i--) {
                    if ((my_road[i].connected[j_mid[i]].left - my_road[i + 3].connected[j_mid[i + 3]].left > 8
                        && my_road[i].connected[j_mid[i]].left - my_road[i + 2].connected[j_mid[i + 2]].left > 8
                        && abs(my_road[i].connected[j_mid[i]].left - my_road[i - 1].connected[j_mid[i - 1]].left) <= 6
                        && abs(my_road[i].connected[j_mid[i]].left - my_road[i - 2].connected[j_mid[i - 2]].left) <= 6
                        && my_road[i].connected[j_mid[i]].width < 60)
                        || (abs(my_road[i].connected[j_mid[i]].left - my_road[i - 1].connected[j_mid[i - 1]].left) <= 4
                            && abs(my_road[i].connected[j_mid[i]].left - my_road[i - 2].connected[j_mid[i - 2]].left) <= 4
                            && abs(my_road[i].connected[j_mid[i]].left - my_road[i - 3].connected[j_mid[i - 3]].left) <= 4
                            && abs(my_road[i].connected[j_mid[i]].left - my_road[i - 4].connected[j_mid[i - 4]].left) <= 4
                            && my_road[i].connected[j_mid[i]].width < 60
                            && my_road[i].connected[j_mid[i]].left - my_road[i + 3].connected[j_mid[i + 3]].left > 3)
                        ) {
                        upPoint = i;
                        break;
                    }
                }
                //if(upPoint!=119)upPoint_x = my_road[upPoint].connected[j_mid[upPoint]].left;

            }
            else {
                for (int i = start; i >= roof_black_line - 40; i--) {
                    if ((my_road[i].connected[j_mid[i]].left - my_road[i + 3].connected[j_mid[i + 3]].left > 8
                        && my_road[i].connected[j_mid[i]].left - my_road[i + 2].connected[j_mid[i + 2]].left > 8
                        && abs(my_road[i].connected[j_mid[i]].left - my_road[i - 1].connected[j_mid[i - 1]].left) <= 6
                        && abs(my_road[i].connected[j_mid[i]].left - my_road[i - 2].connected[j_mid[i - 2]].left) <= 6
                        && my_road[i].connected[j_mid[i]].width < 60)
                        || (abs(my_road[i].connected[j_mid[i]].left - my_road[i - 1].connected[j_mid[i - 1]].left) <= 4
                            && abs(my_road[i].connected[j_mid[i]].left - my_road[i - 2].connected[j_mid[i - 2]].left) <= 4
                            && abs(my_road[i].connected[j_mid[i]].left - my_road[i - 3].connected[j_mid[i - 3]].left) <= 4
                            && abs(my_road[i].connected[j_mid[i]].left - my_road[i - 4].connected[j_mid[i - 4]].left) <= 4
                            && my_road[i].connected[j_mid[i]].width < 60
                            && my_road[i].connected[j_mid[i]].left - my_road[i + 3].connected[j_mid[i + 3]].left > 3)
                        ) {
                        upPoint = i;
                        break;
                    }
                }
                //if (upPoint != 119)upPoint_x = my_road[upPoint].connected[j_mid[upPoint]].left;
                if (upPoint == 119)
                {
                    j_mid2[NEAR_LINE] = 1;
                    for (int i = NEAR_LINE - 1; i > 2; i--) {
                        j_mid2[i] = 1;
                        for (int j = 1; j <= my_road[i].white_num; j++) {
                            if (abs(my_road[i].connected[j].left - my_road[i + 1].connected[j_mid2[i + 1]].left) < abs(my_road[i].connected[j_mid2[i]].left - my_road[i + 1].connected[j_mid2[i + 1]].left)) {
                                j_mid2[i] = j;
                            }
                        }

                    }

                    for (int i = NEAR_LINE; i >= 2; i--)
                    {
                        left_line[i] = my_road[i].connected[j_mid2[i]].left;
                    }

                    int count = 0;
                    int startPoint = roof_black_line + 40;
                    if (startPoint > NEAR_LINE)startPoint = NEAR_LINE;
                    for (int j = startPoint; j >= roof_black_line - 10; j--)
                    {
                        if (abs(left_line[j] - left_side[j]) <= 3) count++;
                    }
                    //////printf("count=%d", count);
                    if (count > 2)
                    {
                        //int startPoint = roof_black_line + 40;
                        for (int i = startPoint; i >= 40; i--)
                        {
                            if (left_line[i] >= left_side[i] + 3
                                && left_line[i - 1] >= left_side[i - 1] + 3
                                && left_line[i - 2] >= left_side[i - 2] + 3
                                && left_line[i + 1] < left_side[i + 1] + 3
                                && left_line[i + 2] < left_side[i + 2] + 3)
                            {
                                startPoint = i;
                                break;
                            }
                        }
                        //////printf("startPoint=%d\n", startPoint);

                        int num = startPoint;
                        upPoint = startPoint;
                        while (num >= 40 && left_line[num] >= left_side[num] + 1

                            ) {
                            if (left_line[num] >= left_line[upPoint]
                                ) {
                                upPoint = num;
                            }

                            num--;

                        }
                        if (upPoint == startPoint)
                        {
                            upPoint = 119;
                        }
                        //////printf("upPoint=%d\n", upPoint);
                    }
                    //if (upPoint != 119)upPoint_x = left_line[upPoint];
                }

            }
            /*
            double k;
            if (upPoint < 75) {
                /*
                int line = 1;
                for (int j = 1; j <= my_road[upPoint].white_num; j++)
                {
                    if (my_road[upPoint].connected[j].width > 20)
                    {
                        line = j;
                        break;
                    }
                }
                k = (double)(my_road[upPoint].connected[line].left - my_road[NEAR_LINE].connected[j_mid[NEAR_LINE]].right) / (upPoint - NEAR_LINE);
                k = (double)(upPoint_x - my_road[NEAR_LINE].connected[j_mid[NEAR_LINE]].right) / (upPoint - NEAR_LINE);
                for (int i = 0; i < 110; i++)
                {
                    IMG[i][upPoint_x] = gray;

                }

            }
            else {
                k = calculate_slope_uint(70, 90, left_side);
            }

            if (my_road[80].white_num != 0) {
                for (int i = NEAR_LINE; i >= 20; i--) {
                    left_line[i] = left_side[i];
                    right_line[i] = k * (i - NEAR_LINE) + my_road[NEAR_LINE].connected[j_mid[NEAR_LINE]].right;
                    if (right_line[i] > right_line[i + 1]) right_line[i] = right_line[i + 1];
                }
            }
            */
            int x=search_line.intVal;
            double k;
            if (upPoint < x || roof_black_line < x+10)
            {
                for (int i = NEAR_LINE; i >= 30; i--)
                {
                    right_line[i] = my_road[i].connected[my_road[i].white_num].right;
                    left_line[i] = right_line[i] - 45;
                }
            }
            else if (upPoint >= x || roof_black_line >= x+10)
            {
                if (upPoint < 90 || roof_black_line < 100) {
                    k = (double)(my_road[upPoint].connected[j_mid[upPoint]].left - my_road[NEAR_LINE].connected[j_mid[NEAR_LINE]].right) / (upPoint - NEAR_LINE);
                }
                else {
                    k = calculate_slope_uint(70, 90, left_side);
                }

                if (my_road[80].white_num != 0) {
                    for (int i = NEAR_LINE; i >= 20; i--) {
                        left_line[i] = left_side[i];
                        right_line[i] = k * (i - NEAR_LINE) + my_road[NEAR_LINE].connected[j_mid[NEAR_LINE]].right;
                        if (right_line[i] > right_line[i + 1]) right_line[i] = right_line[i + 1];
                    }
                }
            }
        }


    }
    else if (roof_black_line == 119 && flagSee >= 10&& carparkflag==0|| carparkflag == 1) {
    carparkflag = 1;
        if (rightPark == 1 && leftPark == 0) {
            uint8_t j_mid[CAMERA_H];
            for (int i = NEAR_LINE - 1; i >= 2; i--) {
                j_mid[i] = j_continue[i];
                for (int j = 1; j <= my_road[i].white_num; j++) {

                    if (abs(my_road[i].connected[j].right - my_road[i + 1].connected[j_mid[i + 1]].right) < abs(my_road[i].connected[j_mid[i]].right - my_road[i + 1].connected[j_mid[i + 1]].right)
                        && my_road[i].connected[j].width > 10) {
                        j_mid[i] = j;

                    }
                }
            }
            for (int i = NEAR_LINE - 1; i >= 30; i--) {
                left_line[i] = my_road[i].connected[j_mid[i]].left;
                right_line[i] = my_road[i].connected[j_mid[i]].right;

                if (right_line[i] < right_line[i + 1] && right_line[i] < right_line[i + 2]) {
                    right_line[i] = right_line[i + 1];
                }
                if (left_line[i] < left_line[i + 1] && i < NEAR_LINE - 10) {
                    left_line[i] = left_line[i + 1];
                }
            }
        }
        else if (rightPark == 0 && leftPark == 1) {
            uint8_t j_mid[CAMERA_H];
            for (int i = NEAR_LINE - 1; i >= 2; i--) {
                j_mid[i] = j_continue[i];
                for (int j = 1; j <= my_road[i].white_num; j++) {
                    if (abs(my_road[i].connected[j].left - my_road[i + 1].connected[j_mid[i + 1]].left) < abs(my_road[i].connected[j_mid[i]].left - my_road[i + 1].connected[j_mid[i + 1]].left)
                        && my_road[i].connected[j].width > 10) {
                        j_mid[i] = j;

                    }
                }
            }
            for (int i = NEAR_LINE - 1; i >= 30; i--) {
                left_line[i] = my_road[i].connected[j_mid[i]].left;
                right_line[i] = my_road[i].connected[j_mid[i]].right;
                if (right_line[i] > right_line[i + 1]&& i < NEAR_LINE - 10) {
                    right_line[i] = right_line[i + 1];
                }
                if (left_line[i] > left_line[i + 1]&& left_line[i] > left_line[i + 2]) {
                    left_line[i] = left_line[i + 1];
                }
            }
        }

    }


}

///////////////////////////////////////////
//功能：车库停车
//输入：
//输出：
//备注：
///////////////////////////////////////////
void carpark_stop() {

    int roof_line = NEAR_LINE;
    for (int i = NEAR_LINE; i >= 60; i--) {
        if (my_road[i - 1].white_num == 0 && my_road[i].white_num != 0) {
            roof_line = i;
            break;
        }
        if (i == 60) {
            return;
        }
    }

    double ljl = linear_judgement(roof_line + 2, NEAR_LINE, left_line);
    double ljr = linear_judgement(roof_line + 2, NEAR_LINE, right_line);
    if (ljl < 10 && ljr < 10) {
        if (roof_line > stopLine.intVal) {
            car_stop = 1;
            state = 140;
        }
    }
    else {
        if (roof_line > stopLine.intVal) {
            car_stop = 1;
            state = 140;
        }
    }
}

void carPark_main()
{
    test_varible[14] = carParkTimes;
//    test_varible[15] = rightPark;
    if (state != stateParkIn)
    {
    //        test_varible[15] = leftPark;


        if(carParkTimes == 0)
        {
            if(file1.intVal == -1)
            {
                leftPark = 0;
                rightPark = 1;

                carpark_in();


            }

            else if(file1.intVal == 0)
            {
                leftPark = 0;
                rightPark = 1;
                carpark_in();

            }

            else if(file1.intVal == 1)
            {
                leftPark = 1;
                rightPark = 0;

                carpark_in();

            }

        }


        if(carParkTimes == 1 && file1.intVal == 1)
        {
            if(parkJudgeCount <= 202)
            {
                parkJudgeCount += 1;

            }

            if(parkJudgeCount > 200 && rampTimes >= 1)
            {
                leftPark = 0;
                rightPark = 1;
                carpark_in();
            }

            else
            {
                leftPark = 1;
                rightPark = 0;
            }
    //            if(folkTimes < 4)
    //            {
    //                leftPark = 1;
    //                rightPark = 0;
    //            }
    //
    //            else if(folkTimes >= 4)
    //            {
    //                state = 0;
    //                leftPark = 0;
    //                rightPark = 1;
    //            }
        }

        else if(carParkTimes == 1 && file1.intVal == -1)
        {
            if(parkJudgeCount <= 22)
            {
                parkJudgeCount += 1;

            }

            if(parkJudgeCount > 20 && tCrossTimes >= 2)
            {
                leftPark = 1;
                rightPark = 0;
                carpark_in();

            }

            else
            {
                leftPark = 0;
                rightPark = 1;
            }


        }
        else if(carParkTimes == 1 && file1.intVal == 0)
        {
//            if(parkJudgeCount <= 202)
//            {
//                parkJudgeCount += 1;
//
//            }
//            leftPark = 1;
//            rightPark = 0;
        }


        else if(carParkTimes == 1 && file1.intVal == 2)
        {
            if(parkJudgeCount <= 202)
            {
                parkJudgeCount += 1;

            }
            leftPark = 0;
            rightPark = 1;
        }
        else if(carParkTimes == 1 && file1.intVal == -2)
        {
            if(parkJudgeCount <= 202)
            {
                parkJudgeCount += 1;

            }
            leftPark = 1;
            rightPark = 0;
        }


    }


    if (state == stateParkIn && carParkTimes < 2)
    {
//        CTRL_encoderCount();
        if(carParkDelay <= parkDelay.intVal)
        {
            carParkDelay += 1;
        }
        int direction = file1.intVal;
//        if(carParkDelay > parkDelay.intVal && carParkTimes < 2 && integerSpeedAver > 2000)
//        {
//            carpark_out();
//
//        }
        if(carParkDelay > parkDelay.intVal && direction == 1 && integerSpeedAver > 2000)
        {
            carpark_out();

        }
        else if(carParkDelay > parkDelay.intVal && direction == -1 && integerSpeedAver > 800)
        {
            carpark_out();

        }
        else if(carParkDelay > parkDelay.intVal && direction == 0 && integerSpeedAver > 500)
        {
//            carpark_out();

        }

//        if(integerSpeedAver > 5000)
//        {
//            state = 0;
//        }
//        design_carpark();
        carpark_stop();

        design_carpark_turn();
    }

    if(carParkTimes == 2 && file1.intVal == 1)
    {
        if(flagStop == 1)
        {
            parkSlowDownCount += 1;

        }
        leftPark = 0;
        rightPark = 1;
//        searchParkLine();
        carpark_stop();
        design_carpark_turn();

    }
    else if(carParkTimes == 2 && file1.intVal == -1)
    {
        if(flagStop == 1)
        {
            parkSlowDownCount += 1;

        }
        leftPark = 1;
        rightPark = 0;
//        searchParkLine();
        carpark_stop();
        design_carpark_turn();
    }
    else if(carParkTimes == 2 && file1.intVal == 0)
    {
//        if(flagStop == 1)
//        {
//            parkSlowDownCount += 1;
//
//        }
//        leftPark = 1;
//        rightPark = 0;
////        searchParkLine();
//        design_carpark_turn();
    }
    else if(carParkTimes == 2 && file1.intVal == 2)
    {
        leftPark = 0;
        rightPark = 1;
//        searchParkLine();

    }
    else if(carParkTimes == 2 && file1.intVal == -2)
    {
        leftPark = 1;
        rightPark = 0;
//        searchParkLine();

    }
}

//void rampwayOn()
//{
//    int rampFlag1 = 0;
//    uint8_t mid_line[120];
//    double k_near_left, k_near_right, k_far_left, k_far_right;
//    k_near_left = calculate_two_point_slope(90, my_road[90].connected[j_continue[90]].left, 50, my_road[50].connected[j_continue[50]].left);
//    k_near_right = calculate_two_point_slope(90, my_road[90].connected[j_continue[90]].right, 50, my_road[50].connected[j_continue[50]].right);
//    k_far_left = calculate_two_point_slope(50, my_road[50].connected[j_continue[50]].left, 20, my_road[20].connected[j_continue[20]].left);
//    k_far_right = calculate_two_point_slope(90, my_road[50].connected[j_continue[50]].right, 20, my_road[20].connected[j_continue[20]].right);
//
//    for(int i=100;i>=10;i--){
//        if(left_line[i]!=MISS){
//            mid_line[i]=(left_line[i] + right_line[i]) / 2;
//        }
//    }
//    int width_max, width_min;
//
//    width_max = 0;
//    width_min =100;
//
//    for(int i=100;i>=10;i--){
//        if(my_road[i].connected[j_continue[i]].width>width_max){
//            width_max=my_road[i].connected[j_continue[i]].width;
//        }
//        if(my_road[i].connected[j_continue[i]].width<width_min){
//            width_min=my_road[i].connected[j_continue[i]].width;
//        }
//    }
//    if(my_road[5].white_num != 0)
//    {
//        if(TFMINI_Distance < rampDistance.intVal && straight_variance(90, 30, 16) == 2)
//        {
//            if(fabs(k_near_left) < 0.5 && fabs(k_near_right) < 0.5 && fabs(k_far_left) < 0.5 && fabs(k_far_right) < 0.5 && fabs(k_near_right - k_far_right) < 0.2 && fabs(k_near_left - k_far_left) < 0.2)
//            {
//                if(width_max - width_min >= rampMin.intVal && width_max - width_min <= rampMax.intVal)
//                {
//                    if(my_road[80].connected[j_continue[80]].width < my_road[40].connected[j_continue[40]].width && my_road[50].connected[j_continue[50]].width < my_road[20].connected[j_continue[20]].width)
//                    {
//                        rampFlag1 = 1;
//
//                    }
//
//                }
//            }
//
//
//        }
//
//    }
//
//    if(rampFlag1 == 1)
//    {
//            state = stateRampway;
////            rampTimes += 1;
//            rampJudgeCount = 0;
//
//    }
//}


///////////////////////////////////////////
//功能：上坡道
//输入：
//输出：
//备注：
///////////////////////////////////////////
void rampwayOn()
{
//    int TFmini_distance;
    //////printf("\n入坡道:\n");
    CTRL_rampGyroUpdate();
//    test_varible[5] = inv_accl[2];
    if(TFMINI_Distance <= rampDistance.intVal && TFMINI_Distance != 0 && inv_accl[2] > 9.75)
    {
        if(my_road[10].white_num != 0){
            int count_dsidth = 0;
            for (int i = 100; i > 20; i--) {
                int up_width = right_line[i - 10] - left_line[i - 10];
                int width = right_line[i] - left_line[i];
                if (up_width - width > 3) {
                    count_dsidth++;
                }
            //////printf("第%d组：差%d,至今有多少%d\n", i,- width + up_width, count_dsidth);

            }

            if (count_dsidth >= 32) {
                int start = 90;
            //////printf("线性：%f,%f,平行%f", linear_judgement(start - 15, start, left_line), linear_judgement(start - 15, start, right_line), fabs(calculate_slope_uint(start - 15, start, left_line) - calculate_slope_uint(start - 15, start, right_line)));
                if(linear_judgement(start - 15,start,left_line) < 10 && linear_judgement(start - 15, start, right_line) < 10
                //&& fabs(calculate_slope_uint(start - 15, start, left_line) - calculate_slope_uint(start - 15, start, right_line)) > 0.2
                ){
                    state = stateRampway;
                }

            }

        }
    }




}
//void rampwayOn()
//{
//    int rampFlag = 0;
//    if(TFMINI_Distance <= rampDistance.intVal && TFMINI_Distance != 0)
//    {
////        for(int i = 80;i <= 100; i++)
////        {
////            if(mid_line[i] > 106 || mid_line[i] < 80)
////            {
//                rampFlag = 1;
////            }
//
////        }
//
//        if(rampFlag == 1)
//        {
//            state = stateRampway;
//            rampTimes += 1;
//        }
//    }
//}

void rampwayDown()
{
    CTRL_rampGyroUpdate();


    if(TFMINI_Distance > 150)
    {
        if(lastTwoState == 0)
        {
            lastTwoState = 1;
        }
    }

    if(TFMINI_Distance < rampDistance.intVal &&TFMINI_Distance != 0 && lastTwoState == 1 && inv_accl[2] < 9.45)
    {
        state = 0;

        rampJudgeCount = 0;

//        GPIO_Set(P22, 0, 0);
    }

}

int midMaxColumn(int istart, int iend, int param, int leftMid, int rightMid)
{

    int count1 = 0;
    int count2 = istart - iend - param;
    for(int i = istart; i > iend; i--)
    {
        if(right_line[i] - left_line[i] < 48 && mid_line[i] >= leftMid && mid_line[i] <= rightMid)
        {
            count1 += 1;
        }

    }
    if(count1 > count2)
    {
        return 1;

    }
    else return 0;


}

int straight_variance(int istart, int iend, float varThreshold)
{
    float k, b;
    int output;
    int sumVar = 0, count = 0;
    float var = 0;
    k = (float)(mid_line[istart] - mid_line[iend]) / (istart - iend);
    for (int i = istart; i > iend; i--)
    {
        output = k * (i - istart) + mid_line[istart];
        output = output - mid_line[i];
        output *= output;
        sumVar += output;
        count += 1;
    }
    var = (float)(sumVar) / count;
//    test_varible[15] = var;

    if (var > varThreshold)
    {
        return 1;
    }
    else if(var <= varThreshold)
    {
        return 2;

    }

    else return 0;
}

int straight_delta(int istart, int iend, int deltaThre)
{
    float k, b;
    int output;
    int sumVar = 0, count = 0;
    float var = 0;
    k = (float)(mid_line[istart] - mid_line[iend]) / (istart - iend);
    for (int i = istart; i > iend; i--)
    {
        output = k * (i - istart) + mid_line[istart];
        output = output - mid_line[i];
        output *= output;
        if(output > deltaThre)
        {
            count += 1;

        }
    }

    return count;
}

void straight_define()
{
//    for(int i = presentVision.intVal;i>60;i--)
//    {
//
//    }

    if(longStrFlag == 0 && shortStrFlag == 0)
    {
        if(calculate_two_point_slope(90, mid_line[90], 10, mid_line[10]) < 0.3 && calculate_two_point_slope(90, mid_line[90], 40, mid_line[40]) < 0.3 && calculate_two_point_slope(90, mid_line[90], 60, mid_line[60]) < 0.3)
        {
            if(straight_variance(90, 10, 10) == 2 && straight_variance(90, 60, 6) == 2 && straight_variance(90, 40, 8) == 2 && straight_delta(90, 20, 49) <= 8)
            {
                longStrFlag = 1;
                shortStrFlag = 0;

            }
        }




    }

    else if(longStrFlag == 1 && shortStrFlag == 0)
    {
        if(!(straight_variance(90, 10, 12) == 2 && straight_variance(90, 60, 8) == 2 && straight_variance(90, 40, 10) == 2 && straight_delta(90, 20, 64) <= 8))
        {
            if(straight_variance(90, 40, 12) == 2 && straight_delta(90, 40, 49) <= 8)
            {
                longStrFlag = 0;
                shortStrFlag = 1;


            }
        }

    }

    else if(longStrFlag == 0 && shortStrFlag == 1)
    {

        if(state == 130 || state == 70)
        {
            longStrFlag = 0;
            shortStrFlag = 0;
        }

        else
        {
            if(straight_variance(80, 45, 10) == 2 && straight_delta(75, 45, 36) <= 8 && calculate_two_point_slope(70, mid_line[70], 30, mid_line[30]) < 0.4)
            {

                longStrFlag = 0;
                shortStrFlag = 1;
            }

            else {
                longStrFlag = 0;
                shortStrFlag = 0;
                lastStraight = 0;

            }
        }
    }

//    test_varible[6] = straightFlag;
}




void roadMemory()
{


}

void small_s_road()
{
    int i1, i2, i3;
    double k1 = 0, k2 = 0, k3 = 0;
    uint8_t aveMidLine;
    for (i1 = 105; i1 > 60; i1--)
    {
        if (mid_line[i1 + 2] == mid_line[i1 + 1] && mid_line[i1 + 1] == mid_line[i1] && mid_line[i1] == mid_line[i1 - 1] && mid_line[i1 - 1] == mid_line[i1 - 2])
        {
            k1 = calculate_two_point_slope(105, mid_line[105], i1, mid_line[i1]);
            break;
        }

    }
    for (i2 = 50; i2 < i1; i2++)
    {
        if (mid_line[i2 + 2] == mid_line[i2 + 1] && mid_line[i2 + 1] == mid_line[i2] && mid_line[i2] == mid_line[i2 - 1] && mid_line[i2 - 1] == mid_line[i2 - 2])
        {
            k2 = calculate_two_point_slope(i1, mid_line[i1], i2, mid_line[i2]);
            break;
        }
    }

    for (i3 = i2; i3 > 30; i3--)
    {
        if (mid_line[i3 + 2] == mid_line[i3 + 1] && mid_line[i3 + 1] == mid_line[i3] && mid_line[i3] == mid_line[i3 - 1] && mid_line[i3 - 1] == mid_line[i3 - 2])
        {

            //break;
        }
        k3 = calculate_two_point_slope(i2, mid_line[i2], 30, mid_line[30]);
    }

    if (fabs(k1) < 0.6 && fabs(k1) > 0.1 && fabs(k2) < 0.1 && fabs(k3) < 0.6 && fabs(k3) > 0.1 && (i1 - i2) > 15)
    {
        sRoadFlag = 1;

    }
}

void s_road_filter()
{
    for(int i = 100; i > 55; i--)
    {
        mid_line[i] = (uint8_t)((mid_line[i] + mid_line[i+1] + mid_line[i+2]) / 3);
    }
}

void mid_line_filter()
{

    for (int i = NEAR_LINE - 4; i > 3; i--)
    {
        if (left_line[i] != MISS && my_road[i].white_num != 0) {
            if (abs(mid_line[i] - mid_line[i + 1]) > 20 && state != stateIslandCircle)
            {
                mid_line[i] = mid_line[i + 1];
            }
            else
            {
                mid_line[i] = (mid_line[i - 1] + mid_line[i] + mid_line[i + 1]) / 3;
            }
        }

    }
    mid_line[0] = mid_line[1] = mid_line[2] = mid_line[3] = mid_line[4];

}

void big_mid_line_filter() {

    for (int i = NEAR_LINE - 3; i > 4; i--)
    {
        if (left_line[i] != MISS && my_road[i].white_num != 0) {
            if (abs(mid_line[i] - mid_line[i + 1]) > 10)
            {
                mid_line[i] = mid_line[i + 1] - (mid_line[i + 1] - mid_line[i]) * 0.1;
            }
            else
            {
                mid_line[i] = (mid_line[i - 3] + mid_line[i - 2] + mid_line[i - 1] + mid_line[i] + mid_line[i + 1] + mid_line[i + 2] + mid_line[i + 3]) / 7;
            }
        }

    }
    mid_line[0] = mid_line[1] = mid_line[2] = mid_line[3] = mid_line[4];

}

uint8_t mid_aver(int way) {
    uint8_t mid;
    uint8_t validRow;
    validRow = valid_row();
    //最平均的算法

    if (way == 1) {
        int32 sum = 0;
        for (int i = 90; i > 10; i--) {
            sum += mid_line[i];
        }
        mid = sum / (90 - 10);
    }
    else if (way == 2) {


        int sumU = 0, sumM = 0, sumD = 0;

        for (int i = 105; i > 75; i--) {
            sumD += mid_line[i];
        }
        for(int i = 75; i > 45; i--) {
            sumM += mid_line[i];
        }
        for (int i = 45; i > 10; i--) {
            sumU += mid_line[i];
        }

        mid = (sumU * 0.3) / (45 - 10) + (sumM * 0.6) / (75 - 45) + (sumD * 0.1) / (105 - 75);
    }

    return mid;
}


uint8_t valid_row()
{
    uint8_t row;
    for(row = NEAR_LINE-2; row >= 10; row--)
    {
        if(my_road[row].white_num != 0 && my_road[row-1].white_num == 0)
        {
            break;
        }

    }
    return row;

}

int8 valid_row_direction()
{
    uint8_t validRow;
    uint8_t leftRowCount = 0,rightRowCount = 0;
    uint8_t rowDelta;

    validRow = valid_row();
    rowDelta = NEAR_LINE - validRow - 2;

    for(int i = NEAR_LINE-2; i > validRow; i--)
    {
        if(mid_line[i] < 94)
        {
            leftRowCount += 1;

        }
        else if(mid_line[i] > 94)
        {
            rightRowCount += 1;
        }

    }
    if(rowDelta > 20)//有效行在92行之前
    {
        if((leftRowCount >= (rowDelta - 5) && rightRowCount <= 5) || leftRowCount - rightRowCount > (rowDelta / 2))//左
        {
            return 1;
        }

        else if((rightRowCount >= (rowDelta - 5) && leftRowCount <= 5) || rightRowCount - leftRowCount > (rowDelta / 2))
        {
            return 2;
        }
        else return 0;

    }

    else if(rowDelta <= 20 && rowDelta >= 2)
    {
        if((leftRowCount >= (rowDelta - 5) && rightRowCount <= 5) || leftRowCount - rightRowCount > (rowDelta / 2))//左
        {
            return 1;
        }

        else if((rightRowCount >= (rowDelta - 5) && leftRowCount <= 5) || rightRowCount - leftRowCount > (rowDelta / 2))
        {
            return 2;
        }
        else return 0;
    }

    else return 0;
}

void TcircleFix()
{
    int8 direction;
    uint8_t validRow;

    validRow = valid_row();

    if(state == stateTIn && validRow > 70)
    {
        direction = valid_row_direction();
        if(direction == 1)
        {
            if(validRow >= cross_circle_param8.intVal)
            {
                pwmFix = (uint32)((validRow - cross_circle_param8.intVal) * cross_circle_param7.floatVal);

            }
            else pwmFix = 0;

        }

        else if(direction == 2)
        {
            if(validRow > cross_circle_param8.intVal)
            {
                pwmFix = (uint32)((cross_circle_param8.intVal - validRow) * cross_circle_param7.floatVal);

            }
            else pwmFix = 0;

        }

    }


//    else if(state == stateIslandCircle && validRow > 70)
//    {
//        direction = islandWhere;
//        if(direction == LEFT)
//        {
//            if(validRow >= cross_circle_param8.intVal)
//            {
//                pwmFix = (uint32)((validRow - cross_circle_param8.intVal) * cross_circle_param7.floatVal);
//
//            }
//            else pwmFix = 0;
//        }
//
//        else if(direction == RIGHT)
//        {
//            if(validRow >= cross_circle_param8.intVal)
//            {
//                pwmFix = (uint32)((cross_circle_param8.intVal - validRow) * cross_circle_param7.floatVal);
//
//            }
//            else pwmFix = 0;
//
//        }
//    }

//    else if(validRow >= cross_circle_param8.intVal)
//    {
//        direction = valid_row_direction();
//        if(direction == 1)//左
//        {
//            if(validRow >= cross_circle_param8.intVal)
//            {
//                pwmFix = (uint32)((validRow - cross_circle_param8.intVal) * cross_circle_param7.floatVal);
//
//            }
//
//        }
//
//        else if(direction == 2)//右
//        {
//            if(validRow >= cross_circle_param8.intVal)
//            {
//                pwmFix = (uint32)((cross_circle_param8.intVal - validRow) * cross_circle_param7.floatVal);
//
//            }
//
//        }
//        else pwmFix = 0;
//    }

    else pwmFix = 0;

//    test_varible[14] = pwmFix;
}

uint8_t IT_averMidLine_foresee()
{
    int way = 2;
    uint8_t averageMidLine;
    float vision1 = mid_line[present_vision], vision2 = mid_line[present_vision - 1], vision3 = mid_line[present_vision - 2], vision4 = mid_line[present_vision + 1],vision5 = mid_line[present_vision + 2];
    float vision6 = mid_line[present_vision - 1],vision7 = mid_line[present_vision + 1];

    if(way == 1)
    {
        averageMidLine = (uint8_t)(vision1 * 0.6 + vision6 * 0.2 + vision7 * 0.2);

    }

    else if(way == 2)
    {
        averageMidLine = (uint8_t)(vision1 * 0.2 + vision2 * 0.2 + vision3 * 0.2 + vision4 * 0.2 + vision5 * 0.2);

    }

    return averageMidLine;
}

uint8_t aver_mid_line_foresee()
{
    int way = 3;
    uint8_t averageMidLine;
    float vision1 = mid_line[present_vision], vision2 = mid_line[present_vision - 5], vision3 = mid_line[present_vision - 10], vision4 = mid_line[present_vision + 5],vision5 = mid_line[present_vision + 10];
    float vision6 = mid_line[present_vision - 1],vision7 = mid_line[present_vision + 1];

    float visionCNT1 = 0, visionCNT2 = 0, visionCNT3 = 0;
    float visionAver1, visionAver2, visionAver3;
    if(way == 1)
    {
        averageMidLine = (uint8_t)(vision1 * 0.6 + vision6 * 0.2 + vision7 * 0.2);

    }

    else if(way == 2)
    {
        averageMidLine = (uint8_t)(vision1 * 0.4 + vision2 * 0.2 + vision3 * 0.1 + vision4 * 0.2 + vision5 * 0.1);

    }

    else if(way == 3)
    {
        for(int i = present_vision + 6; i > present_vision + 3; i--)
        {
            visionCNT1 += mid_line[i];
        }
        visionAver1 = visionCNT1 / 3;

        for(int j = present_vision + 3; j > present_vision - 2; j--)
        {
            visionCNT2 += mid_line[j];
        }
        visionAver2 = visionCNT2 / 5;

        for(int k = present_vision - 2; k > present_vision - 5; k--)
        {
            visionCNT3 += mid_line[k];
        }
        visionAver3 = visionCNT3 / 3;

        averageMidLine = (uint8_t)(visionAver3 * 0.3 + visionAver2 * 0.6 + visionAver1 * 0.1);
    }

    return averageMidLine;
}


////////////////////////////////////////////
//功能：前后求平均位置滤波
//输入：uint8_t left_line[CHANGED_H];//左边线  uint8_t right_line[CHANGED_H];//右边线
//输出：uint8_t left_smooth[CHANGED_H];//左滤波 uint8_t right_smooth[CHANGED_H];//右滤波
//备注：2020.2.19添加 copy学长
///////////////////////////////////////////
void filter_two_line(void)
{
    int gap=5;
    uint8_t left_smooth[CAMERA_H];
    uint8_t right_smooth[CAMERA_H];
    uint8_t i_start;
    uint8_t i_end;
    uint8_t i;
    int j_add = 0;
    uint8_t num = 2;//向上或向下要取多少个点
    uint8_t sum;
    uint8_t left_top = NEAR_LINE - gap, right_top = NEAR_LINE + gap;
    sum = 2 * num + 1;//每个点的值由周围总共几个点决定

    for (i = NEAR_LINE; i >= FAR_LINE; i--)
        if (left_line[i] != MISS)left_top = i;
        else break;

    for (i = NEAR_LINE; i >= FAR_LINE; i--)
        if (right_line[i] != MISS)right_top = i;
        else break;



    //memset(left_smooth, MISS, CHANGED_H);
    //memset(right_smooth, MISS, CHANGED_H);

    //左边界

    i_start = NEAR_LINE - num;
    i_end = left_top + num;

    for (i = NEAR_LINE; i >= i_start + 1; i--)
        left_smooth[i] = left_line[i];

    for (i = i_end - 1; i >= left_top; i--)
        left_smooth[i] = left_line[i];

    j_add = 0;
    for (i = NEAR_LINE; i >= NEAR_LINE - sum + 1; i--)
        j_add += left_line[i];

    for (i = i_start; i >= i_end; i--)
    {
        left_smooth[i] = j_add / sum;
        //IMG[i][left_smooth[i]] = green;
        if (i == i_end)break;
        j_add -= left_line[i + num];
        j_add += left_line[i - num - 1];
    }

    //右边界
    i_start = NEAR_LINE - num;
    i_end = right_top + num;

    for (i = NEAR_LINE; i >= i_start + 1; i--)
        right_smooth[i] = right_line[i];

    for (i = i_end - 1; i >= right_top; i--)
        right_smooth[i] = right_line[i];

    j_add = 0;
    for (i = NEAR_LINE; i >= NEAR_LINE - sum + 1; i--)
        j_add += right_line[i];

    for (i = i_start; i >= i_end; i--)
    {
        right_smooth[i] = j_add / sum;
        //IMG[i][right_smooth[i]] = green;
        if (i == i_end)break;
        j_add -= right_line[i + num];
        j_add += right_line[i - num - 1];
    }
    for (int i = i_start; i <= i_end; i++) {
        left_line[i] = left_smooth[i];
        right_line[i] = right_smooth[i];
    }


}//filter_two_line

void folkTimesCNT()
{
    if(file1.intVal == 1 || file1.intVal == 0)
    {
        if(folkTimes == 0)
        {
            if(integerSpeedAver >= 9000)
            {
                folkCNT = 1;

            }

            if(folkCNT < 1 && state == stateFolkRoadIn) //没有跑到一定距离就识别出三叉 则认为是误识别
            {
                state = 0;
                folkCNT = 0;
            }
        }

        else if(folkTimes == 1 && folkOutTimes == 1)
        {
            if(integerSpeedAver >= 9000 && integerSpeedCNT >= 37000)
            {
                folkCNT = 2;

            }

            if(folkCNT < 2 && state == stateFolkRoadIn) //没有跑到一定距离就识别出三叉 则认为是误识别
            {
                state = 0;
                folkCNT = 1;
            }
        }

        else if(folkTimes == 2 && folkCNT == 2 && folkOutTimes == 2)
        {
            if(integerSpeedAver >= 6000 && integerSpeedCNT > 140000 && islandTimesCNT == 2)
            {
                folkCNT = 3;

            }

            if(folkCNT < 3 && state == stateFolkRoadIn) //没有跑到一定距离就识别出三叉 则认为是误识别
            {
                state = 0;
                folkCNT = 2;
            }
        }

        else if(folkTimes == 3 && folkCNT == 3 && folkOutTimes == 3)
        {
            if(integerSpeedAver >= 3500 && integerSpeedCNT >= 140000)
            {
                folkCNT = 4;
            }

            if(folkCNT < 4 && state == stateFolkRoadIn) //没有跑到一定距离就识别出三叉 则认为是误识别
            {
                state = 0;
                folkCNT = 3;
            }
        }
    }

    else if(file1.intVal == -1)
    {
        if(folkTimes == 0)
        {
            if(integerSpeedAver >= 2500)
            {
                folkCNT = 1;

            }

            if(folkCNT < 1 && state == stateFolkRoadIn) //没有跑到一定距离就识别出三叉 则认为是误识别
            {
                state = 0;
                folkCNT = 0;
            }
        }

        else if(folkTimes == 1 && folkOutTimes == 1)
        {
            if(rampTimes == 1)
            {
                folkCNT = 2;

            }

            if(folkCNT < 2 && state == stateFolkRoadIn) //没有跑到一定距离就识别出三叉 则认为是误识别
            {
                state = 0;
                folkCNT = 1;
            }
        }

        else if(folkTimes == 2 && folkCNT == 2 && folkOutTimes == 2)
        {
            if(integerSpeedAver >= 4000 &&islandTimesCNT == 2)
            {
                folkCNT = 3;

            }

            if(folkCNT < 3 && state == stateFolkRoadIn) //没有跑到一定距离就识别出三叉 则认为是误识别
            {
                state = 0;
                folkCNT = 2;
            }
        }

        else if(folkTimes == 3 && folkCNT == 3 && folkOutTimes == 3)
        {
            if(integerSpeedAver >= 3500)
            {
                folkCNT = 4;
            }

            if(folkCNT < 4 && state == stateFolkRoadIn) //没有跑到一定距离就识别出三叉 则认为是误识别
            {
                state = 0;
                folkCNT = 3;
            }
        }
    }
//    else if(folkTimes == 4)
//    {
//
//    }
}


////////////////////////////////////////////
//功能：直道加速
//输入：
//输出：
//备注：
///////////////////////////////////////////
void accelerate() {

    if (linear_judgement(50, 70, left_line) <= 15
        && linear_judgement(50, 70, right_line) <= 15//前方赛道预警，快到弯道也不能加速
        && linear_judgement(75, 95, left_line) <= 15
        && linear_judgement(75, 95, right_line) <= 15// 前瞻附近赛道是否是直道
        && fabs(calculate_slope_uint(75, 95, left_line)) < 0.3
        && fabs(calculate_slope_uint(75, 95, right_line)) < 0.3//太歪的直道也不敢加速
        && fabs(calculate_slope_uint(75, 95, left_line) - calculate_slope_uint(75, 95, right_line))<0.35//保证赛道平行
        ) {
        flag_straight = 1;
    }
    else {
        flag_straight = 0;
    }



    //////////////printf("accelaerate = %d\n", flag_straight);
}
